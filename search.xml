<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac中ios模拟器的常用操作]]></title>
    <url>%2F2019%2F05%2F26%2F190526mac%E4%B8%ADios%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[下面主要列出了以下几个常用的命令，包括：查找ios模拟器中包含哪些机型、启动ios模拟器中的指定机型。 1、查找ios模拟器中包含哪些机型1instruments -s 会输出以下模拟机型，也就是说可以启动以下这些机型进行模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Known Devices:lsqy的MacBook Pro Apple TV (12.2) [CD901014-4F0C-46C3-AE9A-A22AC37493FB] (Simulator)Apple TV 4K (12.2) [31425E49-958D-40E3-8393-93EA246943F0] (Simulator)Apple TV 4K (at 1080p) (12.2) [6E1C2AFC-32DD-4CC5-A280-8049BD3B8A1A] (Simulator)Apple Watch Series 2 - 38mm (5.2) [26759A5E-00B9-4BD4-A5D2-5AE544DA841B] (Simulator)Apple Watch Series 2 - 42mm (5.2) [33BA7025-31F7-42A7-817B-A4A70CFC60A8] (Simulator)Apple Watch Series 3 - 38mm (5.2) [03739305-4300-452F-BB8B-8671854BD210] (Simulator)Apple Watch Series 3 - 42mm (5.2) [CE4486B9-E587-4AC8-9821-9E50D7FF8BFB] (Simulator)iPad (5th generation) (12.2) [D46751EA-EDD9-4C92-8652-14F339A8372C] (Simulator)iPad (6th generation) (12.2) [20A0FEF8-C34F-4960-B7DF-AA2A7A9EEEF6] (Simulator)iPad Air (12.2) [ED0958FA-0C6B-4E2E-B87D-9B272F49C9AD] (Simulator)iPad Air (3rd generation) (12.2) [E981EDDA-587C-4194-84A8-B018E909046B] (Simulator)iPad Air 2 (12.2) [F1000542-2E19-415D-A6A6-C791D07BC504] (Simulator)iPad Pro (10.5-inch) (12.2) [F950D852-A65E-4797-9B23-53C0A2510815] (Simulator)iPad Pro (11-inch) (12.2) [B34F8807-15F1-45F2-966D-65BBB45A2FEB] (Simulator)iPad Pro (12.9-inch) (12.2) [5BFA185B-E0FB-43ED-8991-B79982ECE0F8] (Simulator)iPad Pro (12.9-inch) (2nd generation) (12.2) [DCE2842B-AF9A-40CC-AAC6-D6F12828C937] (Simulator)iPad Pro (12.9-inch) (3rd generation) (12.2) [8EBD2F29-9C1E-42C6-B95D-2F3273CEB56E] (Simulator)iPad Pro (9.7-inch) (12.2) [79CEBBA2-5665-44D2-BC2D-EF01E971672B] (Simulator)iPhone 5s (12.2) [0A515BFC-2C47-4093-B80E-85BE96712436] (Simulator)iPhone 6 (12.2) [5D695AAE-8D35-4F30-8885-740A85F22AB6] (Simulator)iPhone 6 Plus (12.2) [8A39537F-0EED-4244-A114-223AF0126B0C] (Simulator)iPhone 6s (12.2) [1913C53F-394E-446E-A3A7-4DAA87F9D578] (Simulator)iPhone 6s Plus (12.2) [B2937386-20A9-4ACC-A63E-982BC10F661C] (Simulator)iPhone 7 (12.2) [A3D3511E-AB79-4849-B104-3D9803198203] (Simulator)iPhone 7 Plus (12.2) [7A47C656-0C7A-4002-98D0-CB0F6167C138] (Simulator)iPhone 8 (12.2) [D6083F0A-967F-40D8-88C2-684BDB927B99] (Simulator)iPhone 8 Plus (12.2) [980B8AED-7F44-4D95-A6F7-AAF561F88883] (Simulator)iPhone SE (12.2) [09A3F89A-4BFE-4B4D-8793-8D5C1B4B1E36] (Simulator)iPhone X (12.2) [E374247E-832D-4B61-804D-1C085CA897BD] (Simulator)iPhone Xs (12.2) [DDDF0B87-7295-417B-9A85-27441B4282AD] (Simulator)iPhone Xs (12.2) + Apple Watch Series 4 - 40mm (5.2) [6E29B703-74F6-40C7-99A8-0D9CEB5A9777] (Simulator)iPhone Xs Max (12.2) [F74F45D2-29EA-4490-8490-933FC4084BEA] (Simulator)iPhone Xs Max (12.2) + Apple Watch Series 4 - 44mm (5.2) [B710C546-C80C-400C-829B-8487D411BF6E] (Simulator)iPhone Xʀ (12.2) [7E8332CC-2279-40CE-B86B-AD7D21227D0A] (Simulator)Known Templates:&quot;Activity Monitor&quot;&quot;Allocations&quot;&quot;Blank&quot;&quot;Core Animation&quot;&quot;Core Data&quot;&quot;Counters&quot;&quot;Energy Log&quot;&quot;File Activity&quot;&quot;Game Performance&quot;&quot;Leaks&quot;&quot;Metal System Trace&quot;&quot;Network&quot;&quot;SceneKit&quot;&quot;System Trace&quot;&quot;System Usage&quot;&quot;Time Profiler&quot;&quot;Zombies&quot; 2、启动ios模拟器中的指定机型 注意启动的时候要将名称输入完全，比如如果要启动iPhone X，则需要将后面括号里的内容也带上iPhone X (12.2)，要不然模拟器会不知道要具体启动哪个机型 1xcrun instruments -w &apos;iPhone X (12.2)&apos;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>ios模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置create-react-app支持less]]></title>
    <url>%2F2019%2F01%2F22%2F190122%E9%85%8D%E7%BD%AEcreate-react-app%E6%94%AF%E6%8C%81less%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;使用create-react-app初始化出来的项目默认是不支持less的，对于一些习惯于用less的人来说就不太方便了，现在记录下来改造的方法，使其可以支持less。 安装依赖项1npm install --save-dev less less-loader 修改react-scripts中的webpack配置 我这里使用的react-scripts的版本是2.1.3，修改的webpack文件地址位于node_modules/react-scripts/config/webpack.config.js 12345678910111213141516修改第48行将const cssRegex = /\.css$/；修改为const cssRegex = /\.(css|less)$/；修改第441行开始&#123; test: cssRegex, exclude: cssModuleRegex, use: getStyleLoaders(&#123; importLoaders: 1, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, &apos;less-loader&apos;), // 主要是修改这里，在这里将less-loader加上 // Don&apos;t consider CSS imports dead code even if the // containing package claims to have no side effects. // Remove this when webpack adds a warning or an error for this. // See https://github.com/webpack/webpack/issues/6571 sideEffects: true,&#125;, 这样不方便的就是需要手动进行这个操作，所以就是在项目刚开始的时候注意下，配置好以后就可以了~]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>create-react-app</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs sleep with async/await]]></title>
    <url>%2F2018%2F11%2F22%2F181122Nodejs-sleep-with-async-await%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;在日常开发过程当中，难免有时候需要自己通过Nodejs mock一些数据，如果直接返回的话，在前端展示层面看起来不太真实，所以需要在Nodejs这一层进行下sleep处理，下面简单记录下使用async/await实现的方法,当然还有一些其他的实现方法，比如generator的实现，原理跟这个差不多，就不赘述了。 12345678910111213// ms是需要sleep的毫秒数const sleep = ms =&gt; &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms))&#125;// 伪代码如下async function testSleep() &#123; console.log(&apos;start&apos;); await sleep(3000); console.log(&apos;end&apos;);&#125;testSleep() 优缺点缺陷是程序需要在async域里执行。优点是这种方式实际上是用了setTimeout，没有形成进程阻塞，不会造成性能和负载问题。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Nodejs</tag>
        <tag>工具方法</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决微信jssdk在部分安卓和ios设备中签名失败的问题]]></title>
    <url>%2F2018%2F04%2F29%2F180429%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1jssdk%E5%9C%A8%E9%83%A8%E5%88%86%E5%AE%89%E5%8D%93%E5%92%8Cios%E8%AE%BE%E5%A4%87%E4%B8%AD%E7%AD%BE%E5%90%8D%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在微信上用history模式开发单页应用时，使用的是react+react-router,遇到了一个比较闹心的问题，就是在有的安卓和ios设备上会出现无法调用微信js-sdk的问题，而我这边有一个需求是需要继续微信的拍照上传等能力的，经过各种尝试，总算目前似乎算找到了一种解决的办法，下面记录一下. 遇到的问题调取选择图片或者拍照在部分ios上可以，大多数安卓不可以这个试错的过程中真是怀疑了很多可能，就不一一列出了，总之以后多加注意了。 正确配置因为history模式每次切换path会发生变化，所以如果在变化之后的页面需要调用sdk，那么就需要重新进行下微信的config，所以我在项目的utils下封装了一个重新进行微信config的方法，下面这个是最终得出的一个正确的配置，过程中真的是很不顺利，最终竟然是在config前加了一个setTimeout解决了这个奇怪的问题，还有一点要注意的就是这个方法要在componentDidMount里面调用这个setWxConfig方法。 12345678910111213141516171819const setWxConfig = () =&gt; &#123; // JSSDK配置 let WXCONFIG = window.config || &#123;&#125;; let url = window.location.href.split(&apos;#&apos;)[0]; url = encodeURIComponent(url); // getWxConfig是封装的换取服务端签名的接口 getWxConfig(&apos;?url=&apos; + url).then((data) =&gt; &#123; if(data) &#123; WXCONFIG = data; WXCONFIG.jsApiList = [&apos;scanQRCode&apos;, &apos;closeWindow&apos;, &apos;chooseImage&apos;, &apos;uploadImage&apos;, &apos;previewImage&apos;]; // WXCONFIG.debug = true; setTimeout(() =&gt; &#123; wx.config(WXCONFIG); &#125;, 500); &#125; &#125;,(err) =&gt; &#123; throw err; &#125;);&#125;;]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析reduce与reduceRight]]></title>
    <url>%2F2018%2F04%2F25%2F180425%E6%B5%85%E6%9E%90reduce%E4%B8%8EreduceRight%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;在传统的实际开发中，经常在遇到处理数组的一些问题的时候就采用for循环，当然可以解决遇到的问题，但是站在优雅的角度来看是相当不优雅的，况且是在现在其实是有现成的api能够更好的解决for循环能够解决的问题，下面简单介绍下数组的这两个方法，reduce与reduceRight. reduce定义对数组中的所有元素调用指定的回调函数。该回调函数的返回值为累积结果，并且此返回值在下一次调用该回调函数时作为参数提供。 语法123456789101112131415array1.reduce(callbackfn[, initialValue])参数- array1 必需，一个数组对象- callbackfn 必需。一个接受最多四个参数的函数。对于数组中的每个元素，reduce 方法都会调用 callbackfn 函数一次。- initialValue 可选。如果指定 initialValue，则它将用作初始值来启动累积。第一次调用 callbackfn 函数会将此值作为参数而非数组值提供。返回值- 通过最后一次调用回调函数获得的累积结果。异常当满足下列任一条件时，将引发 TypeError 异常：- callbackfn 参数不是函数对象。- 数组不包含元素，且未提供 initialValue。 注意点 如果提供了 initialValue，则 reduce 方法会对数组中的每个元素调用一次 callbackfn 函数（按升序索引顺序）。如果未提供 initialValue，则 reduce 方法会对从第二个元素开始的每个元素调用 callbackfn 函数。 回调函数的返回值在下一次调用回调函数时作为 previousValue 参数提供。最后一次调用回调函数获得的返回值为 reduce 方法的返回值。 不为数组中缺少的元素调用该回调函数。 回调函数语法123456789回调函数的语法如下所示：function callbackfn(previousValue, currentValue, currentIndex, array1)可使用最多四个参数来声明回调函数。- previousValue 通过上一次调用回调函数获得的值。如果向 `reduce` 方法提供 initialValue，则在首次调用函数时，previousValue 为 initialValue。- currentValue 当前数组元素的值。- currentIndex 当前数组元素的数字索引。- array1 包含该元素的数组对象。 第一次调用回调函数在第一次调用回调函数时，作为参数提供的值取决于 reduce 方法是否具有 initialValue 参数。 如果向 reduce 方法提供 initialValue： previousValue 参数为 initialValue。 currentValue 参数是数组中的第一个元素的值。 如果未提供 initialValue： previousValue 参数是数组中的第一个元素的值。 currentValue 参数是数组中的第二个元素的值。 实际应用例子1 数组求和问题传统for循环方式123456const arr = [3,4,5,6];let sum = 0;for(let i = 0, len = arr.length; i &lt; len; i++) &#123; sum += arr[i];&#125;console.log(&apos;sum&apos;, sum); reduce方式123456const arr = [3,4,5,6];function sumFunc(prev, curr) &#123; return prev += curr;&#125;let sum = arr.reduce(sumFunc, 0);console.log(&apos;sum&apos;, sum); 例子2 数组去重问题传统for循环方式12345678910111213const arr = [3,4,5,6,6,3];function removeDuplicate(array) &#123; const newArr = []; const obj = &#123;&#125;; for(let i = 0, len = array.length; i &lt; len; i++) &#123; if(!obj[array[i]]) &#123; newArr.push(array[i]); obj[array[i]] = 1; &#125; &#125; return newArr;&#125;console.log(&apos;arr&apos;, removeDuplicate(arr)); reduce方式123456789101112const arr = [3,4,5,6,6,3];function removeDuplicate(array) &#123; const obj = &#123;&#125;; return array.reduce((prev, next) =&gt; &#123; if(!obj[next]) &#123; prev.push(next); obj[next] = 1; &#125; return prev; &#125;, []);&#125;console.log(&apos;arr&apos;, removeDuplicate(arr)); reduceRight定义按降序顺序对数组中的所有元素调用指定的回调函数。该回调函数的返回值为累积结果，并且此返回值在下一次调用该回调函数时作为参数提供,其实主要就是调用回调函数的时候是从右边开始调用，其他的跟reduce并无多大区别，这里就不详细介绍了 结语上面只是举了两个比较常见的例子，数组求和和数组去重，其实reduce的用法是相当强大的，redux框架里就用到了reduce,在这里记录下来也是提醒自己以后不要把思维固化到以前的观念上，要多去关注和尝试一些新的特性，不断去尝试用更优雅的方式去解决问题。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>reduce</tag>
        <tag>reduceRight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react、vue、angular简要对比]]></title>
    <url>%2F2017%2F12%2F26%2F171226react%E3%80%81vue%E3%80%81angular%E7%AE%80%E8%A6%81%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[简要记录一下这三个比较流行的前端框架的一些对比 框架与库 react和vue都是一个只专注于视图的库，而angular则是一个不折不扣的框架，里面集成了路由、单元测试等；而react和vue则是结合上它们的社区生态能够变成一个框架，比如react全家桶（react+react-router+redux)、vue全家桶（vue+vue-router+vuex)； 上手难度方面 vue最容易上手，首先它是我们华人Evan You（尤雨溪）开发的，所以最开始的中文文档是很健全的；其次是react，再就是angular1，最后是angular2+版本；angular2以上官方推荐使用typescript，确实会稍微将其门槛提高一下，但是带来的可维护性也是很显然的。 vue的优化做的比react好一些 在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 无状态组件（PureComponent） ，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。 然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。而在做vue相关的项目时，我们只需要关注于业务逻辑，而不需要去操心是否会产生不必要的组件渲染，因为vue已经把这些麻烦的东西很好的解决了。 社区方面 react和angular相对来说比vue稍微好一些，因为react后面有facebook在官方维护，angular有google官方维护；当然vue现在也是发展的非常不错，维护者也是在逐步增多； 跨端能力 react相对来说强一些，因为react-native的大规模使用使其优势稍微强一些；当然现在vue结合weex也是可以实现跨端，但是weex现在还是仍需继续成长的；基于angular的一个很不错的跨端项目-ionic也是非常不错的。 vue写起来更加流畅、方便， react语法更简单、扩展更强大。 在这一方面，react和vue的出发点似乎是不一样的，比如，对于列表循环，使用vue，直接在标签上写 v-for 即可，然后就可以直接循环了，而react需要通过一个数组的map，然后在return，在形式上来说，vue的写法还是更加舒服一点。 另外，由于vue局部的数据双向绑定，所以vue在处理表单这一块也是游刃有余，非常方便，而react仅仅是处理一个表单，就需要添加很多无关的代码，这个还是非常别扭的。可以看得出来，vue提供了更多的api，可以做更多的事情，但是， 这也体现了react的优点，即非常简单，提供的api很少，它只帮我们做了虚拟DOM的工作，其他的事情可以让我们自由的发挥，所以从这个角度来说，react还是更加简洁一些。 数据流 angular是双向数据绑定，vue在表单上可以双向绑定，默认是单向绑定，react则一直是单向数据，这样应用的整个状态更加可控一些。React推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。React和Vue都可以配合Redux/vuex来管理状态数据。 性能方面 angular1会差一些，因为它的脏检查， 在 AngularJS 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。AngularJS 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue 和react则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，再加上虚拟dom的强大之处，性能会好一些。 简要总结 如果是初级开发者，则可以先从vue开始入手，等掌握的差不多了，可以去用一下react，当再有精力的时候可以去学一下typescript去上手一下angular，总之，需要学的东西很多，慢慢去攻克。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈XSS漏洞攻击与防御]]></title>
    <url>%2F2017%2F08%2F25%2F170825%E6%B5%85%E8%B0%88XSS%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;跨站脚本简称xss（cross-site scripting），利用方式主要是借助网站本身设计不严谨，导致执行用户提交的恶意js脚本，对网站自身造成危害。xss漏洞是web渗透测试中最常见而又使用最灵活的一个漏洞。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS分类 XSS大致分为：反射型、存储型、DOM型（这三种为主流） 反射型xss&nbsp;&nbsp;只是简单地把用户输入的数据”反射”给浏览器，攻击时需要用户配合点击，也叫”非持久型xss”。 存储型xss&nbsp;&nbsp;会把用户输入的数据”存储”在服务器端，也叫”持久性xss”，常见留言板等可以提交展示用户输入内容的功能点。 DOM型xss&nbsp;&nbsp;从是否存储可划分成反射型，可通过修改页面的DOM节点形成的xss漏洞。 注意：无论反射型还是存储型，都是需要与服务端交互的，即服务端将提交的内容反馈到了html源码内，导致触发xss，也就是说返回到html源码中可以看到触发xss的代码；而DOM型xss是不与服务端交互的，只与客户端上的js交互，也就是说提交的恶意代码，被放到了js中执行，然后显示出来。那么这种形式有一个问题，就是html源码里面不存在触发xss的代码，因为服务端返回的源码都是一样的，只不过源码里面包含了一段js，这段js再执行后生成了一段xss代码，可以在审查元素中查看到。 XSS危害&nbsp;&nbsp;xss漏洞是发生在客户端，目的是让浏览器执行一段用户提交的恶意js代码，从而达到某种目的。从表面上看，xss漏洞的危害止步于客户端，且主要就是用来执行js获取用户信息（比如浏览器版本等等）。然而由于xss漏洞可能发生的地方很多，因此被利用的情况也不统一，以下列举了xss漏洞能够造成的一些危害（xss漏洞危害包含但不仅限于以下几种）。 cookie劫持（窃取cookie） 后台增删改文章等操作（类似于csrf骗取用户点击，利用js模拟浏览器发包，借助xmlhttprequest类） 钓鱼，利用xss构造出一个登录框，骗取用户账户密码。 Xss蠕虫（利用xss漏洞进行传播） 修改网页代码 利用网站重定向 利用XSS窃取cookie&nbsp;&nbsp;因为cookie能够代表用户的身份，所以盗取了cookie之后，就可以伪造用户去做一些事情了，这个产生的危害是非常可怕的。 cookie介绍cookie分为内存cookie和硬盘cookie，内存cookie储存在浏览器内存中，关闭浏览器则消失。cookie由变量名与值组成，其属性里有标准的cookie变量，也有用户自定义的属性。 1cookie格式：Set-Cookie:=[;=][;expiress=][;domain=][;path=][;secure][;httponly] cookie各个参数详细内容： Set-cookie:http响应头，向客户端发送cookie。 Name=value:每个cookie必须包含的内容。 Expires=date:EXpires确定了cookie的有效终止日期，可选。如果缺省，则cookie不保存在硬盘中，只保存在浏览器内存中。 Domain=domain-name:确定了哪些inernet域中的web服务器可读取浏览器储存的cookie，缺省为该web服务器域名。 Path=path:定义了web服务器哪些路径下的页面可获取服务器发送的cookie。 Secure:在cookie中标记该变量，表明只有为https通信协议时，浏览器才向服务器提交cookie。 Httponly:禁止javascript读取,如果cookie中的一个参数带有httponly，则这个参数将不能被javascript获取；httponly可以防止xss会话劫持攻击。 防御 XSS为防御 XSS，我们首先要知道 XSS 攻击的本质是不安全的HTML 注入，可通过在 HTML、CSS、JS 或 HTTP 协议层次上进行防范。下面提供一些常用的防御策略： 输入检查用户名、邮箱等表单验证（前台/服务器二次验证）富文本使用白名单机制等 输出检查HTML-Encoderjs-Encoder HTTP 头部：HttpOnly设置 cookie 时加入 HttpOnly 可使 js 脚本无法获取 cookie HTTP 头部：CSP（Content Security Policy）定义允许的资源加载地址，比如图片 / 视频 / JS 脚本等 HTTPS加密访问有效防止 DOM XSS 攻击]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archLinux安装VSCode]]></title>
    <url>%2F2017%2F06%2F26%2F170626archLinux%E5%AE%89%E8%A3%85VSCode%2F</url>
    <content type="text"><![CDATA[记录一下在archLinux安装VSCode，我是用的manjaro这款linux发行版，个人觉得这款linux发行版还是非常不错的，有兴趣的也可以安装一下，下面来列一下安装VSCode的几个步骤 前言&nbsp;&nbsp;&nbsp;Visual Studio Code（以下简称vscode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。主要这是微软第一款官方支持Linux的产品，真是大赞微软！ 安装过程1、下载安装包从官网下载压缩包，直接访问Visual Studio Code官网下载就可以，我的电脑是64位的，所以下载64位的就可以了,注意要下载结尾为.tar.gz格式的压缩包https://code.visualstudio.com/docs?dv=linux64 2、解压cd 到你下载这个文件的目录，进行解压缩 123456789101112131415161718192021[lsqy@lsqy-pc ~]$ cd ~/workspace/soft/[lsqy@lsqy-pc soft]$ ll总用量 510M-rw-r--r-- 1 lsqy lsqy 65M 6月 26 11:03 code-stable-code_1.13.1-1497464373_amd64.tar.gzdrwxr-xr-x 2 lsqy lsqy 4.0K 5月 10 17:26 git_for_win_32drwxr-xr-x 4 lsqy lsqy 4.0K 4月 24 18:06 navicatess112_premium_cs_x64-rw-r--r-- 1 lsqy lsqy 246M 4月 11 17:11 navicatess112_premium_cs_x64.tar-rw-r--r-- 1 lsqy lsqy 1.4M 5月 27 10:09 nginx-1.13.0.zip-rw-r--r-- 1 lsqy lsqy 198M 6月 26 13:06 tm2013.tar.gz-rw-r--r-- 1 lsqy lsqy 6.7K 5月 10 18:18 vbox-install.log.gz[lsqy@lsqy-pc soft]$ tar -zxvf code-stable-code_1.13.1-1497464373_amd64.tar.gz[lsqy@lsqy-pc soft]$ ll总用量 510M-rw-r--r-- 1 lsqy lsqy 65M 6月 26 11:03 code-stable-code_1.13.1-1497464373_amd64.tar.gzdrwxr-xr-x 2 lsqy lsqy 4.0K 5月 10 17:26 git_for_win_32drwxr-xr-x 4 lsqy lsqy 4.0K 4月 24 18:06 navicatess112_premium_cs_x64-rw-r--r-- 1 lsqy lsqy 246M 4月 11 17:11 navicatess112_premium_cs_x64.tar-rw-r--r-- 1 lsqy lsqy 1.4M 5月 27 10:09 nginx-1.13.0.zip-rw-r--r-- 1 lsqy lsqy 198M 6月 26 13:06 tm2013.tar.gz-rw-r--r-- 1 lsqy lsqy 6.7K 5月 10 18:18 vbox-install.log.gzdrwxr-xr-x 5 lsqy lsqy 4.0K 6月 15 02:18 VSCode-linux-x64 从上面可以看到解压出了VSCode-linux-x64目录 3、移动到/usr/local/目录1mv VSCode-linux-x64 /usr/local/ 4、添加可执行权限1chmod +x /usr/local/VSCode-linux-x64/code 5、复制一下VScode图标文件到 /usr/share/icons/ 目录1cp /usr/local/VSCode-linux-x64/resources/app/resources/linux/code.png /usr/share/icons/ 6、创建启动链接，在/usr/share/applications/目录在终端使用命令1vim /usr/share/applications/VSCode.desktop 然后输入以下内容: 123456789[Desktop Entry]Name=Visual Studio CodeComment=Multi-platform code editor for LinuxExec=/usr/local/VSCode-linux-x64/codeIcon=/usr/share/icons/code.pngType=ApplicationStartupNotify=trueCategories=TextEditor;Development;Utility;MimeType=text/plain;` 保存后退出, 然后复制到桌面: 1cp /usr/share/applications/VSCode.desktop ~/Desktop/ 这样就会发现 桌面和 应用程序菜单都有了 VSCode的快捷方式了，也算是大功告成了。 结语VSCode的插件系统也是很丰富的，大家可以去发掘自己需要的.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>archLinux</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单页面应用的History路由模式express后端中间件配合]]></title>
    <url>%2F2017%2F03%2F28%2F170328%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84History%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8Fexpress%E5%90%8E%E7%AB%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%85%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[这篇文章主要分享一下通过HTML5的history API的时候，使用NodeJS后端应该如何配置，来避免产生404的问题，这里是使用的express的框架，主要是通过connect-history-api-fallback这个中间件来实现的！ 前言这里使用vue-router来实现的单页应用为例，访问http://cnode.lsqy.tech，进入首页，点击下面的tab栏，一切都是很正常的，但当这时候你 ctrl+command+R 或 点击浏览器的刷新按钮 或 在地址栏上再敲一下回车，总之就是刷新，发现就会出现404了，比如这样的错误Cannot GET /message/,因为默认浏览器会认为你是在请求服务端的路由，服务端那边没有对应的处理，所以自然就会出错了，下面来引入connect-history-api-fallback这个中间件，来无痛使用优雅的History路由模式。 引入connect-history-api-fallback首先看它的介绍Middleware to proxy requests through a specified index page, useful for **Single Page Applications** that utilise the HTML5 History API.中文意思就是一个能够代理请求返回一个指定的页面的中间件，对于单页应用中使用HTML5 History API非常有用。 用法经典的npm安装,注意将其作为依赖项，加上--save1npm install --save connect-history-api-fallback 接下来是在express的简单使用 1234567891011var http = require(&apos;http&apos;);var express = require(&apos;express&apos;);var ecstatic = require(&apos;ecstatic&apos;);var history = require(&apos;connect-history-api-fallback&apos;);var app = express();app.use(history());app.use(ecstatic(&#123; root: __dirname + &apos;/dist&apos; &#125;));http.createServer(app).listen(6565); 这样配置完之后，再重新restart一下项目,你就会发现现在可以非常顺畅的使用了，不管你是刷新了浏览器还是直接通过url从外部访问都不会出现404的结果了。另外，connect-history-api-fallback还有一些可配置的Options项,这个如果需要详细了解可以仔细看看其API的调用即可 总结其实有时候对于单页面应用，虽然是单页的，但是也会有很多不仅仅是必须从首页进去的情况，比如要分享某个页面，这样我们希望能够直接通过这个简洁的url来跳到这个指定的页面，但是如果不做上面的配置的话就会出现404这样的错误了，其实这样的话也算是接管了传统的服务端路由，来完全交给前端来处理路由跳转了，这样以后的url就非常简洁优雅了。 reference: github地址connect-history-api-fallback]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>express</tag>
        <tag>History路由模式</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React相关资料整理]]></title>
    <url>%2F2016%2F12%2F28%2F161228React%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[记录一些React的参考资料 1.React AJAX Best Practices 上面写了四种不错的方式 http://andrewhfarmer.com/react-ajax-best-practices/ 中文版React Ajax最佳实践 2.Modern Js with React 一个很不错的blog，博主是一个很有经验的webDeveloper,相当有经验，上面的React AJAX Best Practices就是它写的。 http://andrewhfarmer.com/ 3.React 最佳实践——那些 React 没告诉你但很重要的事 对于React新手和中级水平的都可以参考借鉴下，能够避免少走一些弯路，可以看出来作者也是慢慢试错总结出来的。 https://segmentfault.com/a/1190000005013207 4.AJAX Requests in React: How and Where to Fetch Datahttps://daveceddia.com/ajax-requests-in-react/ 5.Load Initial Data via AJAX 学习一个新技术，大多数技术的官网上写的无疑是很详细的，之所以把这个tips拿出来，是因为这个点很多时候会被忽略，提醒下自己。主要就是请求过来的远端数据要在componentDidMount方法中，当请求异步数据的时候，在componentWillUnmount中cacel掉发出的的请求，因为这个component就要被移除了，所以这个请求没有意义了。 http://reactjs.cn/react/tips/initial-ajax.html 5.ReactTips必看 官网提供的一个tips模块，仔细阅读完之后能够解决很多你在开发react项目时遇到的问题。 http://reactjs.cn/react/tips/introduction.html 6.Props in getInitialState Is an Anti-Pattern 这个点也是官网tips提到的，也是最佳实践的一个点，就是不要在getInitialState中使用pops,除非真的明确声明是为了项目内部使用。 http://reactjs.cn/react/tips/props-in-getInitialState-as-anti-pattern.html]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>优秀项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github开源项目日常整理]]></title>
    <url>%2F2016%2F12%2F28%2F161228github%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%B8%B8%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[主要记录一些自己在平常工作学习当中发现的一些开源项目，也是能够让自己知道自己star了哪些项目，不要只是star，而要真正能够star的有意义，时刻能够提醒自己。 注意以下项目不分先后，等以后多了以后会对其进行详细一些的分类 1.fetch 就不用为了使用jQuery的Ajax方法就引入整个jQuery库，可以使用window.fetch()就可以了，它是一个简洁、标准化的javascript的Ajax API。在Chrome和Firefox中已经可以使用，如果需要兼容其他浏览器，可以使用fetch polyfill，也就是下面这个库了 A window.fetch JavaScript polyfill. github地址https://github.com/github/fetch MDNhttps://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetchhttps://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API 2.axiosPromise based HTTP client for the browser and node.js github地址https://github.com/mzabriskie/axios 3.superagentAjax with less suck - (and node.js HTTP client to match) github地址https://github.com/visionmedia/superagent]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>优秀项目</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀项目收集-页面自动加载条pace.js]]></title>
    <url>%2F2016%2F12%2F18%2F161218%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E6%94%B6%E9%9B%86-%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9D%A1pace-js%2F</url>
    <content type="text"><![CDATA[pace简介 github地址 https://github.com/HubSpot/pace &nbsp;&nbsp;只需要将page.js和你选择的CSS主题引入，你就会得到一个非常漂亮的的页面加载条。它的强大之处在于它不需要跟你的代码有任何联系，加载进度它会自动检测。 使用例子1234&lt;head&gt; &lt;script src=&quot;/pace/pace.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;/pace/themes/pace-theme-barber-shop.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt; 详细的文档1http://github.hubspot.com/pace/]]></content>
      <categories>
        <category>优秀项目收集</category>
      </categories>
      <tags>
        <tag>页面自动加载条</tag>
        <tag>pace.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用monaca快速开发HybridApp]]></title>
    <url>%2F2016%2F12%2F18%2F161218%E4%BD%BF%E7%94%A8monaca%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91HybridApp%2F</url>
    <content type="text"><![CDATA[安装Monaca CLI1npm install -g monaca 注意要全局安装，也就是加上-g 国内如果直接安装不上的话，可以试试cnpm 1cnpm install -g monaca cnpm 可以通过 npm install -g cnpm来进行安装，是阿里为npm在国内的镜像网； 安装成功后 12monaca -v2.1.6 这样就说明安装无误了 创建一个APP应用1monaca create my-app 接下来你会看到有几个模板，其实也可以说是monaca目前集成好的几个框架可以选用，相当于一个脚手架，monaca跟OnsenUI的集成还是非常棒的，有基于Angular 1 、Angular 2 、React,当然还有Ionic也可以选择，也可以选择一个不用任何框架的版本No Framework 123456789monaca create my-app? Choose a category: Onsen UI Onsen UI and Angular 1 Onsen UI and Angular 2 Onsen UI and React Ionic &gt; No Framework Sample Apps 从上面选择一个你喜欢的框架，接下来monaca就会从云端将你选择的这套脚手架下载下来例如我这边想下载一个不用任何框架的,这样你就可以将自己开发的html5页面放到里面直接在app里看了 1234567891011121314$ monaca create weui? Choose a category: No Framework? Select a template - Press P to see a preview BlankDownloading template...www/components already exists. Skipping.Project created successfully.Type &quot;cd weui&quot; and run monaca command again. &gt; monaca preview =&gt; Run app in the browser &gt; monaca debug =&gt; Run app in the device using Monaca Debugger &gt; monaca remote build =&gt; Start remote build for iOS/Android/Windows &gt; monaca upload =&gt; Upload this project to Monaca Cloud IDE monaca preview 预览模式这样就直接会在你浏览器打开这个项目，默认是监听8080端口，只要你一修改，就会即时刷新，结合控制台能够很方便的快速开发 monaca debug这样就可以直接在你的手机上去运行这个APP了，你手机上需要下载一个monaca，注册一个monaca账号就可以了，再按照引导步骤连上你本机的IP，就可以在手机上运行了，并且它也会即时响应你的改变，热加载刷新。 &nbsp;&nbsp;&nbsp;当我发现monaca的时候，真的感觉这个工具真是相当不错，特此跟大家分享一下，Onsen也是值得大家去用一下的一个非常精美的UI框架。 https://monaca.io/https://onsen.io/]]></content>
      <categories>
        <category>HybridApp</category>
      </categories>
      <tags>
        <tag>HybridApp</tag>
        <tag>monaca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀项目]]></title>
    <url>%2F2016%2F12%2F14%2F161214%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[基于网易云实现的音乐搜索网https://music.daoapp.io/]]></content>
  </entry>
  <entry>
    <title><![CDATA[升级到https小记]]></title>
    <url>%2F2016%2F12%2F12%2F161212%E5%8D%87%E7%BA%A7%E5%88%B0https%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[总结的不错的博文今天整站系统的升级了下https，下面记录下几篇写的不错的博文 1.为什么我们应该尽快升级到 HTTPS？1https://imququ.com/post/moving-to-https-asap.html#simple_thread 2.nginx配置ssl加密（单双向认证、部分https）1http://seanlook.com/2015/05/28/nginx-ssl/ 3.https 免费证书获取指引 –alsotang CNode 社区负责人1https://cnodejs.org/topic/57e917e2bb55ef3e1a17fcbd 4.nginx配置location总结及rewrite规则写法1http://seanlook.com/2015/05/17/nginx-location-rewrite/]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis远程连接]]></title>
    <url>%2F2016%2F11%2F28%2F161128Redis%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[一般情况下，Redis默认只允许本机访问，有时候我们也许需要使Redi能被远程访问，我这次远程连接的目的主要是为了能够在本机通过Redis可视化工具连接上我的阿里云服务器上部署的Redis，这样能够更加直观的去观察一下存入的键值对，下面记录下步骤： 配置修改Redis配置文件/usr/local/src/redis-3.2.5/redis.conf，找到bind那行配置： 对于redis.conf这个文件的位置，有的是在/etc/redis/redis.conf,我的是安装在了上面的位置上，具体看你的Redis安装目录 1bind 127.0.0.1 将其改为： 1bind 0.0.0.0 重启Redis服务注意这时候需要指定配置文件然后重启Redis服务,也就是说启动redis-server的时候后面加上刚才修改的redis.conf。1sudo ./src/redis-server redis.conf 远程连接配置好Redis服务并重启服务后。就可以使用客户端远程连接Redis服务了。命令格式如下： 1$ redis-cli -h &#123;redis_host&#125; -p &#123;redis_port&#125; 其中{redis_host}就是远程的Redis服务所在服务器地址，{redis_port}就是Redis服务端口（Redis默认端口是6379）。例如：1234G7_user@E540-PF03XZZF /C/Users/G7_user/Desktop$ redis-cli -h 你的IP地址 -p 6379你的IP地址:6379&gt; pingPONG 下面就是我用的Redis Desktop Manager,直接连接即可]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装和配置Redis]]></title>
    <url>%2F2016%2F11%2F21%2F161121Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AERedis%2F</url>
    <content type="text"><![CDATA[简介&nbsp;&nbsp;&nbsp;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。由于是存取运行在内存之中，所以速度极快。Redis 最高可以每秒执行 80000 以上数据操作，因此被广泛应用于需要快速存取数据的应用中，比如秒杀网站，投票网站等。&nbsp;&nbsp;&nbsp;Redis 官方安装版本是 Linux 的，并没有 Windows 下的 Redis，好在 GitHub 中有人发布了 Windows 版本的 Reids ，可以直接安装使用。注意，仅支持 64 位系统，32位的没有测试，一般是不能运行的。下载地址：https://github.com/MSOpenTech/redis/releases下载完成之后，直接解压到自己预先建好的目录下即可，例如我建到了D:\Redis下； 启动Redis服务 进入到Redis目录 1$ cd d:/Redis 运行Redis 12redis-server redis.windows.conf或者直接输入redis-server也可以 如果出现这样的画面，就说明 Redis 运行成功，只要确定不要关闭这个画面，Redis 就会一直运行 关闭Redis直接关闭命令行工具即可 启动Redis命令行工具另外开启一个命令提示窗口，并输入下面的命令： 1.定位至 Redis 目录cd c:/redis 2.启动 Redis 命令redis-cli如果光标前出现了这样的字符，127.0.0.1:6379&gt; 说明开启本地测试工具，端口是 6379。这样额就能够在命令行熟悉一些Redis的命令了。 几个学习的网站 http://www.redis.cn/ Redis中文官网http://www.redis.net.cn/ Redis中文网http://redisdoc.com/ Redis命令参考https://www.npmjs.com/package/redis Redis npm包地址]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel-preset-node6]]></title>
    <url>%2F2016%2F11%2F20%2F161120babel-preset-node6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;现在Node6.x虽然现在已经能够原生支持ES6、ES2015将近93%的特性了，而今天介绍的这个插件正式为了解决剩下的的将近7%的特性支持，从而实现完全拥抱ES6. installation(安装)1npm i babel-preset-node6 Usage(用法)通过.babelrc(建议)在你的项目根目录下创建一个babelrc文件，然后将node6包含到你的presets path:12345&#123; &quot;presets&quot;: [ &quot;node6&quot; ]&#125; 现在你无论任何时候运行babel-node,它将会使Node6.x版本缺失的ES6特性可以体验。 通过命令行（CLI）1$ babel script.js --presets node6 通过Node API如果你不想用上面的.babelrc文件,你可以试试这样123require(&quot;babel-core&quot;).transform(&quot;code&quot;, &#123; presets: [&quot;node6&quot;]&#125;); 如果你想用node而不是babel-node作为你的命令行工具，你可以创建一个入口script来引用你的预编译代码：12require(&apos;babel-register&apos;);require(&apos;path/to/es6/script&apos;); 这样你就可以在任何地方使用node来运行ES6代码了当然，你首先要确保你已经安装这两个npm包中的一个12npm i -S babel-core ornpm i -S babel-register Webpack，gulp，Browserify, 等等根据vendor的介绍将node6加到你babel的&quot;perset&quot;列表当中 React支持babel已经有了一个React的开始包，现在你需要分别安装。通过NPM安装1npm i babel-preset-react 然后往你的.babelrc的”presets”列表中添加如下配置123456&#123; &quot;presets&quot;: [ &quot;node6&quot;, &quot;react&quot; ]&#125; reference https://www.npmjs.com/package/babel-preset-node6]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>babel</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bable使用指南]]></title>
    <url>%2F2016%2F11%2F17%2F161117bable%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[记录下自己觉得写得不错的babel资料 官网无非是最权威、做全面的，英文水平好的https://babeljs.io/阮一峰写的babel入门教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS实现数字自动转换人民币金额]]></title>
    <url>%2F2016%2F10%2F20%2F161020JS%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E4%BA%BA%E6%B0%91%E5%B8%81%E9%87%91%E9%A2%9D%2F</url>
    <content type="text"><![CDATA[这个需求在实际项目中还是挺常用的，实现方法有很多种，下面简单总结了两种实现方式，供大家参考。 方法一123456789101112131415161718192021222324252627282930313233343536function outputmoney(number) &#123; number = number.replace(/\,/g, &quot;&quot;); if (isNaN(number) || number == &quot;&quot;) return &quot;&quot;; number = Math.round(number * 100) / 100; if (number &lt; 0) &#123; return &apos;-&apos; + outputdollars(Math.floor(Math.abs(number) - 0) + &apos;&apos;) + outputcents(Math.abs(number) - 0); &#125; else &#123; return outputdollars(Math.floor(number - 0) + &apos;&apos;) + outputcents(number - 0); &#125;&#125;function outputdollars(number) &#123; if (number.length &lt;= 3) &#123; return (number == &apos;&apos; ? &apos;0&apos; : number); &#125; else &#123; var mod = number.length % 3; var output = (mod == 0 ? &apos;&apos; : (number.substring(0, mod))); for (i = 0; i &lt; Math.floor(number.length / 3); i++) &#123; if ((mod == 0) &amp;&amp; (i == 0)) &#123; output += number.substring(mod + 3 * i, mod + 3 * i + 3); &#125; else &#123; output += &apos;,&apos; + number.substring(mod + 3 * i, mod + 3 * i + 3); &#125; &#125; return (output); &#125;&#125;function outputcents(amount) &#123; amount = Math.round(((amount) - Math.floor(amount)) * 100); return (amount &lt; 10 ? &apos;.0&apos; + amount : &apos;.&apos; + amount);&#125;var number = &apos;10038798.39&apos;; &gt; 如果是number类型，可通过+&apos;&apos;或者toString()来转换为string类型，因为要用到一些string的方法。number = outputmoney(number);console.log(number);10,038,798.39 方法二123456789101112131415161718192021222324252627282930313233function formatNum(str) &#123; var newStr = &quot;&quot;; var count = 0; if (str.indexOf(&quot;.&quot;) == -1) &#123; for (var i = str.length - 1; i &gt;= 0; i--) &#123; if (count % 3 == 0 &amp;&amp; count != 0) &#123; newStr = str.charAt(i) + &quot;,&quot; + newStr; &#125; else &#123; newStr = str.charAt(i) + newStr; &#125; count++; &#125; str = newStr + &quot;.00&quot;; //自动补小数点后两位 console.log(str) &#125; else &#123; for (var i = str.indexOf(&quot;.&quot;) - 1; i &gt;= 0; i--) &#123; if (count % 3 == 0 &amp;&amp; count != 0) &#123; newStr = str.charAt(i) + &quot;,&quot; + newStr; &#125; else &#123; newStr = str.charAt(i) + newStr; //逐个字符相接起来 &#125; count++; &#125; str = newStr + (str + &quot;00&quot;).substr((str + &quot;00&quot;).indexOf(&quot;.&quot;), 3); &#125; return str;&#125;var number = &apos;10038798.39&apos;; &gt; 如果是number类型，可通过+&apos;&apos;或者toString()来转换为string类型，因为要用到一些string的方法。number = formatNum(number);console.log(number);10,038,798.39]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-server介绍]]></title>
    <url>%2F2016%2F10%2F01%2F161001http-server%2F</url>
    <content type="text"><![CDATA[http-server是一个基于NodeJs简单的零配置命令行HTTP服务器.在平常我们要在本地查看一些项目的时候，往往是需要开一个本地服务器的，大多数人可能会选择用wamp来进行这个操作，有了这个之后就可以非常方便的想在哪里开启一个本地服务器就可以在哪里开启，使用起来相当快捷方便，比起wamp会轻便很多，当然并不是说wamp就不用了，只是在一些特定的情况下有这个http-server就足够了。下面来深入的了解下http-server。 环境依赖&nbsp;&nbsp;&nbsp;&nbsp;Node,Node的下载和安装就跟普通软件一样，在其官方网址安装了即可，npm也会随之按上。 安装1npm install http-server -g 上面是全局安装，也建议大家都全局安装，否则不能直接在命令行里使用http-server来开启本地服务器。加上-g的也就是意味着全局安装，也就相当于自动配上了环境变量，可以在命令行中直接通过http-server来进行使用。 用法1http-server [path] [option] [path]默认是指向./public如果这个文件夹存在的话，否则就会指向./也就是当前目录。 可用的选项1234567891011121314151617181920212223242526272829-p 端口号 (默认 8080)-a IP 地址 (默认 0.0.0.0)-d 显示目录列表 (默认 &apos;True&apos;)-i 显示 autoIndex (默认 &apos;True&apos;)-e or --ext 如果没有提供默认的文件扩展名(默认 &apos;html&apos;)-s or --silent 禁止日志信息输出--cors 启用 CORS via the Access-Control-Allow-Origin header-o 在开始服务后打开浏览器-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to &apos;3600&apos;). 禁用 caching, 则使用 -c-1.-U 或 --utc 使用UTC time 格式化log消息-P or --proxy Proxies all requests which can&apos;t be resolved locally to the given url. e.g.: -P http://someurl.com-S or --ssl 启用 https-C or --cert ssl cert 文件路径 (default: cert.pem)-K or --key Path to ssl key file (default: key.pem).-r or --robots Provide a /robots.txt (whose content defaults to &apos;User-agent: *\nDisallow: /&apos;)-h or --help 打印以上列表并退出 实际使用&nbsp;&nbsp;&nbsp;首先可以先打开一个目录，如下图：然后在当前目录打开命令行窗口，使用git bash命令或者windows系统下按下shift键然后右击鼠标然后选择在此处打开命令行即可，然后输入http-server,这样就能够开启一个端口了，默认是8080；并且你的http请求也会输出出来，如下图：如果想换个端口则只需加上-p 端口号，例http-server -p 4000，这样就可以通过loaclhost:4000来进行访问了，更多的option可以自行尝试。参考：https://www.npmjs.com/package/http-server]]></content>
      <categories>
        <category>HTTP,NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular规范]]></title>
    <url>%2F2016%2F09%2F15%2F160915Angular%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这个规范的目的是为构建Angular应用提供指导，当然更加重要的是让大家知道选择它的理由,当然, 也是为了督促自己能够好好用规范去编写可维护的代码，跟大家一起共勉！ 如果你喜欢这个规范，请在Pluralsight看看Angular Patterns: Clean Code。 目录 单一职责 IIFE Modules Controllers Services Factories Data Services Directives 解决Controller的Promises 手动依赖注入 压缩和注释 异常处理 命名 应用程序结构的LIFT准则 应用程序结构 模块化 启动逻辑 Angular $包装服务 测试 动画 注释 JSHint JSCS 常量 文件模板和片段 Yeoman Generator 路由 任务自动化 Filters Angular文档 1. 单一职责规则一 一个文件只定义一个组件。 下面的例子在同一个文件中定义了一个app的module和它的一些依赖、一个controller和一个factory。 123456789/* avoid */angular .module('app', ['ngRoute']) .controller('SomeController', SomeController) .factory('someFactory', someFactory);function SomeController() &#123; &#125;function someFactory() &#123; &#125; 推荐以下面的方式来做，把上面相同的组件分割成单独的文件。 12345/* recommended */// app.module.jsangular .module('app', ['ngRoute']); 12345678/* recommended */// someController.jsangular .module('app') .controller('SomeController', SomeController);function SomeController() &#123; &#125; 1234567/* recommended */// someFactory.jsangular .module('app') .factory('someFactory', someFactory);function someFactory() &#123; &#125; 返回顶部 2. IIFEJavaScript闭包 把Angular组件包装到一个立即调用函数表达式中（IIFE）。 为什么？：把变量从全局作用域中删除了，这有助于防止变量和函数声明比预期在全局作用域中有更长的生命周期，也有助于避免变量冲突。 为什么？：当你的代码为了发布而压缩了并且被合并到同一个文件中时，可能会有很多变量发生冲突，使用了IIFE（给每个文件提供了一个独立的作用域），你就不用担心这个了。 12345678910111213141516/* avoid */// logger.jsangular .module('app') .factory('logger', logger);// logger function会被当作一个全局变量function logger() &#123; &#125;// storage.jsangular .module('app') .factory('storage', storage);// storage function会被当作一个全局变量function storage() &#123; &#125; 123456789101112131415161718192021222324252627/** * recommended * * 再也不存在全局变量了 */// logger.js(function() &#123; 'use strict'; angular .module('app') .factory('logger', logger); function logger() &#123; &#125;&#125;)();// storage.js(function() &#123; 'use strict'; angular .module('app') .factory('storage', storage); function storage() &#123; &#125;&#125;)(); 注：为了简洁起见，本规范余下的示例中将会省略IIFE语法。 注：IIFE阻止了测试代码访问私有成员（正则表达式、helper函数等），这对于自身测试是非常友好的。然而你可以把这些私有成员暴露到可访问成员中进行测试，例如把私有成员（正则表达式、helper函数等）放到factory或是constant中。 返回顶部 3. Modules避免命名冲突 每一个独立子模块使用唯一的命名约定。 为什么：避免冲突，每个模块也可以方便定义子模块。 定义(aka Setters) 不使用任何一个使用了setter语法的变量来定义modules。 为什么?：在一个文件只有一个组件的条件下，完全不需要为一个模块引入一个变量。 1234567/* avoid */var app = angular.module('app', [ 'ngAnimate', 'ngRoute', 'app.shared', 'app.dashboard']); 你只需要用简单的setter语法来代替。 12345678/* recommended */angular .module('app', [ 'ngAnimate', 'ngRoute', 'app.shared', 'app.dashboard' ]); Getters 使用module的时候，避免直接用一个变量，而是使用getter的链式语法。 为什么？：这将产生更加易读的代码，并且可以避免变量冲突和泄漏。 12345/* avoid */var app = angular.module('app');app.controller('SomeController', SomeController);function SomeController() &#123; &#125; 123456/* recommended */angular .module('app') .controller('SomeController', SomeController);function SomeController() &#123; &#125; Setting vs Getting 只能设置一次。 为什么？：一个module只能被创建一次，创建之后才能被检索到。 设置module，angular.module(&#39;app&#39;, []);。 获取module，angular.module(&#39;app&#39;);。 命名函数 vs 匿名函数 回调函数使用命名函数，不要用匿名函数。 为什么？：易读，方便调试，减少嵌套回调函数的数量。 12345/* avoid */angular .module('app') .controller('Dashboard', function() &#123; &#125;) .factory('logger', function() &#123; &#125;); 12345678/* recommended */// dashboard.jsangular .module('app') .controller('Dashboard', Dashboard);function Dashboard () &#123; &#125; 123456// logger.jsangular .module('app') .factory('logger', logger);function logger () &#123; &#125; 回到顶部 4. ControllerscontrollerAs在View中的语法 使用controllerAs 语法代替直接用经典的$scope定义的controller的方式。 为什么？：controller被构建的时候，就会有一个新的实例，controllerAs 的语法比经典的$scope语法更接近JavaScript构造函数。 为什么？：这促进在View中对绑定到“有修饰”的对象的使用（例如用customer.name 代替name），这将更有语境、更容易阅读，也避免了任何没有“修饰”而产生的引用问题。 为什么？：有助于避免在有嵌套的controllers的Views中调用 $parent。 1234&lt;!-- avoid --&gt;&lt;div ng-controller="Customer"&gt; &#123;&#123; name &#125;&#125;&lt;/div&gt; 1234&lt;!-- recommended --&gt;&lt;div ng-controller="Customer as customer"&gt; &#123;&#123; customer.name &#125;&#125;&lt;/div&gt; controllerAs在controller中的语法 使用 controllerAs 语法代替 经典的$scope语法 语法。 使用controllerAs 时，controller中的$scope被绑定到了this上。 为什么？：controllerAs 是$scope的语法修饰，你仍然可以绑定到View上并且访问 $scope的方法。 为什么？：避免在controller中使用 $scope，最好不用它们或是把它们移到一个factory中。factory中可以考虑使用$scope，controller中只在需要时候才使用$scope，例如当使用$emit， $broadcast，或者 $on。 12345/* avoid */function Customer ($scope) &#123; $scope.name = &#123;&#125;; $scope.sendMessage = function() &#123; &#125;;&#125; 12345/* recommended - but see next section */function Customer () &#123; this.name = &#123;&#125;; this.sendMessage = function() &#123; &#125;;&#125; controllerAs with vm 使用controllerAs语法时把this 赋值给一个可捕获的变量，选择一个有代表性的名称，例如vm代表ViewModel。 为什么？：this在不同的地方有不同的语义（就是作用域不同），在controller中的一个函数内部使用this时可能会改变它的上下文。用一个变量来捕获this的上下文从而可以避免遇到这样的坑。 12345/* avoid */function Customer() &#123; this.name = &#123;&#125;; this.sendMessage = function() &#123; &#125;;&#125; 123456/* recommended */function Customer () &#123; var vm = this; vm.name = &#123;&#125;; vm.sendMessage = function() &#123; &#125;;&#125; 注：你可以参照下面的做法来避免 jshint的警告。但是构造函数（函数名首字母大写）是不需要这个的. 12/* jshint validthis: true */var vm = this; 注：在controller中用controller as创建了一个watch时，可以用下面的语法监测vm.*的成员。（创建watch时要谨慎，因为它会增加更多的负载） 1&lt;input ng-model="vm.title"/&gt; 123456789function SomeController($scope, $log) &#123; var vm = this; vm.title = 'Some Title'; $scope.$watch('vm.title', function(current, original) &#123; $log.info('vm.title was %s', original); $log.info('vm.title is now %s', current); &#125;);&#125; 置顶绑定成员 把可绑定的成员放到controller的顶部，按字母排序，并且不要通过controller的代码传播。 为什么？：虽然设置单行匿名函数很容易，但是当这些函数的代码超过一行时，这将极大降低代码的可读性。在可绑定成员下面定义函数（这些函数被提出来），把具体的实现细节放到下面，可绑定成员置顶，这会提高代码的可读性。 123456789101112131415/* avoid */function Sessions() &#123; var vm = this; vm.gotoSession = function() &#123; /* ... */ &#125;; vm.refresh = function() &#123; /* ... */ &#125;; vm.search = function() &#123; /* ... */ &#125;; vm.sessions = []; vm.title = 'Sessions'; 1234567891011121314151617181920212223/* recommended */function Sessions() &#123; var vm = this; vm.gotoSession = gotoSession; vm.refresh = refresh; vm.search = search; vm.sessions = []; vm.title = 'Sessions'; //////////// function gotoSession() &#123; /* */ &#125; function refresh() &#123; /* */ &#125; function search() &#123; /* */ &#125; 注：如果一个函数就是一行，那么只要不影响可读性就把它放到顶部。 1234567891011121314151617/* avoid */function Sessions(data) &#123; var vm = this; vm.gotoSession = gotoSession; vm.refresh = function() &#123; /** * lines * of * code * affects * readability */ &#125;; vm.search = search; vm.sessions = []; vm.title = 'Sessions'; 123456789/* recommended */function Sessions(dataservice) &#123; var vm = this; vm.gotoSession = gotoSession; vm.refresh = dataservice.refresh; // 1 liner is OK vm.search = search; vm.sessions = []; vm.title = 'Sessions'; 函数声明隐藏实现细节 使用函数声明来隐藏实现细节，置顶绑定成员，当你需要在controller中绑定一个函数时，把它指向一个在文件的后面会出现函数声明。更多详情请看这里。 为什么？：易读，易识别哪些成员可以在View中绑定和使用。 为什么？：把函数的实现细节放到后面，你可以更清楚地看到重要的东西。 为什么？：由于函数声明会被置顶，所以没有必要担心在声明它之前就使用函数的问题。 为什么？：你再也不用担心当 a依赖于 b时，把var a放到var b之前会中断你的代码的函数声明问题。 为什么？：函数表达式中顺序是至关重要的。 1234567891011121314151617181920212223242526/** * avoid * Using function expressions. */function Avengers(dataservice, logger) &#123; var vm = this; vm.avengers = []; vm.title = 'Avengers'; var activate = function() &#123; return getAvengers().then(function() &#123; logger.info('Activated Avengers View'); &#125;); &#125; var getAvengers = function() &#123; return dataservice.getAvengers().then(function(data) &#123; vm.avengers = data; return vm.avengers; &#125;); &#125; vm.getAvengers = getAvengers; activate();&#125; 注意这里重要的代码分散在前面的例子中。下面的示例中，可以看到重要的代码都放到了顶部。实现的详细细节都在下方，显然这样的代码更易读。 1234567891011121314151617181920212223242526/* * recommend * Using function declarations * and bindable members up top. */function Avengers(dataservice, logger) &#123; var vm = this; vm.avengers = []; vm.getAvengers = getAvengers; vm.title = 'Avengers'; activate(); function activate() &#123; return getAvengers().then(function() &#123; logger.info('Activated Avengers View'); &#125;); &#125; function getAvengers() &#123; return dataservice.getAvengers().then(function(data) &#123; vm.avengers = data; return vm.avengers; &#125;); &#125;&#125; 把Controller中的逻辑延迟到Service中 通过委派到service和factory中来延迟controller中的逻辑。 为什么？：把逻辑放到service中，并通过一个function暴露，就可以被多个controller重用。 为什么？：把逻辑放到service中将会使单元测试的时候更加容易地把它们分离，相反，如果在controller中调用逻辑就显得很二了。 为什么？：保持controller的简洁。 为什么？：从controller中删除依赖关系并且隐藏实现细节。 123456789101112131415161718192021222324252627/* avoid */function Order($http, $q, config, userInfo) &#123; var vm = this; vm.checkCredit = checkCredit; vm.isCreditOk; vm.total = 0; function checkCredit () &#123; var settings = &#123;&#125;; // Get the credit service base URL from config // Set credit service required headers // Prepare URL query string or data object with request data // Add user-identifying info so service gets the right credit limit for this user. // Use JSONP for this browser if it doesn't support CORS return $http.get(settings) .then(function(data) &#123; // Unpack JSON data in the response object // to find maxRemainingAmount vm.isCreditOk = vm.total &lt;= maxRemainingAmount &#125;) .catch(function(error) &#123; // Interpret error // Cope w/ timeout? retry? try alternate service? // Re-reject with appropriate error for a user to see &#125;); &#125;;&#125; 12345678910111213/* recommended */function Order (creditService) &#123; var vm = this; vm.checkCredit = checkCredit; vm.isCreditOk; vm.total = 0; function checkCredit () &#123; return creditService.isOrderTotalOk(vm.total) .then(function(isOk) &#123; vm.isCreditOk = isOk; &#125;) .catch(showServiceError); &#125;;&#125; 保持Controller的专一性 一个view定义一个controller，尽量不要在其它view中使用这个controller。把可重用的逻辑放到factory中，保证controller只服务于当前视图。 为什么？：不同的view用同一个controller是非常不科学的，良好的端对端测试覆盖率对于保证大型应用稳定性是必需的。 分配Controller 当一个controller必须匹配一个view时或者任何一个组件可能被其它controller或是view重用时，连同controller的route一起定义。 注：如果一个view是通过route外的其它形式加载的，那么就用ng-controller=&quot;Avengers as vm&quot;语法。 为什么？：在route中匹配controller允许不同的路由调用不同的相匹配的controller和view，当在view中通过ng-controller分配controller时，这个view总是和相同的controller相关联。 12345678910111213/* avoid - when using with a route and dynamic pairing is desired */// route-config.jsangular .module('app') .config(config);function config ($routeProvider) &#123; $routeProvider .when('/avengers', &#123; templateUrl: 'avengers.html' &#125;);&#125; 123&lt;!-- avengers.html --&gt;&lt;div ng-controller="Avengers as vm"&gt;&lt;/div&gt; 123456789101112131415/* recommended */// route-config.jsangular .module('app') .config(config);function config ($routeProvider) &#123; $routeProvider .when('/avengers', &#123; templateUrl: 'avengers.html', controller: 'Avengers', controllerAs: 'vm' &#125;);&#125; 123&lt;!-- avengers.html --&gt;&lt;div&gt;&lt;/div&gt; 返回顶部 5. Services单例 用new实例化service，用this实例化公共方法和变量，由于这和factory是类似的，所以为了保持统一，推荐用facotry来代替。 注意：所有的Angular services都是单例，这意味着每个injector都只有一个实例化的service。 12345678910// serviceangular .module('app') .service('logger', logger);function logger () &#123; this.logError = function(msg) &#123; /* */ &#125;;&#125; 123456789101112// factoryangular .module('app') .factory('logger', logger);function logger () &#123; return &#123; logError: function(msg) &#123; /* */ &#125; &#125;;&#125; 返回顶部 6. Factories单一职责 factory应该是单一职责，这是由其上下文进行封装的。一旦一个factory将要处理超过单一的目的时，就应该创建一个新的factory。 单例 facotry是一个单例，它返回一个包含service成员的对象。 注：所有的Angular services都是单例，这意味着每个injector都只有一个实例化的service。 可访问的成员置顶 使用从显露模块模式派生出来的技术把service（它的接口）中可调用的成员暴露到顶部， 为什么？：易读，并且让你可以立即识别service中的哪些成员可以被调用，哪些成员必须进行单元测试（或者被别人嘲笑）。 为什么？：当文件内容很长时，这可以避免需要滚动才能看到暴露了哪些东西。 为什么？：虽然你可以随意写一个函数，但当函数代码超过一行时就会降低可读性并造成滚动。通过把实现细节放下面、把可调用接口置顶的形式返回service的方式来定义可调用的接口，从而使代码更加易读。 12345678910111213141516/* avoid */function dataService () &#123; var someValue = ''; function save () &#123; /* */ &#125;; function validate () &#123; /* */ &#125;; return &#123; save: save, someValue: someValue, validate: validate &#125;;&#125; 1234567891011121314151617181920/* recommended */function dataService () &#123; var someValue = ''; var service = &#123; save: save, someValue: someValue, validate: validate &#125;; return service; //////////// function save () &#123; /* */ &#125;; function validate () &#123; /* */ &#125;;&#125; 这种绑定方式复制了宿主对象，原始值不会随着暴露模块模式的使用而更新。 函数声明隐藏实现细节 函数声明隐藏实现细节，置顶绑定成员，当你需要在controller中绑定一个函数时，把它指向一个函数声明，这个函数声明在文件的后面会出现。 为什么？：易读，易识别哪些成员可以在View中绑定和使用。 为什么？：把函数的实现细节放到后面，你可以更清楚地看到重要的东西。 为什么？：由于函数声明会被置顶，所以没有必要担心在声明它之前就使用函数的问题。 为什么？：你再也不用担心当 a依赖于 b时，把var a放到var b之前会中断你的代码的函数声明问题。 为什么？：函数表达式中顺序是至关重要的。 12345678910111213141516171819202122232425262728293031323334353637/** * avoid * Using function expressions */ function dataservice($http, $location, $q, exception, logger) &#123; var isPrimed = false; var primePromise; var getAvengers = function() &#123; // implementation details go here &#125;; var getAvengerCount = function() &#123; // implementation details go here &#125;; var getAvengersCast = function() &#123; // implementation details go here &#125;; var prime = function() &#123; // implementation details go here &#125;; var ready = function(nextPromises) &#123; // implementation details go here &#125;; var service = &#123; getAvengersCast: getAvengersCast, getAvengerCount: getAvengerCount, getAvengers: getAvengers, ready: ready &#125;; return service;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * recommended * Using function declarations * and accessible members up top. */function dataservice($http, $location, $q, exception, logger) &#123; var isPrimed = false; var primePromise; var service = &#123; getAvengersCast: getAvengersCast, getAvengerCount: getAvengerCount, getAvengers: getAvengers, ready: ready &#125;; return service; //////////// function getAvengers() &#123; // implementation details go here &#125; function getAvengerCount() &#123; // implementation details go here &#125; function getAvengersCast() &#123; // implementation details go here &#125; function prime() &#123; // implementation details go here &#125; function ready(nextPromises) &#123; // implementation details go here &#125;&#125; 返回顶部 7. Data Services独立的数据调用 把进行数据操作和数据交互的逻辑放到factory中，数据服务负责XHR请求、本地存储、内存存储和其它任何数据操作。 为什么？：controller的作用是查看视图和收集视图的信息，它不应该关心如何取得数据，只需要知道哪里需要用到数据。把取数据的逻辑放到数据服务中能够让controller更简单、更专注于对view的控制。 为什么？：方便测试。 为什么？：数据服务的实现可能有非常明确的代码来处理数据仓库，这可能包含headers、如何与数据交互或是其它service，例如$http。把逻辑封装到单独的数据服务中，这隐藏了外部调用者（例如controller）对数据的直接操作，这样更加容易执行变更。 12345678910111213141516171819202122232425262728/* recommended */// dataservice factoryangular .module('app.core') .factory('dataservice', dataservice);dataservice.$inject = ['$http', 'logger'];function dataservice($http, logger) &#123; return &#123; getAvengers: getAvengers &#125;; function getAvengers() &#123; return $http.get('/api/maa') .then(getAvengersComplete) .catch(getAvengersFailed); function getAvengersComplete(response) &#123; return response.data.results; &#125; function getAvengersFailed(error) &#123; logger.error('XHR Failed for getAvengers.' + error.data); &#125; &#125;&#125; 注意：数据服务被调用时（例如controller），隐藏调用的直接行为，如下所示。 1234567891011121314151617181920212223242526272829/* recommended */// controller calling the dataservice factoryangular .module('app.avengers') .controller('Avengers', Avengers);Avengers.$inject = ['dataservice', 'logger'];function Avengers(dataservice, logger) &#123; var vm = this; vm.avengers = []; activate(); function activate() &#123; return getAvengers().then(function() &#123; logger.info('Activated Avengers View'); &#125;); &#125; function getAvengers() &#123; return dataservice.getAvengers() .then(function(data) &#123; vm.avengers = data; return vm.avengers; &#125;); &#125;&#125; 数据调用返回一个Promise 就像$http一样，调用数据时返回一个promise，在你的调用函数中也返回一个promise。 为什么？：你可以把promise链接到一起，在数据调用完成并且resolve或是reject这个promise后采取进一步的行为。 1234567891011121314151617181920212223242526272829303132333435/* recommended */activate();function activate() &#123; /** * Step 1 * Ask the getAvengers function for the * avenger data and wait for the promise */ return getAvengers().then(function() &#123; /** * Step 4 * Perform an action on resolve of final promise */ logger.info('Activated Avengers View'); &#125;);&#125;function getAvengers() &#123; /** * Step 2 * Ask the data service for the data and wait * for the promise */ return dataservice.getAvengers() .then(function(data) &#123; /** * Step 3 * set the data and resolve the promise */ vm.avengers = data; return vm.avengers; &#125;);&#125; 返回顶部 8. Directives一个directive一个文件 一个文件中只创建一个directive，并依照directive来命名文件。 为什么？：虽然把所有directive放到一个文件中很简单，但是当一些directive是跨应用的，一些是跨模块的，一些仅仅在一个模块中使用时，想把它们独立出来就非常困难了。 为什么？：一个文件一个directive也更加容易维护。 注： “最佳实践：Angular文档中有提过，directive应该自动回收，当directive被移除后，你可以使用element.on(&#39;$destroy&#39;, ...)或者scope.$on(&#39;$destroy&#39;, ...)来执行一个clean-up函数。” 1234567891011121314151617181920212223242526/* avoid *//* directives.js */angular .module('app.widgets') /* order directive仅仅会被order module用到 */ .directive('orderCalendarRange', orderCalendarRange) /* sales directive可以在sales app的任意地方使用 */ .directive('salesCustomerInfo', salesCustomerInfo) /* spinner directive可以在任意apps中使用 */ .directive('sharedSpinner', sharedSpinner);function orderCalendarRange() &#123; /* implementation details */&#125;function salesCustomerInfo() &#123; /* implementation details */&#125;function sharedSpinner() &#123; /* implementation details */&#125; 1234567891011121314/* recommended *//* calendarRange.directive.js *//** * @desc order directive that is specific to the order module at a company named Acme * @example &lt;div acme-order-calendar-range&gt;&lt;/div&gt; */angular .module('sales.order') .directive('acmeOrderCalendarRange', orderCalendarRange);function orderCalendarRange() &#123; /* implementation details */&#125; 1234567891011121314/* recommended *//* customerInfo.directive.js *//** * @desc sales directive that can be used anywhere across the sales app at a company named Acme * @example &lt;div acme-sales-customer-info&gt;&lt;/div&gt; */angular .module('sales.widgets') .directive('acmeSalesCustomerInfo', salesCustomerInfo);function salesCustomerInfo() &#123; /* implementation details */&#125; 1234567891011121314/* recommended *//* spinner.directive.js *//** * @desc spinner directive that can be used anywhere across apps at a company named Acme * @example &lt;div acme-shared-spinner&gt;&lt;/div&gt; */angular .module('shared.widgets') .directive('acmeSharedSpinner', sharedSpinner);function sharedSpinner() &#123; /* implementation details */&#125; 注：由于directive使用条件比较广，所以命名就存在很多的选项。选择一个让directive和它的文件名都清楚分明的名字。下面有一些例子，不过更多的建议去看命名章节。 在directive中操作DOM 当需要直接操作DOM的时候，使用directive。如果有替代方法可以使用，例如：使用CSS来设置样式、animation services、Angular模板、ngShow或者ngHide，那么就直接用这些即可。例如，如果一个directive只是想控制显示和隐藏，用ngHide/ngShow即可。 为什么？：DOM操作的测试和调试是很困难的，通常会有更好的方法（CSS、animations、templates）。 提供一个唯一的Directive前缀 提供一个短小、唯一、具有描述性的directive前缀，例如acmeSalesCustomerInfo在HTML中声明为acme-sales-customer-info。 为什么？：方便快速识别directive的内容和起源，例如acme-可能预示着这个directive是服务于Acme company。 注：避免使用ng-为前缀，研究一下其它广泛使用的directive避免命名冲突，例如Ionic Framework的ion-。 限制元素和属性 当创建一个directive需要作为一个独立元素时，restrict值设置为E（自定义元素），也可以设置可选值A（自定义属性）。一般来说，如果它就是为了独立存在，用E是合适的做法。一般原则是允许EA，但是当它是独立的时候这更倾向于作为一个元素来实施，当它是为了增强已存在的DOM元素时则更倾向于作为一个属性来实施。 为什么？：这很有意义！ 为什么？：虽然我们允许directive被当作一个class来使用，但如果这个directive的行为确实像一个元素的话，那么把directive当作元素或者属性是更有意义的。 注：Angular 1.3 +默认使用EA。 12&lt;!-- avoid --&gt;&lt;div class="my-calendar-range"&gt;&lt;/div&gt; 1234567891011121314151617/* avoid */angular .module('app.widgets') .directive('myCalendarRange', myCalendarRange);function myCalendarRange () &#123; var directive = &#123; link: link, templateUrl: '/template/is/located/here.html', restrict: 'C' &#125;; return directive; function link(scope, element, attrs) &#123; /* */ &#125;&#125; 123&lt;!-- recommended --&gt;&lt;my-calendar-range&gt;&lt;/my-calendar-range&gt;&lt;div my-calendar-range&gt;&lt;/div&gt; 1234567891011121314151617/* recommended */angular .module('app.widgets') .directive('myCalendarRange', myCalendarRange);function myCalendarRange () &#123; var directive = &#123; link: link, templateUrl: '/template/is/located/here.html', restrict: 'EA' &#125;; return directive; function link(scope, element, attrs) &#123; /* */ &#125;&#125; Directives和ControllerAs directive使用controller as语法，和view使用controller as保持一致。 为什么？：因为不难且有必要这样做。 注意：下面的directive演示了一些你可以在link和directive控制器中使用scope的方法，用controllerAs。这里把template放在行内是为了在一个地方写出这些代码。 注意：关于依赖注入的内容，请看手动依赖注入。 注意：directive的控制器是在directive外部的，这种风格避免了由于注入造成的return之后的代码无法访问的情况。 1&lt;div my-example max="77"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940angular .module('app') .directive('myExample', myExample);function myExample() &#123; var directive = &#123; restrict: 'EA', templateUrl: 'app/feature/example.directive.html', scope: &#123; max: '=' &#125;, link: linkFunc, controller : ExampleController, controllerAs: 'vm', bindToController: true // because the scope is isolated &#125;; return directive; function linkFunc(scope, el, attr, ctrl) &#123; console.log('LINK: scope.min = %s *** should be undefined', scope.min); console.log('LINK: scope.max = %s *** should be undefined', scope.max); console.log('LINK: scope.vm.min = %s', scope.vm.min); console.log('LINK: scope.vm.max = %s', scope.vm.max); &#125;&#125;ExampleController.$inject = ['$scope'];function ExampleController($scope) &#123; // Injecting $scope just for comparison var vm = this; vm.min = 3; console.log('CTRL: $scope.vm.min = %s', $scope.vm.min); console.log('CTRL: $scope.vm.max = %s', $scope.vm.max); console.log('CTRL: vm.min = %s', vm.min); console.log('CTRL: vm.max = %s', vm.max);&#125; 1234&lt;!-- example.directive.html --&gt;&lt;div&gt;hello world&lt;/div&gt;&lt;div&gt;max=&#123;&#123;vm.max&#125;&#125;&lt;input ng-model="&#123;&#123;vm.max&#125;&#125;"/&gt;&lt;/div&gt;&lt;div&gt;min=&#123;&#123;vm.min&#125;&#125;&lt;input ng-model="&#123;&#123;vm.min&#125;&#125;"/&gt;&lt;/div&gt; 注意：当你把controller注入到link的函数或可访问的directive的attributes时，你可以把它命名为控制器的属性。 1234567// Alternative to above examplefunction linkFunc(scope, el, attr, vm) &#123; // 和上面例子的区别在于把vm直接传递进来 console.log('LINK: scope.min = %s *** should be undefined', scope.min); console.log('LINK: scope.max = %s *** should be undefined', scope.max); console.log('LINK: vm.min = %s', vm.min); console.log('LINK: vm.max = %s', vm.max);&#125; 当directive中使用了controller as语法时，如果你想把父级作用域绑定到directive的controller作用域时，使用bindToController = true。 为什么？：这使得把外部作用域绑定到directive controller中变得更加简单。 注意：Angular 1.3.0才介绍了bindToController。 1&lt;div my-example max="77"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425angular .module('app') .directive('myExample', myExample);function myExample() &#123; var directive = &#123; restrict: 'EA', templateUrl: 'app/feature/example.directive.html', scope: &#123; max: '=' &#125;, controller: ExampleController, controllerAs: 'vm', bindToController: true &#125;; return directive;&#125;function ExampleController() &#123; var vm = this; vm.min = 3; console.log('CTRL: vm.min = %s', vm.min); console.log('CTRL: vm.max = %s', vm.max);&#125; 1234&lt;!-- example.directive.html --&gt;&lt;div&gt;hello world&lt;/div&gt;&lt;div&gt;max=&#123;&#123;vm.max&#125;&#125;&lt;input ng-model="vm.max"/&gt;&lt;/div&gt;&lt;div&gt;min=&#123;&#123;vm.min&#125;&#125;&lt;input ng-model="vm.min"/&gt;&lt;/div&gt; 返回顶部 9. 解决Controller的PromisesController Activation Promises 在activate函数中解决controller的启动逻辑。 为什么？：把启动逻辑放在一个controller中固定的位置可以方便定位、有利于保持测试的一致性，并能够避免controller中到处都是激活逻辑。 为什么？：activate这个controller使得重用刷新视图的逻辑变得很方便，把所有的逻辑都放到了一起，可以让用户更快地看到视图，可以很轻松地对ng-view 或 ui-view使用动画，用户体验更好。 注意：如果你需要在开始使用controller之前有条件地取消路由，那么就用route resolve来代替。 1234567891011/* avoid */function Avengers(dataservice) &#123; var vm = this; vm.avengers = []; vm.title = 'Avengers'; dataservice.getAvengers().then(function(data) &#123; vm.avengers = data; return vm.avengers; &#125;);&#125; 1234567891011121314151617/* recommended */function Avengers(dataservice) &#123; var vm = this; vm.avengers = []; vm.title = 'Avengers'; activate(); //////////// function activate() &#123; return dataservice.getAvengers().then(function(data) &#123; vm.avengers = data; return vm.avengers; &#125;); &#125;&#125; Route Resolve Promises 当一个controller在激活之前，需要依赖一个promise的完成时，那么就在controller的逻辑执行之前在$routeProvider中解决这些依赖。如果你需要在controller被激活之前有条件地取消一个路由，那么就用route resolver。 当你决定在过渡到视图之前取消路由时，使用route resolve。 为什么？：controller在加载前可能需要一些数据，这些数据可能是从一个通过自定义factory或是$http的promise而来的。route resolve允许promise在controller的逻辑执行之前解决，因此它可能对从promise中来的数据做一些处理。 为什么？：这段代码将在路由后的controller的激活函数中执行，视图立即加载，promise resolve的时候将会开始进行数据绑定，可以（通过ng-view或ui-view）在视图的过渡之间加个loading状态的动画。 注意：这段代码将在路由之前通过一个promise来执行，拒绝了承诺就会取消路由，接受了就会等待路由跳转到新视图。如果你想更快地进入视图，并且无需验证是否可以进入视图，你可以考虑用控制器 activate 技术。 1234567891011121314/* avoid */angular .module('app') .controller('Avengers', Avengers);function Avengers (movieService) &#123; var vm = this; // unresolved vm.movies; // resolved asynchronously movieService.getMovies().then(function(response) &#123; vm.movies = response.movies; &#125;);&#125; 12345678910111213141516171819202122232425262728293031/* better */// route-config.jsangular .module('app') .config(config);function config ($routeProvider) &#123; $routeProvider .when('/avengers', &#123; templateUrl: 'avengers.html', controller: 'Avengers', controllerAs: 'vm', resolve: &#123; moviesPrepService: function(movieService) &#123; return movieService.getMovies(); &#125; &#125; &#125;);&#125;// avengers.jsangular .module('app') .controller('Avengers', Avengers);Avengers.$inject = ['moviesPrepService'];function Avengers (moviesPrepService) &#123; var vm = this; vm.movies = moviesPrepService.movies;&#125; 注意：下面这个例子展示了命名函数的路由解决，这种方式对于调试和处理依赖注入更加方便。 123456789101112131415161718192021222324252627282930313233/* even better */// route-config.jsangular .module('app') .config(config);function config($routeProvider) &#123; $routeProvider .when('/avengers', &#123; templateUrl: 'avengers.html', controller: 'Avengers', controllerAs: 'vm', resolve: &#123; moviesPrepService: moviesPrepService &#125; &#125;);&#125;function moviesPrepService(movieService) &#123; return movieService.getMovies();&#125;// avengers.jsangular .module('app') .controller('Avengers', Avengers);Avengers.$inject = ['moviesPrepService'];function Avengers(moviesPrepService) &#123; var vm = this; vm.movies = moviesPrepService.movies;&#125; 注意：示例代码中的movieService不符合安全压缩的做法，可以到手动依赖注入和压缩和注释部分学习如何安全压缩。 返回顶部 10. 手动依赖注入压缩的不安全性 声明依赖时避免使用缩写语法。 为什么？：组件的参数（例如controller、factory等等）将会被转换成各种乱七八糟错误的变量。例如，common和dataservice可能会变成a或者b，但是这些转换后的变量在Angular中是找不到的。 1234567/* avoid - not minification-safe*/angular .module('app') .controller('Dashboard', Dashboard);function Dashboard(common, dataservice) &#123;&#125; 这一段代码在压缩时会产生错误的变量，因此在运行时就会报错。 12/* avoid - not minification-safe*/angular.module('app').controller('Dashboard', d);function d(a, b) &#123; &#125; 手动添加依赖 用$inject手动添加Angular组件所需的依赖。 为什么？：这种技术反映了使用ng-annotate的技术，这就是我推荐的对依赖关系进行自动化创建安全压缩的方式，如果ng-annotate检测到已经有了注入，那么它就不会再次重复执行。 为什么？：可以避免依赖变成其它Angular找不到的变量，例如，common和dataservice可能会变成a或者b。 为什么？：避免创建内嵌的依赖，因为一个数组太长不利于阅读，此外，内嵌的方式也会让人感到困惑，比如数组是一系列的字符串，但是最后一个却是组件的function。 1234567/* avoid */angular .module('app') .controller('Dashboard', ['$location', '$routeParams', 'common', 'dataservice', function Dashboard($location, $routeParams, common, dataservice) &#123;&#125; ]); 12345678/* avoid */angular .module('app') .controller('Dashboard', ['$location', '$routeParams', 'common', 'dataservice', Dashboard]);function Dashboard($location, $routeParams, common, dataservice) &#123;&#125; 123456789/* recommended */angular .module('app') .controller('Dashboard', Dashboard);Dashboard.$inject = ['$location', '$routeParams', 'common', 'dataservice'];function Dashboard($location, $routeParams, common, dataservice) &#123;&#125; 注意：当你的函数处于return语句后面，那么$inject是无法访问的（这会在directive中发生），你可以通过把Controller移到directive外面来解决这个问题。 12345678910111213/* avoid */// inside a directive definitionfunction outer() &#123; var ddo = &#123; controller: DashboardPanelController, controllerAs: 'vm' &#125;; return ddo; DashboardPanelController.$inject = ['logger']; // Unreachable function DashboardPanelController(logger) &#123; &#125;&#125; 12345678910111213/* recommended */// outside a directive definitionfunction outer() &#123; var ddo = &#123; controller: DashboardPanelController, controllerAs: 'vm' &#125;; return ddo;&#125;DashboardPanelController.$inject = ['logger'];function DashboardPanelController(logger) &#123;&#125; 手动确定路由解析器依赖 用$inject手动给Angular组件添加路由解析器依赖。 为什么？：这种技术打破了路由解析的匿名函数的形式，易读。 为什么？：$inject语句可以让任何依赖都可以安全压缩。 1234567891011121314151617/* recommended */function config ($routeProvider) &#123; $routeProvider .when('/avengers', &#123; templateUrl: 'avengers.html', controller: 'AvengersController', controllerAs: 'vm', resolve: &#123; moviesPrepService: moviesPrepService &#125; &#125;);&#125;moviesPrepService.$inject = ['movieService'];function moviesPrepService(movieService) &#123; return movieService.getMovies();&#125; 返回顶部 11. 压缩和注释ng-annotate 在Gulp或Grunt中使用ng-annotate，用/** @ngInject */对需要自动依赖注入的function进行注释。 为什么？：可以避免代码中的依赖使用到任何不安全的写法。 为什么？：不推荐用ng-min。 我更喜欢Gulp，因为我觉得它是易写易读易调试的。 下面的代码没有注入依赖，显然压缩是不安全的。 123456789101112131415angular .module('app') .controller('Avengers', Avengers);/* @ngInject */function Avengers (storageService, avengerService) &#123; var vm = this; vm.heroSearch = ''; vm.storeHero = storeHero; function storeHero()&#123; var hero = avengerService.find(vm.heroSearch); storageService.save(hero.name, hero); &#125;&#125; 当上面的代码通过ng-annotate运行时，就会产生如下的带有$inject注释的输出结果，这样的话压缩就会安全了。 1234567891011121314151617angular .module('app') .controller('Avengers', Avengers);/* @ngInject */function Avengers (storageService, avengerService) &#123; var vm = this; vm.heroSearch = ''; vm.storeHero = storeHero; function storeHero()&#123; var hero = avengerService.find(vm.heroSearch); storageService.save(hero.name, hero); &#125;&#125;Avengers.$inject = ['storageService', 'avengerService']; 注意：如果ng-annotate检测到已经有注入了（例如发现了@ngInject），就不会重复生成$inject代码了。 注意：路由的函数前面也可以用/* @ngInject */ 1234567891011121314// Using @ngInject annotationsfunction config($routeProvider) &#123; $routeProvider .when('/avengers', &#123; templateUrl: 'avengers.html', controller: 'Avengers', controllerAs: 'vm', resolve: &#123; /* @ngInject */ moviesPrepService: function(movieService) &#123; return movieService.getMovies(); &#125; &#125; &#125;);&#125; 注意：从Angular 1.3开始，你就可以用ngApp指令的 ngStrictDi参数来检测任何可能失去依赖的地方，当以“strict-di”模式创建injector时，会导致应用程序无法调用不使用显示函数注释的函数（这也许无法安全压缩）。记录在控制台的调试信息可以帮助追踪出问题的代码。我只在需要调试的时候才会用到ng-strict-di。&lt;body ng-app=&quot;APP&quot; ng-strict-di&gt; 使用Gulp或Grunt结合ng-annotate 在自动化任务中使用gulp-ng-annotate或grunt-ng-annotate，把/* @ngInject */注入到任何有依赖关系函数的前面。 为什么？：ng-annotate会捕获大部分的依赖关系，但是有时候需要借助于/* @ngInject */语法提示。 下面的代码是gulp任务使用ngAnnotate的例子。 123456789101112131415161718gulp.task('js', ['jshint'], function() &#123; var source = pkg.paths.js; return gulp.src(source) .pipe(sourcemaps.init()) .pipe(concat('all.min.js', &#123;newLine: ';'&#125;)) // Annotate before uglify so the code get's min'd properly. .pipe(ngAnnotate(&#123; // true helps add where @ngInject is not used. It infers. // Doesn't work with resolve, so we must be explicit there add: true &#125;)) .pipe(bytediff.start()) .pipe(uglify(&#123;mangle: true&#125;)) .pipe(bytediff.stop()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(pkg.paths.dev));&#125;); 返回顶部 12. 异常处理修饰符 使用一个decorator，在配置的时候用$provide服务，当发生异常时，在$exceptionHandler服务中执行自定义的处理方法。 为什么？：在开发时和运行时提供了一种统一的方式来处理未被捕获的Angular异常。 注：另一个选项是用来覆盖service的，这个可以代替decorator，这是一个非常nice的选项，但是如果你想保持默认行为，那么推荐你扩展一个decorator。 1234567891011121314151617181920212223242526272829/* recommended */angular .module('blocks.exception') .config(exceptionConfig);exceptionConfig.$inject = ['$provide'];function exceptionConfig($provide) &#123; $provide.decorator('$exceptionHandler', extendExceptionHandler);&#125;extendExceptionHandler.$inject = ['$delegate', 'toastr'];function extendExceptionHandler($delegate, toastr) &#123; return function(exception, cause) &#123; $delegate(exception, cause); var errorData = &#123; exception: exception, cause: cause &#125;; /** * Could add the error to a service's collection, * add errors to $rootScope, log errors to remote web server, * or log locally. Or throw hard. It is entirely up to you. * throw exception; */ toastr.error(exception.msg, errorData); &#125;;&#125; 异常捕获器 创建一个暴露了一个接口的factory来捕获异常并以合适方式处理异常。 为什么？：提供了一个统一的方法来捕获代码中抛出的异常。 注：异常捕获器对特殊异常的捕获和反应是非常友好的，例如，使用XHR从远程服务获取数据时，你想要捕获所有异常并做出不同的反应。 12345678910111213141516171819/* recommended */angular .module('blocks.exception') .factory('exception', exception);exception.$inject = ['logger'];function exception(logger) &#123; var service = &#123; catcher: catcher &#125;; return service; function catcher(message) &#123; return function(reason) &#123; logger.error(message, reason); &#125;; &#125;&#125; 路由错误 用$routeChangeError来处理并打印出所有的路由错误信息。 为什么？：提供一个统一的方式来处理所有的路由错误。 为什么？：当一个路由发生错误的时候，可以给展示一个提示信息，提高用户体验。 123456789101112131415161718192021222324252627282930313233/* recommended */var handlingRouteChangeError = false;function handleRoutingErrors() &#123; /** * Route cancellation: * On routing error, go to the dashboard. * Provide an exit clause if it tries to do it twice. */ $rootScope.$on('$routeChangeError', function(event, current, previous, rejection) &#123; if (handlingRouteChangeError) &#123; return; &#125; handlingRouteChangeError = true; var destination = (current &amp;&amp; (current.title || current.name || current.loadedTemplateUrl)) || 'unknown target'; var msg = 'Error routing to ' + destination + '. ' + (rejection.msg || ''); /** * Optionally log using a custom service or $log. * (Don't forget to inject custom service) */ logger.warning(msg, [current]); /** * On routing error, go to another route/state. */ $location.path('/'); &#125; );&#125; 返回顶部 13. 命名命名原则 遵循以描述组件功能，然后是类型（可选）的方式来给所有的组件提供统一的命名，我推荐的做法是feature.type.js。大多数文件都有2个名字。 文件名 (avengers.controller.js) 带有Angular的注册组件名 (AvengersController) 为什么？：命名约定有助于为一目了然地找到内容提供一个统一的方式，在项目中和团队中保持统一性是非常重要的，保持统一性对于跨公司来说提供了巨大的效率。 为什么？：命名约定应该只为代码的检索和沟通提供方便。 功能文件命名 遵循以“描述组件功能.类型（可选）”的方式来给所有的组件提供统一的命名，我推荐的做法是feature.type.js。 为什么？：为快速识别组件提供了统一的方式。 为什么？：为任何自动化的任务提供模式匹配。 12345678910111213/** * common options */// Controllersavengers.jsavengers.controller.jsavengersController.js// Services/Factorieslogger.jslogger.service.jsloggerService.js 12345678910111213141516171819202122232425262728/** * recommended */// controllersavengers.controller.jsavengers.controller.spec.js// services/factorieslogger.service.jslogger.service.spec.js// constantsconstants.js// module definitionavengers.module.js// routesavengers.routes.jsavengers.routes.spec.js// configurationavengers.config.js// directivesavenger-profile.directive.jsavenger-profile.directive.spec.js 注意：另外一种常见的约定就是不要用controller这个词来给controller文件命名，例如不要用avengers.controller.js，而是用avengers.js。所有其它的约定都坚持使用类型作为后缀，但是controller是组件中最为常用的类型，因此这种做法的好处貌似仅仅是节省了打字，但是仍然很容易识别。我建议你为你的团队选择一种约定，并且要保持统一性。我喜欢的命名方式是avengers.controller.js。 123456/** * recommended */// Controllersavengers.jsavengers.spec.js 测试文件命名 和组件命名差不多，带上一个spec后缀。 为什么？：为快速识别组件提供统一的方式。 为什么？：为karma或是其它测试运行器提供模式匹配。 1234567/** * recommended */avengers.controller.spec.jslogger.service.spec.jsavengers.routes.spec.jsavenger-profile.directive.spec.js Controller命名 为所有controller提供统一的名称，先特征后名字，鉴于controller是构造函数，所以要采用UpperCamelCase（每个单词首字母大写）的方式。 为什么？：为快速识别和引用controller提供统一的方式。 为什么？：UpperCamelCase是常规的识别一个可以用构造函数来实例化的对象的方式。 12345678910/** * recommended */// avengers.controller.jsangular .module .controller('HeroAvengersController', HeroAvengersController);function HeroAvengers()&#123; &#125; Controller命名后缀 使用Controller。 为什么？：Controller使用更广泛、更明确、更具有描述性。 12345678910/** * recommended */// avengers.controller.jsangular .module .controller('AvengersController', AvengersController);function AvengersController()&#123; &#125; Factory命名 一样要统一，对service和factory使用camel-casing（驼峰式，第一个单词首字母小写，后面单词首字母大写）方式。避免使用$前缀。 为什么？：可以快速识别和引用factory。 为什么？：避免与内部使用$前缀的服务发生冲突。 12345678910/** * recommended */// logger.service.jsangular .module .factory('logger', logger);function logger()&#123; &#125; Directive组件命名 使用camel-case方式，用一个短的前缀来描述directive在哪个区域使用（一些例子中是使用公司前缀或是项目前缀）。 为什么？：可以快速识别和引用controller。 123456789101112/** * recommended */// avenger-profile.directive.jsangular .module .directive('xxAvengerProfile', xxAvengerProfile);// usage is &lt;xx-avenger-profile&gt; &lt;/xx-avenger-profile&gt;function xxAvengerProfile()&#123; &#125; 模块 当有很多的模块时，主模块文件命名成app.module.js，其它依赖模块以它们代表的内容来命名。例如，一个管理员模块命名成admin.module.js，它们各自的注册模块名字就是app和admin。 为什么？：给多模块的应用提供统一的方式，这也是为了扩展大型应用。 为什么？：对使用任务来自动化加载所有模块的定义（先）和其它所有的angular文件（后）提供了一种简单的方式。 配置 把一个模块的配置独立到它自己的文件中，以这个模块为基础命名。app模块的配置文件命名成app.config.js（或是config.js），admin.module.js的配置文件命名成admin.config.js。 为什么？：把配置从模块定义、组件和活跃代码中分离出来。 为什么？：为设置模块的配置提供了一个可识别的地方。 路由 把路由的配置独立到单独的文件。主模块的路由可能是app.route.js，admin模块的路由可能是admin.route.js。即使是在很小的应用中，我也喜欢把路由的配置从其余的配置中分离出来。 返回顶部 14. 应用程序结构的LIFT准则LIFT 构建一个可以快速定位（Locate）代码、一目了然地识别（Identify）代码、拥有一个平直（Flattest）的结构、尽量（Try）坚持DRY（Don’t Repeat Yourself）的应用程序，其结构应该遵循这4项基本准则。 为什么是LIFT?: 提供一个有良好扩展的结构，并且是模块化的，更快的找到代码能够帮助开发者提高效率。另一种检查你的app结构的方法就是问你自己：你能多块地打开涉及到一个功能的所有相关文件并开始工作？ 当我发现我的的代码结构很恶心的时候，我就重新看看LIFT准则。 轻松定位代码（L） 一眼识别代码（I） 平直的代码结构（层级不要太多）（F） 尽量保持不要写重复代码（T） Locate 更直观、更简单、更快捷地定位代码 为什么？：我发现这对于一个项目是非常重要的，如果一个团队不能快速找到他们需要工作的文件，这将不能使团队足够高效地工作，那么这个代码结构就得改变。你可能不知道文件名或是相关的文件放在了哪里，那么就把他们放在最直观的地方，放在一起会节省大量的时间。下面是一个参考目录结构。 123456789101112131415/bower_components/client /app /avengers /blocks /exception /logger /core /dashboard /data /layout /widgets /content index.html.bower.json Identify 当你看到一个文件时你应该能够立即知道它包含了什么、代表了什么。 为什么？：你花费更少的时间来了解代码代表了什么，并且变得更加高效。如果这意味着你需要更长的名字，那么就这么干吧。文件名一定要具有描述性，保持和文件内容互为一体。避免文件中有多个controller，多个service，甚至是混合的。 Flat 尽可能长时间地保持一个平直的文件夹结构，如果你的文件夹层级超过7+，那么就开始考虑分离。 为什么？：没有谁想在一个7级文件夹中寻找一个文件，你可以考虑一下网页导航栏有那么多层。文件夹结构没有硬性规则，但是当一个文件夹下的文件有7-10个，那么就是时候创建子文件夹了，文件夹的层级一定要把握好。一直使用一个平直的结构，直到确实有必要（帮助其它的LIFT）创建一个新的文件夹。 T-DRY（尽量坚持DRY） 坚持DRY，但是不要疯了一样的做却牺牲了可读性。 为什么？：保持DRY很重要，但是如果牺牲了其它LIFT，那么它就没那么重要了，这就是为什么说尽量坚持DRY。 返回顶部 15. 应用程序结构总规范 有实施的短期看法和长远的目标，换句话说，从小处入手，但是要记住app的走向。app的所有代码都在一个叫做app的根目录下，所有的内容都遵循一个功能一个文件，每一个controller、service、module、view都是独立的文件。第三方脚本存放在另外的根文件夹中（bower_components、scripts、lib）。 注：了解实例结构的具体信息看Angular应用结构。 Layout 把定义应用程序总体布局的组件放到layout文件夹中，如导航、内容区等等。 为什么？：复用。 按功能划分文件夹结构 按照它们代表的功能来给创建的文件夹命名，当文件夹包含的文件超过7个（根据需要自行调整数量限制），就考虑新建文件夹。 为什么？：开发者可以快速定位代码、快速识别文件代表的意思，结构尽可能平直，没有重复，没有多余名字。 为什么？：LIFT规范都包括在内。 为什么？：通过组织内容和让它们保持和LIFT指导准则一致，帮助降低应用程序变得混乱的可能性。 为什么？：超过10个文件时，在一个一致性的文件夹中很容易定位，但是在一个平直的文件夹结构中确实很难定位。 123456789101112131415161718192021222324252627282930313233343536/** * recommended */app/ app.module.js app.config.js directives/ calendar.directive.js calendar.directive.html user-profile.directive.js user-profile.directive.html services/ dataservice.js localstorage.js logger.js spinner.js layout/ shell.html shell.controller.js topnav.html topnav.controller.js people/ attendees.html attendees.controller.js people.routes.js speakers.html speakers.controller.js speaker-detail.html speaker-detail.controller.js sessions/ sessions.html sessions.controller.js sessions.routes.js session-detail.html session-detail.controller.js 注意：不要使用按类型划分文件夹结构，因为如果这样的话，当做一个功能时，需要在多个文件夹中来回切换。当应用程序有5个、10个，甚至是25个以上的view、controller（或其他feature）时，这种方式将迅速变得不实用，这就使得它定位文件比按功能分文件夹的方式要困难的多。 12345678910111213141516171819202122232425262728293031323334353637/* * avoid * Alternative folders-by-type. * I recommend "folders-by-feature", instead. */app/ app.module.js app.config.js app.routes.js directives.js controllers/ attendees.js session-detail.js sessions.js shell.js speakers.js speaker-detail.js topnav.js directives/ calendar.directive.js calendar.directive.html user-profile.directive.js user-profile.directive.html services/ dataservice.js localstorage.js logger.js spinner.js views/ attendees.html session-detail.html sessions.html shell.html speakers.html speaker-detail.html topnav.html 返回顶部 16. 模块化许多小的、独立的模块 创建只封装一个职责的小模块。 为什么？：模块化的应用程序很容易添加新的功能。 创建一个App Module 创建一个应用程序的根模块，它的职责是把应用程序中所有的模块和功能都放到一起。 为什么？：Angular鼓励模块化和分离模式。创建根模块的作用是把其它模块都绑定到一起，这为增加或是删除一个模块提供了非常简单的方法。 为什么？：应用程序模块变成了一个描述哪些模块有助于定义应用程序的清单。 保持App Module的精简 app module中只放聚合其它模块的逻辑，具体功能在它们自己的模块中实现。 为什么？：添加额外的代码（获取数据、展现视图、其它和聚合模块无关的代码）到app module中使app module变得很糟糕，也使得模块难以重用和关闭。 功能区域就是模块 创建代表功能区的模块，例如布局、可重用、共享服务、仪表盘和app的特殊功能（例如客户、管理、销售）。 为什么？：自包含的模块可以无缝地被添加到应用程序中。 为什么？：项目进行功能迭代时，可以专注于功能，在开发完成启用它们即可。 为什么？：把功能拆分成不同模块方便测试。 可重用的块就是模块 为通用service创建代表可重用的应用程序块的模块，例如异常处理、日志记录、诊断、安全性和本地数据储藏等模块。 为什么？：这些类型的功能在很多应用程序中都需要用到，所以把它们分离到自己的模块中，它们可以变成通用的应用程序，也能被跨应用地进行重用。 模块依赖 应用程序根模块依赖于应用程序特定的功能模块、共享的和可复用的模块。 为什么？：主程序模块包含一个能快速识别应用程序功能的清单。 为什么？：每个功能区都包含一个它依赖了哪些模块的列表，因此其它应用可以把它当作一个依赖引入进来。 为什么？：程序内部的功能，如共享数据的服务变得容易定位，并且从app.core中共享。 注意：这是保持一致性的一种策略，这里有很多不错的选择，选择一种统一的，遵循Angular依赖规则，这将易于维护和扩展。 我的不同项目间的结构略有不同，但是它们都遵循了这些结构和模块化的准则,具体的实施方案会根据功能和团队发生变化。也就是说，不要在一棵树上吊死，但是心中一定要记得保持一致性、可维护性和效率。 小项目中，你可以直接把所有依赖都放到app module中，这对于小项目来说比较容易维护，但是想在此项目外重用模块就比较难了。 返回顶部 17. 启动逻辑配置 必须在angular应用启动前进行配置才能把代码注入到模块配置，理想的一些case应该包括providers和constants。 为什么？：这使得在更少的地方进行配置变得容易。 12345678910111213141516171819202122angular .module('app') .config(configure);configure.$inject = ['routerHelperProvider', 'exceptionHandlerProvider', 'toastr'];function configure (routerHelperProvider, exceptionHandlerProvider, toastr) &#123; exceptionHandlerProvider.configure(config.appErrorPrefix); configureStateHelper(); toastr.options.timeOut = 4000; toastr.options.positionClass = 'toast-bottom-right'; //////////////// function configureStateHelper() &#123; routerHelperProvider.configure(&#123; docTitle: 'NG-Modular: ' &#125;); &#125;&#125; 运行代码块 任何在应用程序启动时需要运行的代码都应该在factory中声明，通过一个function暴露出来，然后注入到运行代码块中。 为什么？：直接在运行代码块处写代码将会使得测试变得很困难，相反，如果放到facotry则会使的抽象和模拟变得很简单。 12345678910angular .module('app') .run(runBlock);runBlock.$inject = ['authenticator', 'translator'];function runBlock(authenticator, translator) &#123; authenticator.initialize(); translator.initialize();&#125; 返回顶部 18. Angular $包装服务$document和$window 用$document和$window代替document和window。 为什么？：使用内部包装服务将更容易测试，也避免了你自己去模拟document和window。 $timeout和$interval 用$timeout和$interval代替setTimeout和setInterval 。 为什么？：易于测试，处理Angular消化周期从而保证数据的同步绑定。 返回顶部 19. 测试单元测试有助于保持代码的清晰，因此我加入一些关于单元测试的基础和获取更多信息的链接。 用故事来编写测试 给每一个故事都写一组测试，先创建一个空的测试，然后用你给这个故事写的代码来填充它。 为什么？：编写测试有助于明确规定你的故事要做什么、不做什么以及你如何判断是否成功。 1234567891011121314151617it('should have Avengers controller', function() &#123; //TODO&#125;);it('should find 1 Avenger when filtered by name', function() &#123; //TODO&#125;);it('should have 10 Avengers', function() &#123; //TODO (mock data?)&#125;);it('should return Avengers via XHR', function() &#123; //TODO ($httpBackend?)&#125;);// and so on 测试库 用Jasmine或者Mocha进行单元测试。 为什么？：Angular社区中Jasmine和Mocha都用的很广，两者都很稳定，可维护性好，提供强大的测试功能。 注意：使用Mocha时你可以考虑选择一个类似Chai的提示库。 测试运行器 Karma。 为什么？：Karma容易配置，代码发生修改时自动运行。 为什么？：可以通过自身或是Grunt、Gulp方便地钩入持续集成的进程。 为什么？：一些IDE已经开始集成Karma了，如WebStorm和Visual Studio。 为什么？：Karma可以很好的和自动化任务工具如Grunt（带有grunt-karma）和Gulp（带有gulp-karma）合作。 Stubbing和Spying 用Sinon。 为什么？：Sinon可以和Jasmine和Mocha合作良好，并且可以扩展它们提供的stubbing和spying。 为什么？：如果你想试试Jasmine和Mocha，用Sinon在它们中间来回切换是很方便的。我更喜欢Mocha。 为什么？：测试失败Sinon有一个具有描述性的信息。 Headless Browser 在服务器上使用PhantomJS来运行你的测试。 为什么？：PhantomJS是一个headless browser，无需一个“可视”的浏览器来帮助你运行测试。因此你的服务器上不需要安装Chrome、Safari、IE或是其它浏览器。 注意：你仍然需要在你的环境下测试所有浏览器，来满足用户的需求。 代码分析 -在你的测试上运行JSHint。 *为什么？*：测试也是代码，JSHint能够帮你识别代码中可能导致测试无法正常工作的的质量问题。 对测试降低全局JSHint规则 对你的测试代码放宽规则，这样可以允许使用describe和expect等类似通用的全局方法。对表达式放宽规则，就行Mocha一样。 为什么？：测试也是代码，因此要和对待其它生产代码一样重视测试代码的质量。然而，测试框架中允许使用全局变量，例如，在你的测试单例中允许使用this。 1/* jshint -W117, -W030 */ 或者你也可以把下面的这几行加入到你的JSHint Options文件中。 12"jasmine": true,"mocha": true, 组织测试 将单元测试文件(specs)同被测试客户端代码并列放在同一个文件夹下，将多个组件共用的测试文件以及服务器集成测试的文件放到一个单独的tests文件夹下。 为什么？：单元测试和源代码中的每一个组件和文件都有直接的相关性。 为什么？：这样它就会一直在你的视野中，很容易让它们保持在最新状态。编码的时候无论你做TDD还是在开发过程中测试，或者开发完成后测试，这些单测都不会脱离你的视线和脑海，这样就更容易维护，也有助于保持代码的覆盖率。 为什么？：更新源代码的时候可以更简单地在同一时间更新测试代码。 为什么？：方便源码阅读者了解组件如何使用，也便于发现其中的局限性。 为什么？：方便找。 为什么？：方便使用grunt或者gulp。 1234567/src/client/app/customers/customer-detail.controller.js /customer-detail.controller.spec.js /customers.controller.js /customers.controller.spec.js /customers.module.js /customers.route.js /customers.route.spec.js 返回顶部 20. 动画用法 在页面过渡时使用Angular动画，包括ngAnimate模块。三个关键点是细微、平滑、无缝。 为什么？：使用得当的话能够提高用户体验。 为什么？：当视图过渡时，微小的动画可以提高感知性。 Sub Second 使用短持续性的动画，我一般使用300ms，然后调整到合适的时间。 为什么？：长时间的动画容易造成用户认为程序性能太差的影响。 animate.css 传统动画使用animate.css。 为什么？：css提供的动画是快速的、流畅的、易于添加到应用程序中的。 为什么？：为动画提供一致性。 为什么？：animate.css被广泛使用和测试。 注意：参阅Matias Niemelä的关于Angular动画的文章 返回顶部 21. 注释jsDoc 如果你准备做一个文档，那么就使用jsDoc的语法来记录函数名、描述、参数和返回值。使用@namespace和@memberOf来匹配应用程序结构。 为什么？：你可以从代码中生成（重新生成）文档，而不必从头开始编写文档。 为什么？：使用业内通用工具保持了统一性。 123456789101112131415161718192021222324252627282930313233343536/** * Logger Factory * @namespace Factories */(function() &#123; angular .module('app') .factory('logger', logger); /** * @namespace Logger * @desc Application wide logger * @memberOf Factories */ function logger ($log) &#123; var service = &#123; logError: logError &#125;; return service; //////////// /** * @name logError * @desc Logs errors * @param &#123;String&#125; msg Message to log * @returns &#123;String&#125; * @memberOf Factories.Logger */ function logError(msg) &#123; var loggedMsg = 'Error: ' + msg; $log.error(loggedMsg); return loggedMsg; &#125;; &#125;&#125;)(); 返回顶部 22. JS Hint使用一个Options文件 用JS Hint来分析你的JavaScript代码，确保你自定义了JS Hint选项文件并且包含在源控制里。详细信息：JS Hint文档。 为什么？：提交代码到原版本之前先发出警告。 为什么？：统一性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; "bitwise": true, "camelcase": true, "curly": true, "eqeqeq": true, "es3": false, "forin": true, "freeze": true, "immed": true, "indent": 4, "latedef": "nofunc", "newcap": true, "noarg": true, "noempty": true, "nonbsp": true, "nonew": true, "plusplus": false, "quotmark": "single", "undef": true, "unused": false, "strict": false, "maxparams": 10, "maxdepth": 5, "maxstatements": 40, "maxcomplexity": 8, "maxlen": 120, "asi": false, "boss": false, "debug": false, "eqnull": true, "esnext": false, "evil": false, "expr": false, "funcscope": false, "globalstrict": false, "iterator": false, "lastsemic": false, "laxbreak": false, "laxcomma": false, "loopfunc": true, "maxerr": false, "moz": false, "multistr": false, "notypeof": false, "proto": false, "scripturl": false, "shadow": false, "sub": true, "supernew": false, "validthis": false, "noyield": false, "browser": true, "node": true, "globals": &#123; "angular": false, "$": false &#125;&#125; 返回顶部 23. JSCS用一个Options文件 使用JSCS检查代码规范，确保你的代码控制中有定制的JSCS options文件，在这里JSCS docs查看更多信息。 为什么？：提交代码前第一时间提供一个预警。 为什么？：保持团队的一致性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123; "excludeFiles": ["node_modules/**", "bower_components/**"], "requireCurlyBraces": [ "if", "else", "for", "while", "do", "try", "catch" ], "requireOperatorBeforeLineBreak": true, "requireCamelCaseOrUpperCaseIdentifiers": true, "maximumLineLength": &#123; "value": 100, "allowComments": true, "allowRegex": true &#125;, "validateIndentation": 4, "validateQuoteMarks": "'", "disallowMultipleLineStrings": true, "disallowMixedSpacesAndTabs": true, "disallowTrailingWhitespace": true, "disallowSpaceAfterPrefixUnaryOperators": true, "disallowMultipleVarDecl": null, "requireSpaceAfterKeywords": [ "if", "else", "for", "while", "do", "switch", "return", "try", "catch" ], "requireSpaceBeforeBinaryOperators": [ "=", "+=", "-=", "*=", "/=", "%=", "&lt;&lt;=", "&gt;&gt;=", "&gt;&gt;&gt;=", "&amp;=", "|=", "^=", "+=", "+", "-", "*", "/", "%", "&lt;&lt;", "&gt;&gt;", "&gt;&gt;&gt;", "&amp;", "|", "^", "&amp;&amp;", "||", "===", "==", "&gt;=", "&lt;=", "&lt;", "&gt;", "!=", "!==" ], "requireSpaceAfterBinaryOperators": true, "requireSpacesInConditionalExpression": true, "requireSpaceBeforeBlockStatements": true, "requireLineFeedAtFileEnd": true, "disallowSpacesInsideObjectBrackets": "all", "disallowSpacesInsideArrayBrackets": "all", "disallowSpacesInsideParentheses": true, "validateJSDoc": &#123; "checkParamNames": true, "requireParamTypes": true &#125;, "disallowMultipleLineBreaks": true, "disallowCommaBeforeLineBreak": null, "disallowDanglingUnderscores": null, "disallowEmptyBlocks": null, "disallowMultipleLineStrings": null, "disallowTrailingComma": null, "requireCommaBeforeLineBreak": null, "requireDotNotation": null, "requireMultipleVarDecl": null, "requireParenthesesAroundIIFE": true&#125; 返回顶部 24. 常量###供应全局变量 为供应库中的全局变量创建一个Angular常量。 为什么？：提供一种注入到供应库的方法，否则就是全局变量。通过让你更容易地了解你的组件之间的依赖关系来提高代码的可测试性。这还允许你模拟这些依赖关系，这是很有意义的。 1234567891011// constants.js/* global toastr:false, moment:false */(function() &#123; 'use strict'; angular .module('app.core') .constant('toastr', toastr) .constant('moment', moment);&#125;)(); 对于一些不需要变动，也不需要从其它service中获取的值，使用常量定义，当一些常量只是在一个模块中使用但是有可能会在其它应用中使用的话，把它们写到一个以当前的模块命名的文件中。把常量集合到一起是非常有必要的，你可以把它们写到constants.js的文件中。 为什么？：一个可能变化的值，即使变动的很少，也会从service中重新被检索，因此你不需要修改源代码。例如，一个数据服务的url可以被放到一个常量中，但是更好的的做法是把它放到一个web service中。 为什么？：常量可以被注入到任何angular组件中，包括providers。 为什么？：当一个应用程序被分割成很多可以在其它应用程序中复用的小模块时，每个独立的模块都应该可以操作它自己包含的相关常量。 123456789101112// Constants used by the entire appangular .module('app.core') .constant('moment', moment);// Constants used only by the sales moduleangular .module('app.sales') .constant('events', &#123; ORDER_CREATED: 'event_order_created', INVENTORY_DEPLETED: 'event_inventory_depleted' &#125;); 返回顶部 25. 文件模板和片段为了遵循一致的规范和模式，使用文件模板和片段，这里有针对一些web开发的编辑器和IDE的模板和（或）片段。 Sublime Text Angular片段遵循这些规范。 下载Sublime Angular snippets 把它放到Packages文件夹中 重启Sublime 在JavaScript文件中输入下面的命令然后按下TAB键即可： 123456ngcontroller // creates an Angular controllerngdirective // creates an Angular directivengfactory // creates an Angular factoryngmodule // creates an Angular modulengservice // creates an Angular servicengfilter // creates an Angular filter Visual Studio Angular文件遵循SideWaffle所介绍的规范。 下载Visual Studio扩展文件SideWaffle 运行下载的vsix文件 重启Visual Studio WebStorm 你可以把它们导入到WebStorm设置中: 下载WebStorm Angular file templates and snippets 打开WebStorm点击File菜单 选择Import Settings菜单选项 选择文件点击OK 在JavaScript文件中输入下面的命令然后按下TAB键即可： 123ng-c // creates an Angular controllerng-f // creates an Angular factoryng-m // creates an Angular module Atom Angular片段遵循以下规范。 1apm install angularjs-styleguide-snippets 或 打开Atom，打开包管理器(Packages -&gt; Settings View -&gt; Install Packages/Themes) 搜索’angularjs-styleguide-snippets’ 点击’Install’ 进行安装 JavaScript文件中输入以下命令后以TAB结束 123456ngcontroller // creates an Angular controllerngdirective // creates an Angular directivengfactory // creates an Angular factoryngmodule // creates an Angular modulengservice // creates an Angular servicengfilter // creates an Angular filter Brackets Angular代码片段遵循以下规范。 下载Brackets Angular snippets 拓展管理器( File &gt; Extension manager ) 安装‘Brackets Snippets (by edc)’ Click the light bulb in brackets’ right gutter Click Settings and then Import Choose the file and select to skip or override Click Start Import JavaScript文件中输入以下命令后以TAB结束 1234567891011121314// These are full file snippets containing an IIFEngcontroller // creates an Angular controllerngdirective // creates an Angular directivengfactory // creates an Angular factoryngapp // creates an Angular module setterngservice // creates an Angular servicengfilter // creates an Angular filter// These are partial snippets intended to chainedngmodule // creates an Angular module getterngstate // creates an Angular UI Router state defintionngconfig // defines a configuration phase functionngrun // defines a run phase functionngroute // creates an Angular routeProvider vim vim代码片段遵循以下规范。 下载vim Angular代码段 设置neosnippet.vim 粘贴到snippet路径下 123456ngcontroller // creates an Angular controllerngdirective // creates an Angular directivengfactory // creates an Angular factoryngmodule // creates an Angular modulengservice // creates an Angular servicengfilter // creates an Angular filter 返回顶部 26. Yeoman Generator你可以使用HotTowel yeoman generator来创建一个遵循本规范的Angular入门应用。 安装generator-hottowel 1npm install -g generator-hottowel 创建一个新的文件夹并定位到它 12mkdir myappcd myapp 运行生成器 1yo hottowel helloWorld 返回顶部 27. 路由客户端路由对于在视图和很多小模板和指令组成的构成视图中创建导航是非常重要的。 用AngularUI Router来做路由控制。 为什么？：它包含了Angular路由的所有特性，并且增加了一些额外的特性，如嵌套路由和状态。 为什么？：语法和Angular路由很像，很容易迁移到UI Router。 注意：你可以在运行期间使用routerHelperProvider配置跨文件状态 12345678910111213141516171819202122// customers.routes.jsangular .module('app.customers') .run(appRun);/* @ngInject */function appRun(routerHelper) &#123; routerHelper.configureStates(getStates());&#125;function getStates() &#123; return [ &#123; state: 'customer', config: &#123; abstract: true, template: '&lt;ui-view class="shuffle-animation"/&gt;', url: '/customer' &#125; &#125; ];&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// routerHelperProvider.jsangular .module('blocks.router') .provider('routerHelper', routerHelperProvider);routerHelperProvider.$inject = ['$locationProvider', '$stateProvider', '$urlRouterProvider'];/* @ngInject */function routerHelperProvider($locationProvider, $stateProvider, $urlRouterProvider) &#123; /* jshint validthis:true */ this.$get = RouterHelper; $locationProvider.html5Mode(true); RouterHelper.$inject = ['$state']; /* @ngInject */ function RouterHelper($state) &#123; var hasOtherwise = false; var service = &#123; configureStates: configureStates, getStates: getStates &#125;; return service; /////////////// function configureStates(states, otherwisePath) &#123; states.forEach(function(state) &#123; $stateProvider.state(state.state, state.config); &#125;); if (otherwisePath &amp;&amp; !hasOtherwise) &#123; hasOtherwise = true; $urlRouterProvider.otherwise(otherwisePath); &#125; &#125; function getStates() &#123; return $state.get(); &#125; &#125;&#125; Define routes for views in the module where they exist，Each module should contain the routes for the views in the module. 为什么？：每个模块应该是独立的。 为什么？：当删除或增加一个模块时，应用程序只包含指向现存视图的路由。（也就是说删除模块和增加模块都需更新路由） 为什么？：这使得可以在不关心孤立的路由时很方便地启用或禁用应用程序的某些部分。 返回顶部 28. 任务自动化用Gulp或者Grunt来创建自动化任务。Gulp偏向于代码优先原则(code over configuration)而Grunt更倾向于配置优先原则(configuration over code)。我更倾向于使用gulp，因为gulp写起来比较简单。 可以在我的Gulp Pluralsight course了解更多gulp和自动化任务的信息 用任务自动化在其它JavaScript文件之前列出所有模块的定义文件*.module.js。 为什么？：Angular中，模块使用之前必须先注册。 为什么？：带有特殊规则的模块命名，例如*.module.js，会让你很轻松地识别它们。 1234567var clientApp = './src/client/app/';// Always grab module files firstvar files = [ clientApp + '**/*.module.js', clientApp + '**/*.js']; 返回顶部 29. Filters 避免使用filters扫描一个复杂对象的所有属性，应该用filters来筛选选择的属性。 为什么？：不恰当的使用会造成滥用并且会带来糟糕的性能问题，例如对一个复杂的对象使用过滤器。 返回顶部 30. Angular文档Angular文档。 返回顶部 reference: https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Angular规范</tag>
        <tag>规范指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git技巧汇总]]></title>
    <url>%2F2016%2F07%2F13%2F160713git%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Git是一个“分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过“回撤”这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用“回撤”是找不回来的。而“版本管理工具”能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。 下面的内容就是列举了常用的git命令和一些小技巧，可以通过”页面内查找”的方式进行快速查询：Ctrl/Command+f。 开卷必读如果之前未使用过Git，可以学习廖老师的免费Git教程入门 一定要先测试命令的效果后，再用于工作环境中，以防造成不能弥补的后果！到时候别拿着砍刀来找我 所有的命令都在git version 2.7.4 (Apple Git-66)下测试通过 统一概念： 工作区：改动（增删文件和内容） 暂存区：输入命令：git add 改动的文件名，此次改动就放到了‘暂存区’ 本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。 远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了‘远程仓库’（github等) commit-id：输出命令：git log，最上面那行commit xxxxxx，后面的字符串就是commit-id 如果喜欢这个项目，欢迎Star、提交Pr、反馈问题😊 目录 展示帮助信息 回到远程仓库的状态 重设第一个commit 展示工作区和暂存区的不同 展示暂存区和最近版本的不同 展示暂存区、工作区和最近版本的不同 快速切换分支 删除已经合并到master的分支 展示所有的分支关联的远程仓库 关联远程分支 删除本地分支 删除远程分支 查看标签 本地创建标签 推送标签到远程仓库 删除本地标签 删除远程标签 放弃工作区的修改 回到某一个commit的状态，并重新增添一个commit 回到某个commit的状态，并删除后面的commit 修改上一个commit的描述 查看commit历史 显示本地执行过git命令 修改作者名 修改远程仓库的url 列出所有远程仓库 列出本地和远程分支 列出远程分支 查看两个星期内的改动 把A分支的某一个commit，放到B分支上 给git命令起别名 存储当前的修改，但不用提交commit 保存当前状态，包括untracked的文件 展示所有stashes 回到某个stash的状态 回到最后一个stash的状态，并删除这个stash 删除所有的stash 从stash中拿出某个文件的修改 展示所有tracked的文件 展示所有untracked的文件 展示所有忽略的文件 强制删除untracked的文件 强制删除untracked的目录 重命名分支 展示简化的commit历史 查看某段代码是谁写的 把某一个分支到导出成一个文件 从包中导入分支 执行rebase之前自动stash 从远程仓库根据ID，拉下某一状态，到本地分支 详细展示一行中的修改 清除.gitignore文件中记录的文件 展示所有alias和configs 展示忽略的文件 commit历史中显示Branch1有的，但是Branch2没有commit 在commit log中显示GPG签名 删除全局设置 新建并切换到新分支上，同时这个分支没有任何commit 展示任意分支某一文件的内容 clone下来指定的单一分支 创建并切换到该分支 忽略文件的权限变化 展示本地所有的分支的commit 在commit log中查找相关内容 把暂存区的指定file放到工作区中 强制推送 增加远程仓库 联系我 展示帮助信息1git help -g 回到远程仓库的状态抛弃本地仓库的所有版本(commit)，回到远程仓库的状态。1git fetch --all &amp;&amp; git reset --hard origin/master 重设第一个commit也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了1git update-ref -d HEAD 展示工作区和暂存区的不同输出工作区和暂存区的different(不同)。1git diff 还可以展示本地仓库中任意两个commit之间的文件变动：1git diff &lt;commit-id&gt; &lt;commit-id&gt; 展示暂存区和最近版本的不同输出暂存区和本地最近的版本(commit)的different(不同)。1git diff --cached 展示暂存区、工作区和最近版本的不同输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。1git diff HEAD 快速切换分支1git checkout - 删除已经合并到master的分支1git branch --merged master | grep -v '^\*\| master' | xargs -n 1 git branch -d 展示所有的分支关联的远程仓库1git branch -vv 关联远程分支关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。1git branch -u origin/mybranch 或者在push时加上-u参数1git push origin/mybranch -u 删除本地分支1git branch -d &lt;local-branchname&gt; 删除远程分支1git push origin --delete &lt;remote-branchname&gt; 或者1git push origin :&lt;remote-branchname&gt; 查看标签1git tag 展示当前分支的最近的tag1git describe --tags --abbrev=0 本地创建标签1git tag &lt;version-number&gt; 默认tag是打在最近的一次commit上，如果需要指定commit打tag：1$ git tag -a &lt;version-number&gt; -m "v1.0 发布(描述)" &lt;commit-id&gt; 推送标签到远程仓库首先要保证本地创建好了标签才可以推送标签到远程仓库：1git push origin &lt;local-version-number&gt; 一次性推送所有标签，同步到远程仓库：1git push origin --tags 删除本地标签1git tag -d &lt;tag-name&gt; 删除远程标签删除远程标签需要先删除本地标签，再执行下面的命令1git push origin :refs/tags/&lt;tag-name&gt; 放弃工作区的修改1git checkout &lt;file-name&gt; 放弃所有修改：1git checkout . 回到某一个commit的状态，并重新增添一个commit1git revert &lt;commit-id&gt; 回到某个commit的状态，并删除后面的commit和revert的区别：reset命令会抹去某个commit id之后的所有commit1git reset &lt;commit-id&gt; 修改上一个commit的描述1git commit --amend 查看commit历史1git log 查看某段代码是谁写的blame的意思为‘责怪’，你懂的。1git blame &lt;file-name&gt; 显示本地执行过git命令就像shell的history一样1git reflog 修改作者名1git commit --amend --author='Author Name &lt;email@address.com&gt;' 修改远程仓库的url1git remote set-url origin &lt;URL&gt; 列出所有远程仓库1git remote 列出本地和远程分支-a参数相当于：all1git branch -a 列出远程分支-r参数相当于：remote1git branch -r 查看两个星期内的改动1git whatchanged --since='2 weeks ago' 把A分支的某一个commit，放到B分支上这个过程需要cherry-pick命令，参考1git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt; 给git命令起别名简化命令 12345git config --global alias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config --global alias.st status 存储当前的修改，但不用提交commit详解可以参考廖雪峰老师的git教程1git stash 保存当前状态，包括untracked的文件untracked文件：新建的文件1git stash -u 展示所有stashes1git stash list 回到某个stash的状态1git stash apply &lt;stash@&#123;n&#125;&gt; 回到最后一个stash的状态，并删除这个stash1git stash pop 删除所有的stash1git stash clear 从stash中拿出某个文件的修改1git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt; 展示所有tracked的文件1git ls-files -t 展示所有untracked的文件1git ls-files --others 展示所有忽略的文件1git ls-files --others -i --exclude-standard 强制删除untracked的文件可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点： clean后，删除的文件无法找回 不会影响tracked的文件的改动，只会删除untracked的文件 1git clean &lt;file-name&gt; -f 强制删除untracked的目录可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条 1git clean &lt;directory-name&gt; -df 重命名分支1git branch -m &lt;new-branch-name&gt; 展示简化的commit历史1git log --pretty=oneline --graph --decorate --all 把某一个分支到导出成一个文件1git bundle create &lt;file&gt; &lt;branch-name&gt; 从包中导入分支新建一个分支，分支内容就是上面git bundle create命令导出的内容1git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt; 执行rebase之前自动stash1git rebase --autostash 从远程仓库根据ID，拉下某一状态，到本地分支1git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt; 详细展示一行中的修改1git diff --word-diff 清除gitignore文件中记录的文件1git clean -X -f 展示所有alias和configs1git config --list 展示忽略的文件1git status --ignored commit历史中显示Branch1有的，但是Branch2没有commit1git log Branch1 ^Branch2 在commit log中显示GPG签名1git log --show-signature 删除全局设置1git config --global --unset &lt;entry-name&gt; 新建并切换到新分支上，同时这个分支没有任何commit相当于保存修改，但是重写commit历史1git checkout --orphan &lt;branch-name&gt; 展示任意分支某一文件的内容1git show &lt;branch-name&gt;:&lt;file-name&gt; clone下来指定的单一分支1git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git 创建并切换到该分支1git checkout -b &lt;branch-name&gt; 忽略文件的权限变化不再将文件的权限变化视作改动1git config core.fileMode false 展示本地所有的分支的commit最新的放在最上面 1git for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/ 在commit log中查找相关内容通过grep查找，given-text：所需要查找的字段 1git log --all --grep='&lt;given-text&gt;' 把暂存区的指定file放到工作区中1git reset &lt;file-name&gt; 强制推送1git push -f &lt;remote-name&gt; &lt;branch-name&gt; 增加远程仓库1git remote add origin &lt;remote-url&gt; ⬆ 返回顶部 reference: https://github.com/521xueweihan/git-tips]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化默认密码输入框]]></title>
    <url>%2F2016%2F06%2F19%2F160619%E4%BC%98%E5%8C%96%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%2F</url>
    <content type="text"><![CDATA[主要是为了弥补在移动端原生密码输入框默认样式比较单调，通过这样能够实现自定义密码框输出样式。代码如下，仅供参考— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;优化默认密码框&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scaleable=0&quot; /&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; html &#123; height: 100%; font-size: 16px; &#125; body &#123; height: 100%; background-color: skyblue; &#125; .container &#123; position: relative; margin: 100px 100px; &#125; .password &#123; display: block; &#125; ul &#123; display: inline-block; border: 1px solid #fff; margin: 0 auto; font-size: 0; position: relative; width: 12rem; height: 2rem; left: 50%; transform: translateX(-50%); &#125; li &#123; display: inline-block; width: 2rem; height: 2rem; background-color: #fff; font-size: 1.2rem; font-weight: 700; text-align: center; line-height: 2rem; border-left: 1px solid #e6e6e6; box-sizing: border-box; vertical-align: middle; overflow: hidden; &#125; li:first-child &#123; border-left: 0 none &#125; .input &#123; position: absolute; top: 0; left: -100%; width: 200%; height: 100%; opacity: 0; text-indent: -9999px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;password&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input class=&quot;input&quot; type=&quot;tel&quot; maxlength=&quot;6&quot; id=&quot;input&quot;&gt; &lt;label for=&quot;input&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;script src=&quot;./zepto.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&apos;body&apos;).on(&apos;input&apos;, &apos;.input&apos;, function() &#123; var $this = $(this), $inputs = $this.parent().find(&apos;.password li&apos;), password = $this.val() + &apos;&apos;; var numLen = 6; for (var i = 0; i &lt; numLen; i++) &#123; if (password[i]) &#123; $($inputs[i]).text(&apos;●&apos;); &#125; else &#123; $($inputs[i]).text(&apos;&apos;); &#125; &#125; if (password.length == 6) &#123; alert(&apos;6位密码已输完&apos;); $this.val(&apos;&apos;); $inputs.html(&apos;&apos;); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击查看效果]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置HybridApp&Android环境]]></title>
    <url>%2F2016%2F06%2F18%2F160618%E9%85%8D%E7%BD%AEHybridAppAndroid%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1、安装JAVA环境并配置JAVA环境变量http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html在硬盘中已经下载好了 2、配置环境变量2.1.在系统变量中添加JAVA_HOME把jdk的安装路径复制即可注意不要添加到用户变量当中，以防后续出bug； 2.2.在系统变量中增加CLASSPATH12 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;注意开头的一个点 2.3.在Path系统变量的后面增加 ;%JAVA_HOME%\bin;2.4.命令行输入javac正常运行即可3、安装android环境并配置android环境变量3.1-下载SDK Tools—-http://developer.android.com/sdk/index.html#Other 3.2-下载完毕安装或者解压后，在相应目录下找到并打开SDK Manager.exeSDK Manager默认勾选了一些选项，直接点击Install packages安装即可 如果安装过慢，可以用国内的镜像，或者分包下载http://www.androiddevtools.cn/ 找到相应的包下载即可： http://mirrors.opencas.cn/android/repository/ 我已经把这些包都下载好了，接下来就是按照文档目录分别解压到相应位置即可 3.3-Android环境变量配置：- a-找到SDK Manager所在的目录上面下载的包都在同一目录下 - b-新建系统变量：ANDROID_HOME变量值：C:\Program Files\android–注意这个变量值是安装的根目录 整个安装目录的结构图如下： 主要是安装以下打钩的几个 将这几个文件解压到相应文件夹即可 - c-在Path系统变量的后面增加—— ;%ANDROID_HOME%\tools ;%ANDROID_HOME%\platform-tools d-在命令行输入adb正常运行说明环境配置正确； tips:把bulid-tools中的android6.0改为下面的23.0.1 4、最后一步通过npm安装即可 1npm install -g cordova ionic 考虑到有部分用户可能因为被墙的原因npm安装不成功，可以参考我这篇文章来解决国内解决npm被墙的三种方式]]></content>
      <categories>
        <category>HybridApp</category>
      </categories>
      <tags>
        <tag>HybridApp</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS调试方法总结]]></title>
    <url>%2F2016%2F05%2F04%2F160504NodeJS%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、 console.logconsole.log 是最方便的，也是最快的，但是这种方法对于初学者来说肯定是不太适合的，接下来向下看 二、NodeJS内置调试器使用方式：在控制台中输入以下命令：1node debug 脚本文件名 执行上面的命令结束之后，代码会自动停在脚本的第一行，等待用户执行其它调试命令。如果你对相关命令不熟悉，那么可以通过输入 help 命令查看可用命令，代码显示如下1234567891011C:\Users\92816\Desktop\testprogramming&gt;node debug a.js&lt; Debugger listening on port 5858connecting to 127.0.0.1:5858 ... okbreak in C:\Users\92816\Desktop\testprogramming\a.js:1&gt; 1 &quot;use strict&quot;; 2 let foo = &apos;bar&apos;; 3 console.log(foo);debug&gt; helphelpCommands: run (r), cont (c), next (n), step (s), out (o), backtrace (bt), setBreakpoint (sb), clearBreakpoint (cb),watch, unwatch, watchers, repl, exec, restart, kill, list, scripts, breakOnException, breakpoints, version 如若想退出调试，则按上Ctrl+C按提示输入.exit即可。这种方法也算中规中矩，但是可能对于经常习惯于浏览器调试的会感到不习惯，下面介绍带可视化界面的方法 三、 node-inspectornode-inspector 是一个第三方全局命令行调试工具。node-inspector 3.1 安装1npm install -g node-inspector 3.2 启动调试方法一，直接使用node-debug 文件名1node-debug a.js node-debug 命令会自动在当前操作系统默认浏览器中加载node调试器,也就是说可以帮你自动打开你的默认浏览器，比较省心123456C:\Users\92816\Desktop\testprogramming&gt;node-debug a.jsNode Inspector v0.12.8Visit http://127.0.0.1:8080/?port=5858 to start debugging.Debugging `a.js`Debugger listening on port 5858 方法二，使用node –debug-brk 文件名再结合上node-inspector先打开一个命令行窗口可以输入下面的命令启动调试： 1node --debug-brk a.js 会显示如下12C:\Users\92816\Desktop\test&gt;node --debug-brk a.jsDebugger listening on port 5858 接下来在另外打开一个命令行窗口输入node-inspector,出现下面的提示，将http://127.0.0.1:8080/?port=5858复制到你的浏览器地址栏即可开始调试了123C:\Users\92816\Desktop\test&gt;node-inspectorNode Inspector v0.12.8Visit http://127.0.0.1:8080/?port=5858 to start debugging. 调试的快捷键和在 Chrome 浏览器中的快捷键是一样的,在这里就不多说了 四、 visual studio code 调试 node 这一款工具我个人觉得还是很好用的，界面做的也是非常不错的，推荐使用 visuao studio code 官方网站 4.1 下载visuao studio code 下载地址 4.2 安装手动安装，一直下一步下一步就可以了 4.3 开始调试vsc官方文档调试链接 必须以项目的方式打开要调试的js脚本所在的目录，目录路径最好不要包含中文，否则可能有问题 在要调试的脚本文件中，找到具体要设置断点的行，在左侧点击设置断点 设置好断点之后，按F5启动调试 这个时候，vsc 编辑器会提示你选择要调试的环境，这里选择 Node.js 即可 当选择完调试环境之后，vsc 默认会在当前根目录下生成一个 .vsccode 目录 在 .vsccode 目录下找到一个叫做 launch.json 的文件，打开编辑 在 launch.json 文件中，在 configurations 节点下找到一个叫做 program 的属性节点 将 program 属性节点中原来的值 ${workspaceRoot}/app.js 改为 ${workspaceRoot}/要调试的脚本文件名.js 修改完毕之后，按 Ctrl+C 保存 上述操作完成之后，按 F5 启动调试 尽情的享受 vsc 调试带给你的调试的乐趣吧 快捷键和 Chrome 浏览器中的调试环境快捷键一致 对于执行了以上操作还没有成功的，建议将 vsc 关闭重新打开再次按 F5 启动调试即可解决，如果有快捷键冲突的时候，可以使用fn+F5 五、 Webstorm 调试 (IDE方式） 按以下几步调试即可，相对来说也比较简单，就是可能比较重量级一些，喜欢轻量级的可以考虑使用visuao studio code; 5.1 开始调试 在要调试的文件中具体的行位置左边通过 Ctrl+F8 设置一个端点 在当前要调试的文件中通过鼠标右键，然后选择 Debug 要调试的文件名.js 这个时候 ws 会自动帮你启动调试模式，并且自动停留在你打击端点的位置 F8 步进 Shift + F8 步出 Alt + F8 可以执行一个表达式 Ctrl + F5 重新启动调试 结语&nbsp;&nbsp;&nbsp;&nbsp;这里也只是总结了五种调试方式，怎么说呢，工具肯定会有很多，我觉得最重要的是找到最适合自己的，有句话，适合自己的就是最好的！]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>调试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bower中文API]]></title>
    <url>%2F2016%2F05%2F03%2F160503Bower%E4%B8%AD%E6%96%87API%2F</url>
    <content type="text"><![CDATA[1. cache&nbsp;&nbsp;&nbsp;&nbsp;管理你已经缓存的包，最后的参数可传可不传，不传默认操作的是所有包，如果传了就是对指定的包进行操作,格式如下,1$ bower cache &lt;command&gt; [&lt;args&gt;] cache clean清除你所缓存的包，一共有三种形式的操作，代码如下 12345678# 清理所有缓存的包$ bower cache clean# 清理指定名字的包的缓存，也可指定多个，中间加上空格即可$ bower cache clean &lt;name&gt; [&lt;name&gt; ...]# 清理指定名字和版本的包的缓存，也可指定多个，中间加上空格即可，跟第二种类似，只是多加了指定版本$ bower cache clean &lt;name&gt;#&lt;version&gt; [&lt;name&gt;#&lt;version&gt; ..] cache list列出你所缓存的包，也就是缓存包的列表，包含每个包的名字以及这个包对应的github地址 1234# 列出了所有你所缓存包的列表$ bower cache list# 列出你所缓存的指定名字的包，可以多个，后面加空格即可$ bower cache list &lt;name&gt; [&lt;name&gt; ...] 例如我电脑上列出的：1234C:\Users\92816&gt;bower cache listbootstrap=https://github.com/twbs/bootstrap.git#3.2.6jquery=https://github.com/jquery/jquery-dist.git#1.7.2jquery=https://github.com/jquery/jquery-dist.git#1.8.3 2. help显示关于bower的帮助信息,后面可以加上具体的帮助类型名称，比如可以$ bower help search则会显示出对应search的一些说明和操作信息，如果不加则会显示出所有的类型的说明和操作信息1$ bower help &lt;command&gt; 例：输入$ bower help search，将会显示如下帮助信息，包括用法和描述123456789101112 Usage: bower search &lt;name&gt; [&lt;options&gt;]Options: -h, --help Show this help message Additionally all global options listed in &apos;bower help&apos; are availableDescription: Finds all packages or a specific package. 只输入 $ bower help,将会显示出所有的用法 1234567891011121314151617181920212223242526272829303132333435 Usage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache # 管理你缓存的包 help Display help information about Bower # 显示关于Bower的帮助信息 home Opens a package homepage into your favorite browser # 在你默认浏览器中打开一个包的主页 info Info of a particular package # 一个包的详细信息说明 init Interactively create a bower.json file # 初始化一个bower.json文件 install Install a package locally # 在本地安装一个包 link Symlink a package folder # 建立一个包文件夹的链接 list List local packages - and possible updates 列出本地所有的包以及可以更新的包 login Authenticate with GitHub and store credentials # 用github账号登陆 lookup Look up a package URL by name # 打开一个指定名字的包的官网 prune Removes local extraneous packages # 移除本地没有用的包 register Register a package # 注册一个包 search Search for a package by name # 根据名字搜索一个包 update Update a local package # 更新一个本地的宝 uninstall Remove a local package # 卸载一个本地的包 unregister Remove a package from the registry # 从注册表中移除一个包 version Bump a package version # 显示一个包的版本Options: -f, --force Makes various commands more forceful # 是各种命令行工具更加强大 -j, --json Output consumable JSON # 将帮助信息以JSON格式的输出 -l, --loglevel What level of logs to report # 生成日志级别 -o, --offline Do not hit the network # 离线模式 -q, --quiet Only output important information # 只输出重要信息 -s, --silent Do not output anything, besides errors # 除了错误，不要输出任何信息 -V, --verbose Makes output more verbose # 让输入信息更加详细 --allow-root Allows running commands as root # 允许以管理员权限在命令行运行 -v, --version Output Bower version # 输出bower的版本 --no-color Disable colors # 颜色不可用See &apos;bower help &lt;command&gt;&apos; for more information on a specific command. 3. home123$ bower home$ bower home &lt;package&gt;$ bower home &lt;package&gt;#&lt;version&gt; 在你的默认浏览器中打开一个包，或者指定版本的包的官方地址，一般都是github地址。如果没有包通过，那么将会打开你本地包的主页。 4. info123$ bower info &lt;package&gt;$ bower info &lt;package&gt; [&lt;property&gt;]$ bower info &lt;package&gt;#&lt;version&gt; [&lt;property&gt;] 显示一个包（或者指定版本的包）的整体详细信息，也可指定属性查看 5. init1$ bower init 一步一步提示你初始化一个bower.json文件 6. install12$ bower install [&lt;options&gt;]$ bower install &lt;endpoint&gt; [&lt;endpoint&gt; ..] [&lt;options&gt;] 安装一个项目的依赖项（dependencies）中列出的包一个项目的依赖项有以下这些部分组成： 在项目中的bower.json中指定的dependencies 所有外部的依赖项，虽然没有在bower.json当中指定，但是出现在bower_components中 任何在命令行终端作为参数增加的项当使用--save标识符的时候，所有增加的包的名字将会添加到bower.json中的dependencies中。Bower建议经常使用--save标识符去实现两个用户之间能够复用安装，也就是以后如果你将你的项目需要跟同事一起开发，那么无需将你所有依赖项的实体包都拷给同事，Bower会自动帮你安装bower.json中dependencies所列出的依赖项，并且后续万一你丢失了依赖项，那么bower也会自动按照dependencies帮你安装好丢失的依赖项，这一点无疑会很大程度的提高你的工作效率。终端可以有多种形式的输入： &lt;package&gt; &lt;package&gt;#&lt;version&gt; &lt;name&gt;=&lt;package&gt;#&lt;version&gt;在上面 &lt;package&gt;是一个包的URL路径，实际位置或者注册的名字 &lt;version&gt;是一个可用的版本和分支等。 &lt;name&gt;是一个本地应该有的名字 安装选项 -F, –force-latest: Force latest version on conflict。强制更新到最新版本 -p, –production: Do not install project devDependencies。不要安装到开发依赖项当中，其实也就是生产环境环境当中 -S, –save: Save installed packages into the project’s bower.json dependencies。保存所安装包到项目中bower.json的dependencies中。 -D, –save-dev: Save installed packages into the project’s bower.json devDependencies。保存所安装包到项目中bower.json的devDependencies中，其实也就是开发环境当中 -E, –save-exact: Configure installed packages with an exact version rather than semver。明确安装一个指定版本的包，而不是依赖项当中的。 7.link12$ bower link$ bower link &lt;name&gt; [&lt;local name&gt;] 这个link的功能可以让开发者们非常容易的测试他们的包，只需要两步。使用bower link在项目文件夹目录当中将会创建一个全局link。在其他一些包中，bower link &lt;name&gt;将会创建一个link在components文件夹当中并且指向先前创建的link.Using ‘bower link’ in a project folder will create a global link. Then, in some other package, bower link will create a link in the components folder pointing to the previously created link.它将会允许你特别容易的测试因为它们将会很快地反应。当一个link不再需要的时候，你仅仅需要通过bower uninstall &lt;name&gt;就可以将其移除。 上述link是也可以理解为链接的意思,能够快速链接指定的包。 8. list1$ bower list [&lt;options&gt;] 列出本地的包以及可以更新的包； list options（列表选项）12-p, --paths: # 生成一个JSON格式的路径地图-r, --relative: # 使路径相对于目录的`config`属性，默认为`bower components` 例：12345678910111213C:\Users\92816\Desktop\testprogramming&gt;bower list -p jquery: &apos;bower_components/jquery/dist/jquery.js&apos;, bootstrap: [ &apos;bower_components/bootstrap/less/bootstrap.less&apos;, &apos;bower_components/bootstrap/dist/js/bootstrap.js&apos; ]C:\Users\92816\Desktop\testprogramming&gt;bower list -rbower check-new Checking for new versions of the project dependencies...test C:\Users\92816\Desktop\testprogramming└─┬ bootstrap#3.3.6 (latest is 4.0.0-alpha.2) └── jquery#2.2.3 (latest is 3.0.0-beta1) 9. lookup1$ bower lookup &lt;name&gt; 通过一个包的名字查看其官方的github地址，然后你就可以复制下来去访问了例：12C:\Users\92816\Desktop\testprogramming&gt;bower lookup underscoreunderscore https://github.com/jashkenas/underscore.git 10. login1$ bower login 用github账号登陆 login options -t, –token: 通过现有的GitHub身份验证令牌登陆,不用再提示输入用户名和密码 11. prune1$ bower prune 卸载本地无用的包 12. register1$ bower register &lt;name&gt; &lt;url&gt; 注册一个包 13. search12$ bower search$ bower search &lt;name&gt; 搜索你需要的包 14. update1$ bower update &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 根据bower.json更新你所安装的包到最新版本 update options1234-F, --force-latest: 强制更新-p, --production: 生产环境-S, --save: 更新`bower.json`中的`dependencies`列处的项-D, --save-dev: 更新`bower.json`中的`devDependencies`列处的项,即更新开发版依赖的项。 15. uninstall1$ bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 从你本地的bower_components文件目录下卸载指定的包注意，默认情况下，会连所依赖的模块一起卸 载。比如，如果卸载jquery-ui，会连jquery一起卸载，除非还有别的模块依赖jquery,这一点大家可以留意一下 uninstall options（卸载选项） -S, –save: 也将会从项目的bower.json中dependencies移除该项-D, –save-dev: 也将会从项目的bower.json中devDependencies移除该项 16. version1$ bower version [&lt;newversion&gt; | major | minor | patch] 在这个包的目录下运行显示出它的版本并且在bower.json中写入一个新的数据。 17. Using local cache当你没有网的时候，只要你以前安装过，就可以从本地缓存中安装所需要的包 1$ bower install &lt;package&gt; --offline 你可以通过以下命令列出你所缓存的包的列表：例：123C:\Users\92816\Desktop\testprogramming&gt;bower cache listbootstrap=https://github.com/twbs/bootstrap.git#3.3.6jquery=https://github.com/jquery/jquery-dist.git#2.2.3 当然你也可以通过这个命令来将你所缓存包清除： 1$ bower cache clean 这样之后你再输入bower cache list就没有内容了；例：1C:\Users\92816\Desktop\testprogramming&gt;bower cache list]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Bower</tag>
        <tag>包管理工具</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6编码风格及规范]]></title>
    <url>%2F2016%2F05%2F03%2F160503ES6%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%8F%8A%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编程风格ES6的新特性足以让每一个前端开发者感到欣喜，也看到了Javascript构建大型应用的潜力，下面这些新的编码风格绝对值得好好去研究学习并运用到项目当中，与传统的JavaScript语法结合在一起，去体会ES6的魅力。 块级作用域（1）let取代var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 123456789'use strict';if (true) &#123; let x = 'hello';&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了一个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。 123456'use strict';if(true) &#123; console.log(x); // ReferenceError let x = 'hello';&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 （2）全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。 12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 （3）严格模式 V8引擎只在严格模式之下，支持let。结合前两点，这实际上意味着，将来所有的编程都是针对严格模式的。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 1234567891011// badconst a = "foobar";const b = 'foo' + a + 'bar';// acceptableconst c = `foobar`;// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 1234567891011121314151617181920212223var ref = 'some value';// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 使用默认值语法设置函数参数的默认值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map结构注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 1234567// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from 'moduleA'; 使用export取代module.exports。 123456789101112131415161718192021// commonJS的写法var React = require('react');var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from 'react';const Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);export default Breadcrumbs 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 12345// badimport * as myObject './importModule';// goodimport myObject from './importModule'; 如果模块默认输出一个函数，函数名的首字母应该小写。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint的使用ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装ESLint。 1$ npm i -g eslint 然后，安装Airbnb语法规则。 1$ npm i -g eslint-config-airbnb 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。 123&#123; "extends": "eslint-config-airbnb"&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。 12345678var unusued = 'I have no purpose!';function greet() &#123; var message = 'Hello, World!'; alert(message);&#125;greet(); 使用ESLint检查这个文件。 1234567$ eslint index.jsindex.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。 reference: http://www.ruanyifeng.com/blog/]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bower中文文档]]></title>
    <url>%2F2016%2F05%2F03%2F160503Bower%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[前言 原创翻译，有不当的地方欢迎指出。转载请注明出处。谢谢! 一个Web站点由很多的东西组成-框架、类库、资产、以及各种实用的工具，Bower为你将这些所有的东西管理起来。&nbsp;&nbsp;&nbsp;&nbsp;记录这些所有的包以及确保它们是最新的（或者设置为你需要的特殊指定版本）无疑是很棘手的事情，接下来正是Bower来拯救你，让你不再棘手！&nbsp;&nbsp;&nbsp;&nbsp;Bower可以管理起包括HTML、CSS、Javascript、字体甚至是图片这些组件。Bower不会连接和压缩你的代码，也不会做其他与它职责无关的事情，它仅仅帮助你安装你需要的正确版本的包以及这些包的依赖。&nbsp;&nbsp;&nbsp;&nbsp;只要一开始， Bower 工作是通过获取和安装所有的包, 寻找，发现，下载，和保存所有你在寻找的东西。Bower会将这些包记录在一个配置文件（bower.json)当中，你怎么使用这些包取决于你。Bower提供钩子（可以理解为一个依附物）促进你使用这些包作为你的工具，或者用于你的工作流程当中.&nbsp;&nbsp;&nbsp;&nbsp;Bower也算是一个前端优化的利器，如果有多个包依赖一个包-比如jquery，Bower将只会下载一次jquery，这个是一个扁平的依赖图，通过这种扁平的依赖机构能够很大程度的减少页面的负担。 安装Bower&nbsp;&nbsp;&nbsp;&nbsp;Bower是一个命令行工具，通过npm安装，注意一定要记得加上-g，以确保是全局安装1npm install -g bower Bower需要依赖于node、npm和git。 npm一般在安装node的时候就自行安装上了，node以及git的安装可以直接在其官网安装即可,没有什么特殊要注意的 想了解不同平台上安装的问题，请阅读troubleshooting 快速开始 包的安装 &nbsp;&nbsp;&nbsp;&nbsp;通过命令 bower install安装软件包，默认会安装到 bower_components/目录.代码如下1bower install &lt; package&gt; 想要下载的包可以是GitHub上的短链接（如jquery/jquery）、 .git 、 一个URL或者其它.这一点的灵活性也使Bower更加的方便了， 了解更多： bower install。12345678910# 通过 bower.json 文件安装 bower install# 通过在github上注册的包名安装 bower install jquery# GitHub短链接 bower install desandro/masonry# Github上的 .git bower install git://github.com/user/package.git# URL bower install http://example.com/script.js 搜索包 &nbsp;&nbsp;&nbsp;&nbsp;可以在这里为你喜爱的项目搜索然后发现注册的包的名字 保存加载的包 &nbsp;&nbsp;&nbsp;&nbsp;可以通过bower init命令新建一个bower.json文件。会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置，例如：如果想保存依赖信息(dependencies)到你的bower.json文件，可以使用：bower install PACKAGE --save,这一点是很关键的一步，有了这个依赖信息，如果后续你想分享你的项目给你的同事，你就不需要将你的所有依赖项的实体包都发过去，因为你的bower.json当中已经有你的依赖项，当执行bower install之后，就会自行将所需要的依赖项下载下来,这样无疑是很省心的，也体现了bower在这一点上起到的作用。 使用下载的包 &nbsp;&nbsp;&nbsp;&nbsp;怎么使用这些包取决于你，我们建议你将Bower与Grunt, RequireJS, Yeoman以及其它工具一起使用，对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如： 对于上面的每行代码前，没有带$，那个是mac和linux会默认自己带上的]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Bower</tag>
        <tag>包管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内解决npm被墙的三种方式]]></title>
    <url>%2F2016%2F05%2F02%2F160502%E5%9B%BD%E5%86%85%E8%A7%A3%E5%86%B3npm%E8%A2%AB%E5%A2%99%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一种方式：通过指定镜像源地址来下载包&nbsp;&nbsp;&nbsp;&nbsp;这个使用的是淘宝的NPM镜像，这是一个完整 npmjs.org镜像，同步频率目前为 10分钟一次以保证尽量与官方服务同步，这里也不得不说淘宝的这个镜像真是对我们开发者的一个福音，代码如下1npm install 包名 --registry=https://registry.npm.taobao.org 第二种方式：通过 淘宝提供的一个 cnpm 全局命令行工具&nbsp;&nbsp;&nbsp;&nbsp;这种方式的好处就是省去了后面的registry的一串长长的地址。 安装全局命令行工具， 注意要加上-g，以确保是全局安装，这样才能够直接在命令行使用cnpm 1npm install -g cnpm 使用时直接按如下操作即可，但是这一点唯一不足的就是操作的时候需要用cnpm，而不是npm，对于处女座的人可以采用第三种方式 1cnpm install 包名 第三种方式：通过一个全局命令行工具 nrm 来管理我们的镜像源地址 安装nrm 注意要加上-g，以确保是全局安装，这样才能够直接在命令行使用nrm 1npm install -g nrm 基本使用 首先可以先显示当前所有可用镜像源1nrm ls 显示当前正在使用的镜像源1nrm current 初始默认是官方npm 切换镜像源1nrm use 镜像源名称 这时显示registry已经切换为taobao了， 接下来再确认一下当前正在使用的镜像源1nrm current 已经变为taobao了，以后再安装包的时候直接npm install 包名即可，再也不用担心被墙的苦恼了,大功告成！]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象之原型链]]></title>
    <url>%2F2016%2F04%2F16%2F160416%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型链的认识 既然提到原型链，就需要和构造函数联系起来进行理解; 构造函数的认识&nbsp;&nbsp;&nbsp;&nbsp;其实构造函数时函数调用的一种模式，例如创建了一个函数，然后通过一个变量new了这个函数，那么这个函数就可以成为构造函数，可以从作用上来理解它为什么叫构造函数，直白点可以说是来构造一个对象出来的，实际上是实例化了一个对象出来，任何通过new来进行操作的函数都可以成为构造函数。&nbsp;&nbsp;&nbsp;&nbsp;接下来那么这个被new出来的对象就会继承创建出来的那个函数的属性，前提是在构造函数内部通过this.属性名这样的属性new出来的实例对象才能拥有。 引出原型链的认识&nbsp;&nbsp;&nbsp;&nbsp;当new出的这个实例对象需要访问某个属性时，首先它会在其本身查找，也可以理解为是先看其构造函数内部有没有通过this.属性名初始化这个属性，如果没有找到这个属性，也就是没有从本身找到这个属性，那么它就会往上查找，这个查找过程中查的那条链就叫做原型链，具体了解可以看引申出来属性搜索原则，下面有总结，其实这也和原型继承这个机制是联系在一起的，可以说设计这个原型链就是为原型继承服务的； 构造函数的整个过程： 1、new申请内存，创建对象，（new运算符可以称作新建运算符）； 2、调用构造函数，构造函数有一个隐式参数，即this； 3、刚创建出来的对象的引用赋值给this，由函数处理；（其实主要就是利用new能够动态改变this的指向） 4、在构造函数中利用this.成员 = 值来给对象添加成员 构造函数的优势： ①、对象就有独立的原型对象； ②、也具有类型名了 属性搜索原则 ①、在当前对象中找； ②、在构造函数定义规则中找； ③、在其原型对象中找； ④、在其原型对象的原型对象中找…….直到Object.prototype,这等于就是在其原型链上寻找 ⑤、如果没有则返回undefined; 稍微深入的理解下原型其实对象中有一个属性 叫 proto通过调试可以发现 对象的 proto 与创建（实例化）它的构造函数的 prototype 是一个东西看下面的代码测试： 123456function F() &#123; //声明一个构造函数&#125;var o = new F(); //通过这个构造函数实例化一个对象oconsole.log( o.__proto__ === F.prototype ); //true 注意一下 proto 是非标准属性，这里也只是辅助理解来运用下，实际工作中不要采用它来进行业务逻辑 原型对象与原型属性F.prototype 是构造函数 F 的原型属性F.prototype 是对象 o 的原型对象 proto与prototype有什么区别_proto_是站在对象的角度讨论其原型对象prototype是站在构造函数的角度讨论其原型属性，或构造函数创建的对象的原型对象也可以理解成所站的位置不同，就会有不同的角色。 上面的这些理论知识还是会有些抽象，抽时间我会把原型链画一下，那样理解起来就清晰了。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2016%2F04%2F01%2F160401%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 非零的负整数：^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([- 0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)- ：^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-- Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符( 包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))]]></content>
      <categories>
        <category>实用小技能</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码]]></title>
    <url>%2F2016%2F03%2F20%2F160320http%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1XX：信息状态码 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） 2XX：成功状态码 200 OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 Created 服务器已经创建了文档，Location头给出了它的URL。 202 Accepted 已经接受请求，但处理尚未完成。 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 3XX：重定向 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器 返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 Temporary Redirect 和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定 向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新） 4XX：客户端错误 400 Bad Request 请求出现语法错误。 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。 405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新） 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新） 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 Request URI Too Long URI太长（HTTP 1.1新）。 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 5XX: 服务器错误 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>http状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个页面从输入URL到页面加载显示完成的详细过程]]></title>
    <url>%2F2016%2F03%2F19%2F160319%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这一道经典的面试题，相信都不陌生，并且它的这个过程其实能够囊括前后端的通信流程，可以将动态网站实现简单的呈现一下，下面也是简要总结一下，具体还需要自己真正将图解HTTP这本书好好看完之后能够认识的更加完善，等到以后再慢慢完善 下面以访问baidu页面来做一个过程分析 输入 URL：http://www.baidu.com DNS 域名解析 计算机无法识别域名，计算机与计算机之间要想进行通信，必须通过ip地址用来定位该计算机所在的位置 在浏览器中，输入的ip地址或者域名，默认给你加了一个80端口号（对方的服务器监听的就是80端口） 158.12.25.652 域名就是为了好记 为了好记，所以我们的万维网提供了 一个 域名这样的概念 当你输入了 ip 地址后，浏览器会自动去 找DNS域名解析服务器， 建立 TCP 连接（Socket）：三次握手,确保这个一定是一个有效的请求和响应，这个三次握手在业界相信大多数人都不陌生，虽然它是提高了传输的有效性，但是这个导致的直接问题就是整个传输过程是很耗时的，也就是说每次http请求都会经历三次握手这个过程，消耗的时间也是不言而喻，并且传统的http协议规定一次请求只能请求一个文件，所以一些顶级网站千方百计的采取一些减少http请求的策略，大多数就是采取一次http请求能够请求多个文件这样的实现，欣喜的是，http2.0已经支持能够一次http能够请求多个文件，这个还是值得期待全部推行开来的，只不过肯定需要过上一段时间，慢慢去等待推行吧。 将用户输入的地址封装成 HTTP Request 请求报文 发送到服务器 浏览器将用户输入的 URL 地址根据HTTP协议 封装成了 http 请求报文（请求头+请求行+请求体） 该报文说白了也就是字符串而已，最终也要被转成了二进制数据再发送到服务器 后台服务器接收到用户HTTP Request 请求报文 后台服务器接收到 客户端发送给自己的数据（二进制数据） 首先把二进制数据按照编码解析成字符，（人类可以识别的） 解析成字符之后，再按照 HTTP 协议规范中定义的格式解析出来 后台服务器处理用户请求信息 当得到用户请求报文之后，根据请求报文中的 get、port或者 URL、或者URL中的查询字符串或者 请求体中的数据 根据用户的特定的请求数据做特定的处理 后台服务器将相应结果封装到 HTTP Response 响应报文中 发送给客户端 当我们解析和处理完用户请求报文消息之后 服务器开始将具体的 要发送给客户端的数据 根据 HTTP 协议规范 封装成 HTTP协议响应报文 响应头、响应字段、响应体 该数据说白了也是具有特定格式的字符串而已，最终这个字符串也要转换成二进制数据发送到客户端 发送到客户端也是通过 Socket（ip地址、端口号） 发送到了该客户单 用户浏览器接收到响应后开始渲染html、css，解析和执行 JavaScript 代码 当客户端解析到 服务器发送过来的 二进制数据 客户端浏览器也会将 二进制数据 根据编码类型解析成 字符串 然后根据 HTTP 协议，解析服务器发送过来的 响应报文 然后根据响应报文中的报文内容（报文头、报文体）做具体的解析 当浏览器在解析的过程中遇到 一些静态资源时，会再次重复上面的步骤]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中栈与队列的实现]]></title>
    <url>%2F2016%2F03%2F15%2F160315%E6%95%B0%E7%BB%84%E4%B8%AD%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。由于数组十分容易懂，所以它被用来作为介绍数据结构的起点非常合适。下面来看一下栈和队列的在数组当中的实现：.pop, .push, .shift和 .unshift 先来看栈的实现每个人都知道.push可以再数组末尾添加元素，但是你知道可以使用[].push(‘a’, ‘b’, ‘c’, ‘d’, ‘z’)一次性添加多个元素吗？ .pop 方法是.push 的反操作，它返回被删除的数组末尾元素。如果数组为空，将返回void 0 即是(undefined),使用.pop和.push可以创建LIFO (last in first out)栈。 (last in first out)栈的特性是后进先出，正向前面的last in first out的翻译push()从尾部添加,返回添加后数组的长度pop()从尾部删除,返回被删除的元素 12345678910111213function Stack () &#123; //声明一个Stack构造函数 this._stack = []; //在其实例对象上动态添加一个_stack = [],方便下面借用其方法，一般`_`表示私有&#125;Stack.prototype.next = function () &#123; //再其原型属性添加一个next方法，其实就是借用了数组的pop方法； return this._stack.pop(); &#125;Stack.prototype.add = function () &#123; //下面的实现其实·就是借用了数组的push方法 return this._stack.push.apply(this._stack, arguments); //这里使用了apply借用上下文模式，主要是想利用它第二个参数是数组的作用，虽然arguments是伪数组，也可以实现让其里面的参数逐个的添加到this._stack中，这种借用上下文调用的小技巧用的地方还是挺多的&#125;stack = new Stack(); //实例化一个栈对象stackstack.add(1,2,3); //从后面依次添加3个元素stack.next(); //弹出最后一个元素，// &lt;- 3 接下来是队列的实现使用.shift和 .unshift即可创建FIFO (first in first out)队列。 (first in first out)栈的特性是先进先出，正向前面的first in first out的翻译unshift()从头部添加,返回添加后数组的长度shift()从头部删除,返回被删除的元素12345678910111213function Queue () &#123; //声明一个Queue构造函数 this._queue = []; //同样在实例对象自定义一个_queue私有属性方便下面借用其方法，一般`_`表示私有&#125;Queue.prototype.next = function () &#123; //再其原型属性添加一个next方法，其实就是借用了数组的shift方法，也就是从前面删除元素 return this._queue.shift();&#125;Queue.prototype.add = function () &#123; //借用其unshift方法，也就是从前面添加元素 return this._queue.unshift.apply(this._queue, arguments);&#125;queue = new Queue();//实例化一个队列对象queue；queue.add(1,2,3); //从前面依次添加三个元素queue.next(); //弹出第一个元素// &lt;- 1 //使用shift或者pop能够很方便的遍历一个数组元素list = [1,2,3,4,5,6,7,8,9,10]while (item = list.shift()) { console.log(item)}list// &lt;- [] //遍历完成 结语&nbsp;&nbsp;&nbsp;&nbsp;栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。栈的使用遍布程序语言实现的方方面面，从表达式求值到处理函数调用；栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。咖啡厅内的一摞盘子是现实世界中常见的栈的例子。只能从最上面取盘子，盘子洗净后，也只能摞在这一摞盘子的最上面。结合前面的比喻，再记住后进先出对队列的理解就差不多了；&nbsp;&nbsp;&nbsp;&nbsp;队列是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出，这点和栈不一样，在栈中，最后入栈的元素反而被优先处理。可以将队列想象成在银行前排队的人群，排在最前面的人第一个办理业务，新来的人只能在后面排队，直到轮到他们为止。队列被用在很多地方，比如提交操作系统执行的一系列进程、打印任务池等，一些仿真系统用队列来模拟银行或杂货店里排队的顾客；结合前面的比喻，再记住先进先出对队列的理解就差不多了；]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>栈与队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS-API之path模块]]></title>
    <url>%2F2016%2F03%2F07%2F160307NodeJS-API%E4%B9%8Bpath%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;这个模块包含处理和转换文件路径的一套工具集，这些方法的大部分主要用于字符串变换。不会调用文件系统去检验路径是否合法。&nbsp;&nbsp;&nbsp;&nbsp;你只需要require(&#39;path&#39;)即可使用这个模块，下面的这些方法是所被提供的： 1.path.basename(p[, ext])&nbsp;&nbsp;&nbsp;&nbsp;返回一个路径中的最后一部分. 与Unix 的 basename 命令很相似。第二个参数是可选项，只能传后缀名，如果未传则是情况一，会得到带后缀名的文件名；如果传了则是情况二，则会得到不带后缀名的文件名，例：12345path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;)// returns &apos;quux.html&apos;path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)// returns &apos;quux&apos; 2.path.delimiter&nbsp;&nbsp;&nbsp;&nbsp;特定平台的路径分隔符, ;或者&#39;:&#39;.*nix上的例子: 12345console.log(process.env.PATH)// &apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&apos;process.env.PATH.split(path.delimiter)// returns [&apos;/usr/bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin&apos;, &apos;/sbin&apos;, &apos;/usr/local/bin&apos;] Windows上的例子: 12345console.log(process.env.PATH)// &apos;C:\Windows\system32;C:\Windows;C:\Program Files\node\&apos;process.env.PATH.split(path.delimiter)// returns [&apos;C:\\Windows\\system32&apos;, &apos;C:\\Windows&apos;, &apos;C:\\Program Files\\node\\&apos;] 3.path.dirname(p)&nbsp;&nbsp;&nbsp;&nbsp;返回一个路径的文件夹名，相当于Unix中的dirname命令。例：12path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)// returns &apos;/foo/bar/baz/asdf&apos; 4.path.extname(p)&nbsp;&nbsp;&nbsp;&nbsp;返回路径中文件的扩展名,在从路径最后一部分中的最后一个’.’到字符串的末尾。如果在路径的最后一部分没有’.’，或者第一个字符是’.’，就返回一个 空字符串。例：1234567891011121314path.extname(&apos;index.html&apos;)// returns &apos;.html&apos;path.extname(&apos;index.coffee.md&apos;)// returns &apos;.md&apos;path.extname(&apos;index.&apos;)// returns &apos;.&apos;path.extname(&apos;index&apos;)// returns &apos;&apos;path.extname(&apos;.index&apos;)// returns &apos;&apos; 5.path.format(pathObject)&nbsp;&nbsp;&nbsp;&nbsp;从一个路径对象中返回一个路径字符串，它刚好跟path.prase相反。&nbsp;&nbsp;&nbsp;&nbsp;如果pathObject有dir和base属性，那么返回的字符串将会是dir属性、所在平台的路径分隔符以及base属性三者链接起来。&nbsp;&nbsp;&nbsp;&nbsp;如果没有提供dir属性，root属性将会被当做dir属性来用。然而，假设当root属性以所依赖的平台分隔符所结束时，在这种情况下，返回的字符串将会是root属性和base属性的链接起来的字符串。&nbsp;&nbsp;&nbsp;&nbsp;如果dir和root属性都没有被提供的话，那么返回的字符串将会是base属性的内容。&nbsp;&nbsp;&nbsp;&nbsp;如果base属性没有被提供，那么base属性将会是name属性和ext（后缀名）属性的结合。下面看几个官方实例就会很清楚了：1234567891011121314151617181920212223242526272829303132333435363738// 当提供dir和base的时候，将会返回 `dir + platform separator + base`path.format(&#123; dir: &apos;/home/user/dir&apos;, base: &apos;file.txt&apos;&#125;);// returns &apos;/home/user/dir/file.txt&apos;// 当dir没有指定的时候root将会被使用，当base没有指定的时候name和ext将会被使用；如果仅仅是root被提供，或者是dir跟root相等，那么这时候就不会包含平台的分隔符了path.format(&#123; root: &apos;/&apos;, base: &apos;file.txt&apos;&#125;);// returns &apos;/file.txt&apos;path.format(&#123; dir: &apos;/&apos;, root: &apos;/&apos;, name: &apos;file&apos;, ext: &apos;.txt&apos;&#125;);// returns &apos;/file.txt&apos;// 如果dir或者root没有提供的时候会直接将base对应的字符串返回path.format(&#123; base: &apos;file.txt&apos;&#125;);// returns &apos;file.txt&apos;Windows当中的例子:path.format(&#123; root : &quot;C:\\&quot;, dir : &quot;C:\\path\\dir&quot;, base : &quot;file.txt&quot;, ext : &quot;.txt&quot;, name : &quot;file&quot;&#125;)// returns &apos;C:\\path\\dir\\file.txt&apos; 6.path.isAbsolute(path)&nbsp;&nbsp;&nbsp;&nbsp;判断path是否是一个绝对路径，绝对路径经常会被用来处理同一个地址，不管是在哪一个目录下。例：1234567891011path.isAbsolute(&apos;/foo/bar&apos;) // truepath.isAbsolute(&apos;/baz/..&apos;) // truepath.isAbsolute(&apos;qux/&apos;) // falsepath.isAbsolute(&apos;.&apos;) // falseWindows 中的例子:path.isAbsolute(&apos;//server&apos;) // truepath.isAbsolute(&apos;C:/foo/..&apos;) // truepath.isAbsolute(&apos;bar\\baz&apos;) // falsepath.isAbsolute(&apos;.&apos;) // false 注意：如果这个路径字符串传一个长度为0的字符串，那么不像其他路径模块函数，它将会被照样输出，并返回一个false。 7.path.join([path1][, path2][, …])&nbsp;&nbsp;&nbsp;&nbsp;连接所有的参数到一起并且格式化这个生成的路径，所以以后只要涉及到拼接路径字符串，就采用它，这样就不易出错了，你多写了/它也会自动帮你处理掉，大大提高容错率。这些参数必须是字符串的格式，在v0.8，不是字符串格式的参数会被默默地忽略掉。在v0.10以及以上，会抛出一个异常。例：123456path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;)// returns &apos;/foo/bar/baz/asdf&apos;path.join(&apos;foo&apos;, &#123;&#125;, &apos;bar&apos;)// throws exceptionTypeError: Arguments to path.join must be strings 注意：如果这个参数添加一个长度为0的字符串，不像其他路径模块函数，它将会被忽略。如果连接的路径字符串是一个长度为0的字符串，接下来会返回一个代表自己当前的工作目录的路径。这个API的一个重要的应用场景，是将相对路径转为绝对路径，通过path.join(__dirname,’相对路径’) =&gt; 就会将这个相对路径转为绝对路径，在某些场景下极为有用。 8.path.normalize(p)&nbsp;&nbsp;&nbsp;&nbsp;规范规范化字符串路径，注意 ‘..’ 和 `’.’ 部分。&nbsp;&nbsp;&nbsp;&nbsp;多个斜杠会被替换成一个；路径末尾的斜杠会被保留； Windows 系统上, 会使用反斜杠。例：12path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)// returns &apos;/foo/bar/baz/asdf&apos; 注意：如果路径字符串中传入了一个长度为0的字符串，那么将会返回当前工作文件目录名。 9. path.parse(pathString)&nbsp;&nbsp;&nbsp;&nbsp;从传入的一个路径字符串中返回一个对象。例如在*nix上：123456789path.parse(&apos;/home/user/dir/file.txt&apos;)// returns// &#123;// root : &quot;/&quot;,// dir : &quot;/home/user/dir&quot;,// base : &quot;file.txt&quot;,// ext : &quot;.txt&quot;,// name : &quot;file&quot;// &#125; 在Windows上： 123456789path.parse(&apos;C:\\path\\dir\\index.html&apos;)// returns// &#123;// root : &quot;C:\\&quot;,// dir : &quot;C:\\path\\dir&quot;,// base : &quot;index.html&quot;,// ext : &quot;.html&quot;,// name : &quot;index&quot;// &#125; 类Unix系统不像Windows系统那样具有好几个盘符 10. path.posix&nbsp;&nbsp;&nbsp;&nbsp;提供上述的路径方法,并且总是以posix兼容的方式进行交互。 POSIX 表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。 11. path.relative(from, to)&nbsp;&nbsp;&nbsp;&nbsp;解决从from到to的相对路径。&nbsp;&nbsp;&nbsp;&nbsp;有时候我们有两个绝对路径，我们需要从中找出相对目录的起源目录。这其实就是path.resolve的相反实现,我们可以看看是什么意思:1path.resolve(from, path.relative(from, to)) == path.resolve(to) 例：12345path.relative(&apos;C:\\orandea\\test\\aaa&apos;, &apos;C:\\orandea\\impl\\bbb&apos;)// returns &apos;..\\..\\impl\\bbb&apos;path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;)// returns &apos;../../impl/bbb&apos; 注意：如果相对路径中有长度为0的字符串，那么当前的工作目录将会被用来代替那个长度为0的字符串。如果两个路径一样，那么将会返回一个长度为0的字符串，其实就是一个空字符串； 12. path.resolve([from …], to)&nbsp;&nbsp;&nbsp;&nbsp;将to解析为一个绝对路径。&nbsp;&nbsp;&nbsp;&nbsp;如果to不是一个相对于from 参数的绝对路径，to会被添加到from的右边，直到找出一个绝对路径为止。如果使用from路径且仍没有找到绝对路径时，使用当时路径作为目录。返回的结果已经规范化，得到的路径会去掉结尾的斜杠，除非得到的当前路径为root目录。非字符串参数将被忽略。&nbsp;&nbsp;&nbsp;&nbsp;其实还有一种便于记忆的方法就是把它看做一系列 cd 命令.1path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;) 相似与：12345cd foo/barcd /tmp/file/cd ..cd a/../subfilepwd 不同的是，有时候不同的路径也是不需要存在的，也可能是文件。例：123456789path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)// returns &apos;/foo/bar/baz&apos;path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)// returns &apos;/tmp/file&apos;path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)// 如果当前在 /home/myself/node, it returns// &apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos; 注意：如果参数中需要解析长度为0的字符串，那么将会返回当前的工作目录来代替它们。 13. path.sep特定操作系统的分隔符。如 ‘\‘ or ‘/‘. 123456789例如在 *nix上:&apos;foo/bar/baz&apos;.split(path.sep)// returns [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]在Windows上:&apos;foo\\bar\\baz&apos;.split(path.sep)// returns [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;] 14. path.win32&nbsp;&nbsp;&nbsp;&nbsp;提供上述的路径方法,但目前是只兼容win32的方式进行交互。]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015-2016前端知识体系]]></title>
    <url>%2F2016%2F03%2F05%2F160305-2015-2016%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[一篇很好的技术栈文章，也是激励自己一定要时刻保持学习的状态！ 一、框架与组件bootstrap等UI框架设计与实现 伸缩布局：grid网格布局 基础UI样式：元素reset、按钮、图片、菜单、表单 组件UI样式：按钮组、字体图标、下拉菜单、输入框组、导航组、面包屑、分页、标签、轮播、弹出框、列表、多媒体、警告 响应式布局：布局、结构、样式、媒体、javascript响应式 第三方插件：插件管理 jQuery、zepto使用原理以及插件开发 支持amd、cmd、全局变量的模块化封装 $.fn.method = function(){} mvc/mvvm框架原理设计，vue/angular/avalon等 directive设计：html、text、class、html、attr、repeat、ref，可扩展 filter设计：bool、upperCase、lowerCase，可扩展 表达式设计：if-else等实现 viewmodel结构设计：例如数据，元素，方法的挂载与作用域 数据更变检测：函数触发，脏数据检测、对象hijacking polymer/angular2思想与设计思路 import技术 template和script引入方式 css样式命名空间隔离 简单复用第三方库 reactjs原理与使用 virtual dom单向数据绑定 js执行语法方式 UI由状态控制 commonJS/AMD/CMD 模块引入 模块定义 模块标识 UMD解决不同规范兼容性的问题，例如webpack封装 模块懒执行(CMD)与与预执行(AMD) loadJs模块化加载原理与实现 创建script标签，需要id映射到资源url onload加载模块队列判断 全部加载完成后触发 加载失败问题优化 requirejs、modjs、seajs polyfill、shim原理与实现 polyfill提供了开发者们希望浏览器原生提供支持的功能特性 shim将新的API引入到旧的环境中,且仅靠旧环境中已有的手段实现 virtual Dom、Incremental DOM 1.用js对象树表示dom树结构，根据该对象树构建dom树 2.状态改变时，重新构建对象，和旧的对象对比，记录两个对象树差异 3.将对象树差异应用到dom中 小结:js对象模拟dom(elem.js)，virtual dom diff算法(diff.js)、差异渲染dom(patch.js) incremental dom在状态改变时扫描旧对象树将差异直接应用到dom中 shadow dom 隔离外部环境用于封装组件：结构、样式、行为 实现形式：新标签、class类属性 + 构建编译 webwork与service Worker webwork与主线程机制，on/post serviceworker可作为浏览器请求代理 应用场景 ES6转ES5、Babel与ES6开发规范体系 ES6编码规范全 ES6在babel下兼容性 ES6在node下兼容性与性能 ES6新特性：看编码规范 aurelia ES6前端框架 Isomorphic JavaScript 同构原理 同构方案 Rendr nodejs: 服务器 hapi: 应用服务 backbone.js: 后台mvc requirejs: 模块加载 jquery: dom处理 reactjs同构:React + Flux + Koa 双向数据绑定 函数触发:vuejs 脏数据检测:angular 对象hijacking:avalon browserify运行原理 1.从入口模块开始分析require函数调用 2.根据依赖生成AST 3.根据AST找到每个模块的模块名 4.得到每个模块的依赖关系，生成一个依赖字典 5.包装每个模块（传入依赖字典以及export和require函数），生成执行的js performance timing performance timing api performance timing 过程 performance timing 性能计算 performanceTrace库 组件UI与js组件规范化 组件编码规范 组件目录规范：组件目录与公用目录 组件构建规范：构建环境支持 组件模块化管理：spm，bowserify 组件复用性管理 第三方组件接入成本 immutable JavaScriptgenerator与promise原理与使用二、构建生态grunt/gulp开发环境任务编写 文件处理插件：html、scss、js、image、font、其它 优化插件：雪碧图、图片压缩、iconfont构建 发布替换插件 打包、压缩包插件：组件自动分析 白名单配置 自定义插件编写 npm、jspm、bower包管理工具r.js、browserify、webpack、Rollup打包工具使用 原理：根据依赖配置文件对文件进行依赖打包 webpack支持更多的规范打包，AMD,Commonjs webpack+babel/reactjs+reflux fis3构建与插件开发、构建环境、fis3构建离线包web Component：rosetta-org、x-view、Q、riot、novabrunch构建工具三、开发技巧与调试fiddler加willow基础组合调试 常见配置与分析 结合浏览器调试 werien、vorlonjs远程调试，chrome inspectmockjs，F.M.S(Front Mock Server)模拟调试使用与cgi自动调试macha/phantomjs/casperjs/karma测试自动化任务使用自动化UI测试，海豚node-supervior、node-inspector、karma开发发布系统流程sublime高效插件 emmet工具使用、 sublimelinter、 babel snippets、 sublimeLint、 SassBeautify 、 emmet 快速编辑、 jsxlint、 SideBarEnhancements、 SnippetsMaker、 SublimeCodeIntel、 css snippets、 ColorPicker、 html/css/js Pretty、 SpinnetMacker、 DocBlockr、 MultiEditUtils、 javascript &amp; node spinnet、 JavaScript &amp; NodeJS Snippets、 jsLint、cssLint 代码自动化检查fecs四、html、css与重构jpeg、webp、apng、bpg图片 编码原理 特点与优劣势 适用场景 iconfont使用与实现原理 自动打包构建方法 iconfont兼容性写法 fonthello、fontawesome、icomoon.io、iconfont.cn线上工具 页面响应式设计 layout布局响应式 html结构响应式 css样式响应式 image媒体响应式 javascript响应式 media query与平台判断 css重置 reset nomalize neat sass/compass/less/postcss常用语法与使用 常用语法功能 组件化UI设计管理 构建工具实现方案 雪碧图自动合成 iconfont自动接入等等 media query与常见页面尺寸了解 媒体类型引入和媒体特性引入 device-width适应 retina屏幕适应 em,rem原理与实现 rem计算：width*retina/10，相当于屏幕宽度为10rem 字体在rem情况下仍然使用px code4ui、code4app、初页、maka等 前端dom操作即使刷新前端页面 根据dom操作生成组件config配置保存到db 根据config配置使用r.js或webpack打包 发布打包后输出文件 css3动画 transform animation transiction 3D加速与动画加速 动画库 缓动函数速查表： http://www.xuanfengge.com/easeing/easeing/ Ceaser： http://xuanfengge.com/easeing/ceaser/ cubic-bezier：http://cubic-bezier.com/ css网格布局 susy Responsive Grid System Fluid 960 Grid(adaptjs) Simple Grid 搜索引擎与前端SEO tdk优化 页面内容优化 唯一的H1标题 img设置alt属性 nofollow url优化 统一链接 301跳转 canonical robot优化 robots.txt meta robots sitemap SEO工具 各种站长工具等 浏览器缓存种类，resources,webSQL,indexDB, localstorage,cookie,app cache,cache storage store.js、cookie.js UI框架 bootstrap、jqwidgets、semantic ui、amaze ui 微信手Q ui: frozenui、weui、blend ui extjs、echart图表ui 五、native/hybrid/桌面开发ionic移动开发方案 运行架构 hybrid混合开发 cordova交互 离线包更新 性能瓶颈 nativescript移动开发方案react Native移动开发方案 运行架构：js引擎 性能缺陷与内存泄露 更新机制 使用场景 android/ios原生开发与框架 java oc、swift web与native交互 屏幕旋转 摇一摇 录像，拍照，选取本地图片 打电话，发短信 电池电量 地理位置 日期选择 开启硬件加速 桌面应用开发 nodewebkit atom-shell(后改名为electron) 网易Hex pomelo(游戏服务器框架) react desktop appjs:appjs.com 六、前端/H5优化(另一个图已给出)yslow、pagespeed移动web性能优化 手机浏览器”省流量”原理 增量更新原理及注意事项 本地存储的应用 加载优化 图片优化 单页面及路由实现 业内著名站点案例分析 七、全栈/全端开发express/node club + mongodb、thinkjs等框架node.js直出实时web开发，meteor/express.ioMEAN(mongodb/express/angular/nodejs)http与http2协议、bigpipe、pipeline离线缓存，cookie、localstorage、indexdbcdn与dns 动态域名加速 cdn原理与cdn combo 八、研究实验WebAssembly、webTRC、typescriptMaterial design规范的前端框架 交互动效库 AMP-HTML规范 使用受限HTML以及缓存技术来提高移动网络中静态内容的性能 添加自定义的元素代替禁用掉的元素：amp-audio, amp-img、amp-video等 九、数据分析与监控badjs数据上报 捕获错误两种方法：onerror、try-catch。抽样上报，先onerror统计语法错误，如果是script error，再使用tryjs。 后台统计方法、不同业务接入体系、抽样统计 onerror:可以捕捉语法错误和运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；当前页面执行的js脚本出错都会捕捉到；跨域的资源需要特殊头部支持。 try-catch:无法捕捉语法错误，只能捕捉运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；需要借助工具把function块以及文件块加入try,catch，可以在这个阶段打入更多的静态信息。 点击热力图clickHeat、heatMapjs加载失败优化方案 失败重发机制 加载源域名服务器文件 https反劫持 百度alog数据上报十、其它软技能axure 原型图设计xmind脑图管理效率管理can i use、github知识管理/总结分享产品思维与技能十一、前端技术网站技术社区 w3c tech、w3c plus、w3 help div.io、nodeParty 稀土掘金、前端早读课 alloyteam、html5基地 W3 help 行业会议 segmentfault会议 深js、杭js GMIC(全球移动互联网大会) D2、webrebuild infoQ内容、Qcon、velocity reference: http://ouvens.github.io/frontend-resource/2016/01/26/front-end-learning-list.html]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS入门系列一之先从Javascript说起]]></title>
    <url>%2F2016%2F02%2F28%2F160228NodeJS%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80%2F</url>
    <content type="text"><![CDATA[什么是JavaScript Javascript是一种动态类型、弱类型、基于原型的语言。 Javascript是一种脚本语言 脚本语言是不需要提前编译的语言 是在运行时动态的编译和解析执行的，所以也叫做动态语言 还有一种语言叫作：静态语言（静态语言是需要经过编译之后才能执行），这也是它们两者的区别 Javascript运行在浏览器（这里暂时这样写，后面介绍了NodeJS后就知道Javascript不仅仅能运行在浏览器上 暂时可以说Javascript是一种运行在浏览器中的脚本语言 JavaScript 的运行环境 对于初学者可能想当然说是浏览器 其实理论意义上，JavaScript是运行在浏览器中的Javascript解析引擎中，这也是后面NodeJS可以运行Javascript的原因，下面再进行详细介绍 浏览器中的 JavaScript 可以做什么 从 JavaScript 语言角度来说：其实是ECMAScript 规定了 JavaScript 脚本的核心语法，如 数据类型、关键字、保留字、运算符、对象和语句等，它不属于任何浏览器。 ECMAScript 3（当前使用较多的其实还在这个层面，因为涉及到兼容性的问题） ECMAScript 5（现在用户也逐步在慢慢增多） ECMAScript 6（2015年发布，添加了很多更加方便的规范，使Jascript更加强大了） DOM操作 DOM 是“ Document Object Model ”的缩写，简称“ 文件对象模型 ”，由W3C制定规范 DOM 定义了 JavaScript 操作 HTML 文档的接口，提供了访问 HTML 文档（如body、form、div、textarea等）的途径以及操作方法，浏览器载入 HTML 文档后，将整个文档规划成由节点构成的节点树，文档中每个部分都是一个节点 这也是Javascript使用最为广泛的，通过DOM操作能够让浏览器渲染出各种炫酷的界面，并能完成很多业务逻辑 BOM操作 BOM 是”Browser Object Model“的缩写，简称“浏览器对象模型” BOM 定义了 JavaScript 操作浏览器的接口，提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法，其实这些接口都是通过中间层通过硬件层面开放给程序员的接口，也是得益于这些接口我们可以高效的进行开发 遗憾的是，BOM 只是 ECMAScript 的一个扩展，没有任何相关标准，W3C也没有对该部分作出规范，每个浏览器厂商都有自己的 BOM 实现，这可以说是 BOM 的软肋所在，也是令很多程序要感到很烦恼的一个地方–兼容性； AJAX AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术 通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新 说到这里，也算是AJAX拯救了Javascript，因为在2005年之前Javscript经常被认为是一个很低级的脚本语言，最重要的是很多开发者都用它开发了一些烦人的广告之类的，最终导致Javascript在好几个主流浏览器上都经常被禁用，相信现在有些开发者也知道每个浏览器都有一个禁用Javascript的选项，不过这时的我们并不是真的禁用它，最多是处于调试的目的，但那时候可是真的禁用，好了，野史就先说到这….2005年对于AJAX可以说是一个重要的元年，很多重大的事件让大众对它真的是刮目相看，Google在它著名的交互应用程序中使用了异步通讯，如Google、Google地图、Google搜索等。而AJAX又是基于Javascript，所以就此Javascript又重新发展了起来。 事件驱动编程 Javascript中的事件驱动是通过鼠标或热键的动作引发的，比如我们常见的onclick（点击）、onchange（内容改变）、onFocus（获得焦点）、onblur(失去焦点)、onload（文档加载完毕）、onselect(当text或textarea的内容被高亮显示后触发该事件)….还有很多事件在这里就不一一赘述了，大家只需要先知道是这样一个事件驱动原理，使我们能够实现很多交互，因为我们可以知道，每一个用户的行为很多时候是很难预测的，所以计算机不可能提前都预制好要去做些什么。计算机内部是只能识别二进制的，也就是我们所有的操作最终都会以二进制（0101）的形式返回给计算机，然后计算机再去根据指令去执行。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu了 浏览器中的 JavaScript 不可以做什么 相对于 传统的 c、Java、c#、c++ 等等这些语言来说 文件操作 注意：JavaScript 本身不是不可以操作文件 为了 安全性 客户端的 JavaScript 可以向服务器发送请求，但是不能接收请求 那在开发人员能力相同的情况下编程语言的能力取决于什么 最重要的区别 取决于 你的 执行环境 对比一些后台语言：Java、PHP、C#、C++ 运行环境不一样 编程语言的能力 真正 取决于 这个语言在哪儿运行（运行环境） JavaScript 只可以运行在浏览器中吗 这里就可以引申出上面的问题了，Javascript不仅仅只能运行在浏览器上，其实决定Javascript的关键也是它的运行环境，比如chrome中的V8引擎、Firefox中的SpideMonkey、IE的JScript、Safari的JavaScriptCore、MicrosoftEdge的 ChakraCore 上面这些其实都是引擎，大家可以想象一下显示生活中的引擎，比如汽车中的发动机，也可以说是汽车的引擎，相信知道汽车的人知道发动机其实是可以更换的，也就是可移植，而这一点也是引擎最重要的特性； 而NodeJS作者正是通过移植了chrome的V8引擎，使javascript可以跨平台运行了，也算是开创了Javascript的一个新纪元，让Javascript又提升了一个新的高度,接下来我们也就要进入神奇的Node世界了。]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生数组方法]]></title>
    <url>%2F2016%2F02%2F15%2F160215%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Mutator 方法即下面的这些方法会改变调用它们的对象自身的值： Array.prototype.copyWithin() ES6在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。 Array.prototype.fill() ES6将数组中指定区间的所有元素的值，都替换成某个固定的值。 Array.prototype.pop()删除数组的最后一个元素，并返回这个元素。 Array.prototype.push()在数组的末尾增加一个或多个元素，并返回数组的新长度。 Array.prototype.reverse()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 Array.prototype.shift()删除数组的第一个元素，并返回这个元素。 Array.prototype.sort()对数组元素进行排序，并返回当前数组。 Array.prototype.splice()在任意的位置给数组添加或删除任意个元素。 Array.prototype.unshift()在数组的开头增加一个或多个元素，并返回数组的新长度。 Accessor 方法下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 Array.prototype.concat()返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 Array.prototype.includes() ES6判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。 Array.prototype.join()连接所有数组元素组成一个字符串。 Array.prototype.slice()抽取当前数组中的一段元素组合成一个新数组。 Array.prototype.toSource()返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。 Array.prototype.toString()返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。 Array.prototype.toLocaleString()返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。 Array.prototype.indexOf()返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Array.prototype.lastIndexOf()返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Iteration 方法在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在回调函数执行之前，数组的长度会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 Array.prototype.forEach()为数组中的每个元素执行一次回调函数。 Array.prototype.entries() ES6返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。 Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 Array.prototype.find() ES6找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 Array.prototype.findIndex() ES6找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 Array.prototype.keys() ES6返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。 Array.prototype.map()返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.reduceRight()从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.values() ES6返回一个数组迭代器对象，该迭代器会包含所有数组元素的值。 Array.prototype@@iterator ES6和上面的 values() 方法是同一个函数。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在本地模拟一个git远程仓储]]></title>
    <url>%2F2016%2F02%2F10%2F160210%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AAgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%82%A8%2F</url>
    <content type="text"><![CDATA[在本地搭建一个仓储来模拟git的远程仓储，主要是帮助理解一下git作为一个版本控制器的实现过程 创建一个本地共享仓库首先我们要知道一下git要求共享仓库是一个以.git结尾的目录。所以我们第一步先新建一个这样的目录 12345678992816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ mkdir repo.git # 创建以.git结尾目录92816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ cd repo.git # 进入这个目录92816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/repo.git$ git init --bare # 初始化一个共享仓库，也叫裸仓库 注意选项--bareInitialized empty Git repository in C:/Users/92816/Desktop/在本地模拟远程仓储/repo.git/ 这样就建好了一个共享的仓库，但这时这个仓库是一个空的仓库;其实在远端的也是这个原理，比如我们在github上初始化了一个仓库，也相当于这里的repo.git,这样接下来就可以把它当成一个远端来进行了 创建一个本地的测试仓库1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/repo.git (BARE:master)$ cd ../ 创建一个test1测试目录1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ mkdir test1 创建一个test1测试目录1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ cd ./test1/ 创建一个demo01.js文件，touch是bash操作命令,可以创建一个文件1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1$ touch demo01.js 通过vi编辑器简单编辑了一下，当然你也可以拿一个现成的文件1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1$ vi demo01.js 通过cat查看文件里的内容12392816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1$ cat demo01.js 这是第一次创建的demo # 这是demo01.js里的内容 将test1这个测试目录初始化一下，以便进行git相关操作12392816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1$ git initInitialized empty Git repository in C:/Users/92816/Desktop/在本地模拟远程仓储/test1/.git/ 将test1中的文件提交到缓存区123492816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1 (master)$ git add .warning: LF will be replaced by CRLF in demo01.js.The file will have its original line endings in your working directory. 提交一下描述信息123456792816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1 (master)$ git commit -m &quot;test&quot;[master (root-commit) 891fe92] testwarning: LF will be replaced by CRLF in demo01.js.The file will have its original line endings in your working directory. 1 file changed, 1 insertion(+) create mode 100644 demo01.js 推送到本地模拟的共享仓库 repo. git的master分支当中1234567892816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1 (master)$ git push ../repo.git/ masterCounting objects: 3, done.Writing objects: 100% (3/3), 234 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To ../repo.git/ * [new branch] master -&gt; mastergit push ../repo.git master 回退到上一级1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1 (master)$ cd ../ 将repo. git 克隆到test2当中，因为目录当中没有test2这个目录，会直接新建一个test2目录123492816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ git clone ./repo.git/ test2Cloning into &apos;test2&apos;...done. 进入到test2目录当中1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ cd ./test2 通过ls命令列出test2目录，可以看出里面已经有d emo01.js这个文件了，也就是已经复制过来了12392816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ lsdemo01.js 通过vi编辑器打开 demo01.js文件，进行了一下修改，添加了“在test2中进行了内容修改”这样一段话123456792816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ vi demo01.js92816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ cat demo01.js这是第一次创建的demo在test2中进行了内容修改 可以通过git status来查看一下当前的文件状态123456789101192816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: demo01.js # 提示文件已经更改了no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 将更改的demo01. js文件添加到缓存区1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ git add demo01.js 提交一下描述信息123492816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ git commit -m &quot;test&quot;[master 205e461] test 1 file changed, 1 insertion(+) 将其推送到 repo. git的master分支当中12345678992816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test2 (master)$ git push ../repo.git/ masterCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 295 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To ../repo.git/ 891fe92..205e461 master -&gt; master 进入到test1目录1292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储$ cd ./test1 从共享仓库中将内容拉回来12345678910111292816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1 (master)$ git pull ../repo.git/ masterremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From ../repo * branch master -&gt; FETCH_HEADUpdating 891fe92..205e461Fast-forward demo01.js | 1 + 1 file changed, 1 insertion(+) 再次查看现在的demo01. js，你会发现在test2中修改的内容已经在test1中了123492816@MrLiu MINGW64 ~/Desktop/在本地模拟远程仓储/test1 (master)$ cat demo01.js这是第一次创建的demo在test2中进行了内容修改 结语&nbsp;&nbsp;&nbsp;&nbsp;这样就实现了test2中的修改能够在test1中体现出来了，也就是达到了同步的效用，其实在项目当中，这里模拟的共享仓库就是服务器上部署的仓库，步骤也都差不多，就是不管你哪一个人在自己的本地仓库中进行的修改，你通过git add .或者文件名现将其到缓存区，然后在git commit -m 描述信息，然后再git push ../repo.git/ master就能推送到远端了，这样另一个同事只需要git pull ../repo.git/ master就可以将这个共享仓库中改变的部分拉下来，实现同步功能,总归来说，一般我们用的远端仓储只不过是放在服务器上，可以从外网访问而已。 注意点：我们如果想要利用git进行版本控制，就一定注意需要将现有项目初始化为一个仓库，也就是通过git init或者将一个已有的使用git进行版本控制的仓库克隆到本地git clone 仓库地址，其实这个也不难理解，只有这样git才能知道它要操作的文件，以后就直接可以使用git的相关命令了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs监控工具-nodemon]]></title>
    <url>%2F2016%2F01%2F28%2F160128NodeJs%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-nodemon%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;相信大家在开发Node.js应用的的时候，都遇到了一个挺让人烦恼的事情，就是每次即使只是小小的修改了一下子代码，那么也得再重新Crtl+c退出来重启，不像在开发php，java等web项目的时候，修改了项目代码，服务器都会自动重启，让我们的改动生效，好在有大神开发了自动重启的工具——nodemon！推荐给大家 简介&nbsp;&nbsp;&nbsp;&nbsp;Nodemon 是一款非常实用的工具，用来监控你 node.js 源代码的任何变化和自动重启你的服务器。 Nodemon 是一款完美的开发工具，可以使用 npm 安装。 安装也是非常简单，只需下面一步即可1npm install -g nodemon 使用1nodemon 文件名.js 例：123456C:\Users\92816\Desktop&gt;nodemon 04_staticServer.js[nodemon] 1.9.2[nodemon] to restart at any time, enter `rs`[nodemon] watching: *.*[nodemon] starting `node 04_staticServer.js`server is runnig at port 3000 如果想获得帮助信息，只需nodemon -h12345678910111213141516171819202122232425262728293031323334353637383940C:\Users\92816\Desktop&gt;nodemon -h Usage: nodemon [options] [script.js] [args] Options: -e, --ext ................ extensions to look for, ie. js,jade,hbs. -x, --exec app ........... execute script with &quot;app&quot;, ie. -x &quot;python -v&quot;. -w, --watch dir........... watch directory &quot;dir&quot; or files. use once for each directory or file to watch. -i, --ignore ............. ignore specific files or directories. -q, --quiet .............. minimise nodemon messages to start/stop only. -V, --verbose ............ show detail on what is causing restarts. -I, --no-stdin ........... don&apos;t try to read from stdin. -C, --on-change-only ..... execute script on change only, not startup --no-colors .............. disable color output -d, --delay n ............ debounce restart for &quot;n&quot; seconds. --exitcrash .............. exit on crash, allows use of nodemon with daemon tools like forever.js. -v, --version ............ current nodemon version. -h, --help ............... you&apos;re looking at it. --help &lt;topic&gt; ........... help on a specific feature. Try &quot;--help topics&quot;. -- &lt;your args&gt; ........... to tell nodemon stop slurping arguments. Note: if the script is omitted, nodemon will try to read &quot;main&quot; from package.json and without a nodemon.json, nodemon will monitor .js, .coffee, and .litcoffee by default. To learn more about nodemon.json config: nodemon --help config See also the sample: https://github.com/remy/nodemon/wiki/Sample-nodemon.json Examples: $ nodemon server.js $ nodemon -w ../foo server.js apparg1 apparg2 $ PORT=8000 nodemon --debug-brk server.js $ nodemon --exec python app.py $ nodemon --exec &quot;make build&quot; -e &quot;styl hbs&quot; $ nodemon app.js -- -v For more details see http://github.com/remy/nodemon/ 结语&nbsp;&nbsp;&nbsp;&nbsp;有了这个自动监控重启无疑会提高自己的开发效率,让我们更方便的programming，如果想了解更多，可以访问其官网;]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装nvm来管理Node]]></title>
    <url>%2F2016%2F01%2F20%2F160120CentOS%E5%AE%89%E8%A3%85nvm%E6%9D%A5%E7%AE%A1%E7%90%86Node%2F</url>
    <content type="text"><![CDATA[NVM（Node version manager）顾名思义，就是Node.js的版本管理软件，可以轻松的在Node.js各个版本间切换，项目源码在GitHub；如果你想长期做 node 开发, 或者想快速更新 node 版本, 或者想快速切换 node 版本,那么在非 Windows(如 osx, linux) 环境下, 请使用 nvm 来安装你的 node 开发环境, 保持系统的干净.如果你使用 Windows 做开发, 那么你可以使用 nvmw 来替代 nvm. 获取nvm源码1、直接从 github 找到最新版本通过wget下载到本地wget https://github.com/cnpm/nvm/archive/v0.23.0.tar.gz;2、或者直接克隆到本地通过git clone https://github.com/cnpm/nvm.git; 安装nvm1、安装nvm非常简单，只要解压后进入目录然后执行./install.sh然后source ~/.bash_profile。2、也可以手动配置终端启动时自动执行 source /opt/wget/nvm-0.23.0/nvm.sh,在 ~/.bashrc`, ~/.bash_profile, ~/.profile, 或者 ~/.zshrc 文件添加命令: 重新打开你的终端, 输入nvm`。 通过nvm安装管理nodejs1、列出所有可安装的版本nvm list-remote;2、安装相应的版本使用nvm install v4.6.0；还可以直接安装 iojs 各个版本;3、查看一下你当前已经安装的版本:nvm ls;4、切换版本；nvm use v4.6.0;5、设置默认版本 nvm alias default v4.6.0;注意：具体操作很简单，使用帮助通过nvm help;]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>NodeJS</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Browsersync-省时的浏览器同步测试工具]]></title>
    <url>%2F2016%2F01%2F10%2F160110Browsersync-%E7%9C%81%E6%97%B6%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%AD%A5%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[基本使用1. 安装 Node.jsBrowserSync是基于Node.js的, 是一个Node模块， 如果您想要快速使用它，需要先安装一下Node.js安装适用于Mac OS，Windows和Linux。 2. 安装 BrowserSync您可以选择从Node.js的包管理（NPM）库中 安装BrowserSync。打开一个终端窗口，运行以下命令： npm install -g browser-sync上面的是在全局下安装它们，这样你就可以在所有项目(任何目录)中使用。 当然您也可以结合gulpjs或gruntjs构建工具来使用，在您需要构建的项目里运行下面的命令: npm install –save-dev browser-sync 3. 启动 BrowserSync一个基本用途是，如果您只希望在对某个css文件进行修改后会同步到浏览器里。那么您只需要运行命令行工具，进入到该项目（目录）下，并运行相应的命令： 静态网站 如果您想要监听.css文件, 您需要使用服务器模式。 BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站。 12345678// --files 路径是相对于运行该命令的项目（目录）browser-sync start --server --files &quot;css/*.css&quot;如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件// --files 路径是相对于运行该命令的项目（目录）browser-sync start --server --files &quot;css/*.css, *.html&quot;// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。browser-sync start --server --files &quot;**/*.css, **/*.html&quot; 不能是中文路径。打开您的命令行工具，进入到BrowsersyncExample目录下，运行以下其中一条命令。Browsersync将创建一个本地服务器并自动打开你的浏览器后访问http://localhost:3000地址，这一切都会在命令行工具里显示。 1234// 监听css文件browser-sync start --server --files &quot;css/*.css&quot;// 监听css和html文件browser-sync start --server --files &quot;css/*.css, *.html&quot; 动态网站 如果您已经有其他本地服务器环境PHP或类似的，您需要使用代理模式。 BrowserSync将通过代理URL(localhost:3000)来查看您的网站。 12// 主机名可以是ip或域名browser-sync start --proxy &quot;主机名&quot; &quot;css/*.css&quot; 在本地创建了一个PHP服务器环境，并通过绑定Browsersync.cn来访问本地服务器，使用以下命令方式，Browsersync将提供一个新的地址localhost:3000来访问Browsersync.cn，并监听其css目录下的所有css文件。 1browser-sync start --proxy &quot;Browsersync.cn&quot; &quot;css/*.css&quot; API你可以用它来创建简单的开发任务或与其他工具配合使用完成复杂的任务。你要使用它， 只需要 require Browsersync 模块，就像使用其他模块那样。以下是常用方法的详细说明： 在 2.0.0 版本之前直接引用Browsersync模块后即可使用：12345678// 引用 browserSync 模块var browserSync = require(&quot;browser-sync&quot;);// 启动服务器browserSync(&#123;server: &quot;./app&quot;&#125;);// 调用reload方法browserSync.reload(&quot;core.css&quot;); 在2.0.0+版本（推荐）虽然上述方式依然支持，但现在我们推荐以下方式代替。调用 .create() 意味着你得到一个唯一的实例并允许您创建多个服务器或代理。 1234567891011// require 加载 browser-sync 模块var bs = require(&quot;browser-sync&quot;).create();// .init 启动服务器bs.init(&#123; server: &quot;./app&quot;&#125;);// 主Browsersync模块出口bs.reload(&quot;*.html&quot;);.create( name ) .create( name )创建Browsersync实例 nameType: String可稍后用于检索的标识符12345678910// 创建一个未命名的实例var bs = require(&quot;browser-sync&quot;).create();// 创建一个命名实例var bs = require(&quot;browser-sync&quot;).create(&apos;My server&apos;);// 创建多个var bs1 = require(&quot;browser-sync&quot;).create(&apos;Server 1&apos;);var bs2 = require(&quot;browser-sync&quot;).create(&apos;Server 2&apos;); .get( name )通过名称获取单个实例。如果你有其他构建脚本在单独的文件，这很有用。 nameType: String 12345678910111213// 在一个文件中创建一个命名实例...var bs = require(&quot;browser-sync&quot;).create(&apos;My Server&apos;);// 初始化Browsersync服务器bs.init(&#123; server: true&#125;);// 现在，获取另一个实例。var bs = require(&quot;browser-sync&quot;).get(&apos;My server&apos;);// 并调用它的任何方法。bs.watch(&apos;*.html&apos;).on(&apos;change&apos;, bs.reload); .init( config, cb )启动Browsersync服务。这将启动一个服务器，代理服务器或静态服务器，这取决于你实际需要。 configType: Object [optional]这是你的Browsersync实例的主配置，并且可以包含任何可用的选项。如果你不使用已有的配置参数，Browsersync仍将运行; 但只能在 snippet 模式下 cbType: Function [optional]如果你传递一个回调函数，它会在Browsersync已完成全部安装任务，并准备使用时被调用。或同步执行其他任务：当你需要等待信息（网址，端口等），这非常有用。 1234567891011var bs = require(&quot;browser-sync&quot;).create();// 开始一个Browsersync静态文件服务器bs.init(&#123; server: &quot;./app&quot;&#125;);// 开始一个Browsersync代理bs.init(&#123; proxy: &quot;http://www.bbc.co.uk&quot;&#125;); .reload( arg )该 reload 方法会通知所有的浏览器相关文件被改动，要么导致浏览器刷新，要么注入文件，实时更新改动。 argType: String | Array | Object [optional]一个或多个文件被重新加载。 1234567891011// 浏览器重载bs.reload();// 单个文件bs.reload(&quot;styles.css&quot;);// 多个文件bs.reload([&quot;styles.css&quot;, &quot;ie.css&quot;]);// 在2.6.0里 - 通配符来重新加载所有的CSS文件bs.reload(&quot;*.css&quot;); .stream( opts )该 stream 方法返回一个变换流，并且可以充当一次或多个文件。 optsType: Object [optional]配置流的方法 注: 至少需要2.6.0版本 1234567891011121314151617181920212223// 编译SASS且自动注入到浏览器gulp.task(&apos;sass&apos;, function () &#123; return gulp.src(&apos;scss/styles.scss&apos;) .pipe(sass(&#123;includePaths: [&apos;scss&apos;]&#125;)) .pipe(gulp.dest(&apos;css&apos;)) .pipe(bs.stream());&#125;);// 提供 `once: true` 限制每个流重装一次gulp.task(&apos;templates&apos;, function () &#123; return gulp.src(&apos;*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;app&apos;)) .pipe(bs.stream(&#123;once: true&#125;));&#125;);// 提供过滤器以被重新加载阻止不需要的文件gulp.task(&apos;less&apos;, function () &#123; return gulp.src(&apos;*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;css&apos;)) .pipe(bs.stream(&#123;match: &quot;**/*.css&quot;&#125;));&#125;); .notify( msg, timeout )浏览器消息助手 msgType: String | HTML可以是一个简单的消息，如“连接”或HTML timeoutType: Number [optional]消息将保存在浏览器里时间设置。1.3.0版本 12345678910var bs = require(&quot;browser-sync&quot;).create();// 文本信息bs.notify(&quot;Compiling, please wait!&quot;);// HTML信息bs.notify(&quot;HTML &lt;span color=&apos;green&apos;&gt;is supported&lt;/span&gt; too!&quot;);// 1.3.0版本，指定超时bs.notify(&quot;This message will only last a second&quot;, 1000); .exit()此方法将关闭所有正在运行的服务器，停止文件并退出当前进程。 123456789var bs = require(&quot;browser-sync&quot;).create();// 启动服务器bs.init(&#123;server: &quot;./app&quot;&#125;);// 5秒后退出服务器setTimeout(function () &#123; bs.exit();&#125;, 5000); .watch( patterns, opts, fn )单个文件监听。使用此连同Browsersync创建自己的，最小的构建系统 patternsType: String需要监听的文件 optsType: Object [optional]选择要传递给Chokidar对象的参数 - 可设置匹配规则 参考文档 fnType: Function [optional]每个事件的回调函数 注: 至少需要2.6.0版本 12345678910111213141516171819// 创建一个Browsersync实例var bs = require(&quot;browser-sync&quot;).create();// 监听HTML更改事件并重新加载bs.watch(&quot;*.html&quot;).on(&quot;change&quot;, bs.reload);// 提供一个回调来捕获所有事件的CSS// files - 然后筛选的&apos;change&apos;和重载所有// css文件在页面上bs.watch(&quot;css/*.css&quot;, function (event, file) &#123; if (event === &quot;change&quot;) &#123; bs.reload(&quot;*.css&quot;); &#125;&#125;);// 现在初始化的Browsersync服务器bs.init(&#123; server: &quot;./app&quot;&#125;); .pause()暂停文件执行事件 .resume()恢复暂停的事件 .emitter所使用的运行Browsersync实例（如果存在的话）的内部事件辐射源。你可以用它来发出自己的事件，如更改的文件，记录等。 12345678var bs = require(&quot;browser-sync&quot;).create();// 监听 `init` 事件bs.emitter.on(&quot;init&quot;, function () &#123; console.log(&quot;Browsersync is running!&quot;);&#125;);bs.init(config); .active一个简单的true/false标志，你可以用它来确定是否有一个当前运行Browsersync实例。 12345678910var bs = require(&quot;browser-sync&quot;).create();// -&gt; false, init尚未被执行console.log(bs.active);bs.init(config, function (err, bs) &#123; // -&gt; true，因为BS现在正在运行 console.log(bs.active);&#125;); .paused一个简单的true/false标志来确定是否当前实例暂停 更多信息可以查看Browsersync;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Browsersync</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript创建对象的七种方法总结]]></title>
    <url>%2F2016%2F01%2F06%2F160106Javascript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;最近再次拿起《Javascript高级程序设计（第三版）》，真的感觉经典的书何时读都会很有收获，相信好多人都推荐过这本书，这次也是给大家分享下其中创建对象这个主题，也是让自己更加深刻一下。 一、工厂模式12345678910111213例：function createPerson(name,age,job) &#123; var o = new Object( ); o.name = name; o.age = age; o.job = job; o.sayName = function ( ) &#123; alert(this.name); &#125;; return o; &#125;var person1 = createPerson(&quot;jim&quot;,29,&quot;teacher&quot;);var person2 = createPerson(&quot;tom&quot;,29,&quot;doctor&quot;);工厂模式虽然解决了创建多个对象的问题，但却没有解决对象识别的问题（即怎么知道一个对象的类型）； 二、构造函数模式12345678910例：function Person(name,age,job) &#123; this.name = name; this.age = age; this .job = job; this .sayName = function ( ) &#123; alert(this.name); &#125;; &#125;var person1 = new Person(&quot;jim&quot;,29,&quot;teacher&quot;);var person2 = new Person(&quot;tom&quot;,29,&quot;doctor&quot;); 特点： ①、没有显示地创建对象； ②、直接将属性和方法赋给了this对象； ③、没有return语句 创建Person的新实例，必须通过new操作符，以这种方式调用构造函数会经历以下四个步骤： ①、创建一个新对象； ②、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； ③、执行构造函数中的代码（初始化对象）； ④、返回新对象 这样就能够通过instanceof检测实例了，对象也就具备了类型 三、原型模式12345678910111213function Person( ) &#123;&#125;Person.prototype.name = &quot;jim&quot;;Person.prototype.age = 29;Person.prototype.job = teacher&quot;;Person.prototype.sayName = function ( ) &#123; alert(this.name); &#125;;var person1 = new Person( );person1.sayName( );var person2 = new Person( );person2.sayName( );alert(person1.sayName === person2.sayName) //true 缺点：原型模式的最大问题是由其共享的本性所导致的，这种共享对于函数非常合适，对于那些包含基本值的属性倒也还说得过去，通过在实例中添加一个同名属性，可以隐藏原型中的属性，然后对于引用类型值的属性来说，问题就比较突出了，只要一个实例改变，则所有是例都会发生同样的改变，因为实例只是有一个指针指向这个共享的引用类型，所以在开发中经常采用下面的这种组合模式； 四、组合使用构造函数模式和原型模式&nbsp;&nbsp;&nbsp;构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时共享着对方法的引用，最大限度地节省了内存，另外，这种模式还支持向构造函数传参，可以说是集两种模式之长； 五、动态原型模式&nbsp;&nbsp;&nbsp;它把所有的信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点，换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型；例：1234567891011121314function Person(name,age,job) &#123; //属性 this.name = name; this.age = age; this .job = job; //方法 if(typeof this.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function ( ) &#123; alert(this.name); &#125;; &#125; &#125;var person1 = new Person(&quot;jim&quot;,29,&quot;teacher&quot;);person1.sayName( ); 这里只会在sayName( )方法不存在的情况下，才会将它添加到原型中，其中，if语句检查的可以是初始化之后应该存在的任何属性和方法-不必用一大堆if语句检查每个属性和每个方法，只要检查其中一个即可，对于采用这种模式创建的对象，还可以使用instanceof操作符确定它的类型；注意：使用这种动态原型模式时，不能使用对象字面量重写原型，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系； 六、寄生构造函数模式&nbsp;&nbsp;&nbsp;这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的象，从表面上看，这个函数很像典型的构造函数； 例：1234567891011function Person(name,age,job) &#123; var o = new Object( ); o.name = name; o.age = age; o.job = job; o.sayName = function ( ) &#123; alert(this.name); &#125;; return o; &#125;var friend = new Person(&quot;jim&quot;,29,&quot;teacher&quot;); &nbsp;&nbsp;&nbsp;在这个例子中，除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例，而通过在构造函数末尾添加一个return语句，可以重写调用构造函数时返回的值，如果是简单数据类型直接忽略，是引用类型的话是直接返回这个对象。&nbsp;&nbsp;&nbsp;这个模式可以在特殊情况下用来为对象构造函数，注意一下接下来的说明：返回的对象和构造函数或与构造函数的原型属性之间没有关系，也可以说，构造函数返回的对象与构造函数外部创建的对象没有什么不同，也就不能一栏instanceof操作符来确定对象类型了。只是应用一些很少的特殊情况（可以起到保护内部数据的作用）假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式。123456789101112131415function SpecialArray( ) &#123; //创建数组 var values = new Array( ); //添加值 values.push.apply(values,arguments); //添加方法 values.toPipedString = function ( ) &#123; return this.join(&quot;|&quot;); &#125;; //返回数组 return values;&#125;var colors = new SpecialArray(&quot;red&quot;,&quot;blue&quot;.&quot;green&quot;);alert(colors.toPipedString()); //red|blue|green;//这样就能确保这个方法只应用这个特殊数组，而不是所有数组了 七、稳妥构造函数模式&nbsp;&nbsp;&nbsp;道格拉斯.克罗克福德发明了Javascript中的稳妥对象这个概念，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止this和new）或者防止被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数与寄生构造函数模式类似，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数； 例：1234567891011 function Person(name,age,job) &#123; //创建要返回的对象 var o = new Object( ); o.sayName = function( ) &#123; alert(name); &#125;; return o; &#125;var friend = Person(&quot;jim&quot;,29,&quot;teacher&quot;);friend.sayName( ); //jim &nbsp;&nbsp;&nbsp;这样变量friend中保存的是一个稳妥对象，而除了调用sayName（）方法以外，没有别的方式可以访问其数据成员，即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的方法访问传到构造函数中的原始数据。这种模式提供的这种安全性，使得它非常适合在某些安全执行环境提供的环境下使用，与寄生构造函数模式类似，使用稳妥构造函数创建的对象与构造函数之间也没有关系，因此instanceof操作符对这种对象也没有意义，其实我现在理解主要也是利用了闭包的思想，用函数包起来之后去保护一些私有变量；]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端组件库大合集]]></title>
    <url>%2F2015%2F12%2F13%2F151213%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93%E5%A4%A7%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这是一个较为全面的组件库，里面罗列了很多不错的框架以及组件，很值得参考和学习，跟大家一起分享学习!里面共有以下分类： 前端自动化 前端框架 JavaScript 框架汇总 UI组件库 基础模板 排版 网格系统 H5 API应用 UA识别 表单处理 图表绘制 日期格式化 页面交互 代码高亮插件 UI Icon组件 动画 本地存储 模板引擎 通知组件、弹框组件 提示控件 对话框、弹出层 文档、表格 目录树插件 Ajax模块 音频、视频 按钮 富文本编辑器 内容提取 颜色（CSS Colors）/SVG 实用工具/其他插件 想看这些内容戳这里就可以了大合集]]></content>
      <categories>
        <category>前端组件</category>
      </categories>
      <tags>
        <tag>前端组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash常见命令]]></title>
    <url>%2F2015%2F12%2F05%2F151205bash%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[bash命令格式命令 [-options] [参数]，如：tar zxvf demo.tar.gz查看帮助：命令 --help bash常见命令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory)` 切换目录，如 cd /etc ls (List)` 查看当前目录下内容，如 ls -al mkdir (Make Directory)` 创建目录，如 mkdir blog touch 创建文件，如 touch index.html cat 查看文件全部内容，如 cat index.html more less 查看文件，如more /etc/passwd、less /etc/passwd rm (remove)` 删除文件，如 rm index.html、rm -rf blog rmdir (Remove Directory)` 删除文件夹，只能删除空文件夹，不常用（rm –r temp/ ` 递归删除 - rm –rf temp/ ` 强行递归直接删除很危险） mv (move)` 移动文件或重命名，如 mv index.html ./demo/index.html cp (copy)` 复制文件，cp index.html ./demo/index.html head 查看文件前几行，如 head -5 index.html tail 查看文件后几行 –n –f，如 tail index.html、tail -f -n 5 index.html （实时，错误日志） tab 自动补全，连按两次会将所有匹配内容显示出来（筛选） history 查看操作历史 ssh 远程登录，如ssh root@gitlab.study.com &gt; 和 &gt;&gt;重定向，如echo hello world! &gt; README.md，&gt;表示覆盖 &gt;&gt;表示追加 wget 下载，如wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz tar 解压缩，如tar zxvf node-v4.4.0.tar.gz curl 网络请求，如curl http://www.baidu.com whoami 查看当前用户 |` 管道符 grep 匹配内容，一般结合管道符使用]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAHOO前端优化35条黄金法则]]></title>
    <url>%2F2015%2F11%2F14%2F151114YAHOO%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%9635%E6%9D%A1%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[Yahoo!的Excetional Performance 团队总结出了一系列可以提高网站速度的方法。可以分为 7大类 35条。包括内容 、服务器 、 CSS 、 JavaScript 、Cookie 、图片 、移动应用 ，七部分。 一、内容部分 尽量减少 HTTP请求 减少 DNS查找 避免跳转 缓存 Ajxa 推迟加载 提前加载 减少 DOM元素数量 用域名划分页面内容 使 frame数量最少 避免 404错误 1、尽量减少 HTTP请求次数 终端用户响应的时间中，有 80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、 Flash等。通过减少页面中的元素可以减少 HTTP请求的次数。这是提高网页速度的关键步骤。 减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少HTTP请求次数同时又可能保持页面内容丰富的技术。 合并文件是通过把所有的脚本放到一个文件中来减少 HTTP请求的方法，如可以简单地把所有的 CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修 改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。 CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的 background-image和 background-position属性来显示图片的不同部分； 图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可 以减少 HTTP请求次数。图片地图只有在图片的所有组成部分在页面中是紧挨在一起的时候才能 使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法； 内联图像是使用 data:URL scheme的方法把图像数据加载页面中。这可能会增加页面的大 小。把内联图像放到样式表（可缓存）中可以减少 HTTP请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的 支持。 减少页面的HTTP请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。 如同 Tenni Theurer的他的博客 Browser Cahe Usage - Exposed!中所说， HTTP请求在无缓存情况下占去了 40%到 60%的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！ 2、减少 DNS查找次数 域名系统（ DNS）提供了域名和 IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中 输入 www.yahoo.com 时， DNS解析服务器就会返回这个域名对应的 IP地址。 DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的 IP地址会花费 20到 120毫秒的时间。而且在这个过程中浏览器什么都不会做直到 DNS查找完毕。 缓存 DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的 ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。 DNS信息会保留在操作系统的 DNS缓存中（微软 Windows系统中 DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。 Internet Explorer 默认情况下对 DNS查找记录的缓存时间为 30分钟，它在注册表中的键值为 DnsCacheTimeout。 Firefox对 DNS的查找记录缓存时间为 1分钟，它在配置文件中的选项为network.dnsCacheExpiration（ Fasterfox把这个选项改为了 1小时）。 当客户端中的 DNS缓存都为空时（浏览器和操作系统都为空）， DNS查找的次数和页面中主机名的数量相同。这其中包括页面中 URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。 减少主机名的数量还可以减少页面中并行下载的数量。减少 DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是 把这些页面中的内容分割成至少两部分但不超过四部分。这种结果就是在减少 DNS查找次数和保持较高程度并行下载两者之间的权衡了。 3、避免跳转跳转是使用 301和 302代码实现的。下面是一个响应代码为 301的 HTTP头： 12345HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 浏览器会把用户指向到 Location中指定的 URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名 称， 301和 302响应都不会被缓存除非增加一个额外的头选项，如 Expires或者 Cache-Control来指定它缓存。&lt;meat /&gt;元素的刷新标签和JavaScript也可以实现 URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的 3XXHTTP状态代码，这主要是为了确保“后退”按钮可以正确地使用。 但是要记住跳转会降低用户体验。在用户和 HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在 HTML文件被加载前任何文件（图像、 Flash等）都不会被下载。 有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。 这种现象发生在当 URL本该有斜杠（ /）却被忽略掉时。例如，当我们要访问 http://astrology.yahoo.com/astrology 时，实际上返回的是一个包含 301代码的跳转，它指向的是http://astrology.yahoo.com/astrology/ （注意末尾的斜杠）。在 Apache服务器中可以使用 Alias 或者 mod_rewrite或者 the DirectorySlash来避免。 连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况 下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量 也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体验。一个可替代方法就是如果两者在同一台服务器上时使用 Alias和 mod_rewrite和实现。如果是因为域名的不同而采用跳转，那么可以通过使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 4、可缓存的 AJAX Ajax 经常被提及的一个好处就是由于其从后台服务器传输信息 的异步性而为用户带来的反馈的即时性。但是，使用 Ajax并不能保证用户不会在等待异步的 JavaScript和 XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于 Ajax如何来使用。例如，在一个基于 Web的 Email客户端中，用户必须等待 Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这 很重要。 为了提高性能，优化 Ajax响应是很重要的。提高 Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看 Add an Expires or a Cache-Control Header。 其它的几条规则也同样适用于Ajax： Gizp 压缩文件 减少 DNS查找次数 精简 JavaScript 避免跳转 配置 ETags 让我们来看一个例子：一个 Web2.0的 Email客户端会使用 Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过 Email web应用程序后没有对地址薄作任何的修改，而且 Ajax响应通过 Expire或者Cacke-Control头来实现缓存，那么就可以直接从上一次的缓存中读取地址薄 了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的 Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如， &amp;t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间 戳就不变，则从浏览器的缓存中加载从而减少了一次 HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的 URL和缓存响应并不匹配，浏览器就会重要请求更新地址薄。 即使你的 Ajxa响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做 可以使你的 Web2.0应用程序更加快捷。 5、推迟加载内容 你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时 所必需首先加载的？哪些内容和结构可以稍后再加载？ 把整个过程按照 onload事件分隔成两部分， JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的 JavaScript，那么它就以等待稍后加载，因为页面上的拖放元素是在初始化呈现 之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载 工具可以节省你的工作量：YUI Image Loader可以帮你推迟加载折叠部分的图片，YUI Get utility是包含 JS和 CSS的便捷方法。比如你可以打开 Firebug的 Net选项卡看一下 Yahoo的首页。 当性能目标和其它网站开发实践一致时就会相得益彰。这种情况 下，通过程序提高网站性能的方法告诉我们，在支持 JavaScript的情况下，可以先去除用户体验，不过这要保证你的网站在没有 JavaScript也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。 6、预加载 预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实 现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容 大部分已经加载到缓存中了，因此可以大大改善访问速度。 下面提供了几种预加载方法： 无条件加载：触发 onload事件时，直接加载额外的页面内容。以 Google.com为例，你可以看一下它的 spirit image图像是怎样在 onload中加载的。这个 spirit image图像在 google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。 有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预 加载页面内容。在 search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。 有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可能出在 用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站中利用 浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。 7、减少 DOM元素数量 一个复杂的页面意味着需要下载更多数据，同时也意味着 JavaScript遍历 DOM的效率越慢。比如当你增加一个事件句柄时在 500和 5000个 DOM元素中循环效果肯定是不一样的。 大量的 DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的 元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。 YUI CSS utilities 可以给你的布局带来巨大帮助： grids.css可以帮你实现整体布局，font.css和 reset.css可以帮助你移除浏览器默认格式。它提供了一个重新审视你页面中标签 的机会，比如只有在语意上有意义时才使用 &lt;div&gt;，而不是因为它具有换行效果才使用它。 DOM 元素数量很容易计算出来，只需要在 Firebug的控制台内输入： document.getElementsByTagName(&#39;*&#39;).length 那么多少个 DOM元素算是多呢？这可以对照有很好标记使用的类似页面。比如 Yahoo!主页是一个内容非常多的页面，但是它只使用了 700个元素（ HTML标签）。 8、根据域名划分页面内容把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于 DNS查找带来的影响你首先要确保你使用的域名数量在 2个到 4个之间。例如，你可以把用到的 HTML内容和动态内容放在 http://www.example.org/上，而把页面各种组件（图片、脚本、 CSS)分别存放在 statics1.example.org和 statics.example.org上。 你可在Tenni Theurer和 Patty Chi合写的文章 Maximizing Parallel Downloads in the Carpool Lane找到更多相关信息。 9、使 iframe的数量最小 ifrmae 元素可以在父文档中插入一个新的 HTML文档。了解 iframe的工作理然后才能更加有效地使用它，这一点很重要。 &lt;iframe&gt;优点： 解决加载缓慢的第三方内容如图标和广告等的加载问题 Security sandbox 并行加载脚本 &lt;iframe&gt;的缺点： 即时内容为空，加载也需要时间 会阻止页面加载 没有语意 10、不要出现 404错误 HTTP 请求时间消耗是很大的，因此使用 HTTP请求来获得一个没有用处的响应（例如 404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。 有些站点把 404错误响应页面改为“你是不是要找 ***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的 情况是指向外部 JavaScript的链接出现问题并返回 404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作 JavaScript代码来执行。 二、服务器部分 使用内容分发网络 为文件头指定Expires或Cache-Control Gzip压缩文件内容 配置ETag 尽早刷新输出缓冲 使用GET来完成AJAX请求 避免空的图像来源 11、使用内容分发网络 用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？ 按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任 务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。 要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的 应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。 内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据 和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。 一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet，或者Limelight Networks这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加 全球化，CDN就是实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。 12、为文件头指定Expires或Cache-Control 这条守则包括两方面的内容：对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求 网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请求，但 是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件， 但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。 浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需 要缓存多长时间。下面这个例子是一个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。 Expires: Thu, 15 Apr 2010 20:00:00 GMT 如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。下面这个例子是使用 ExpiresDefault来设定请求时间后10年过期的文件头： ExpiresDefault &quot;access plus 10 years&quot; 要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版 本号，如yahoo_2.0.6.js。 使用Expires文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少HTTP请求次数来说是无效的，因为浏览器的缓 存是空的。因此这种方法对于你网站性能的改进情况要依据他们“预缓存”存在时对你页面的点击频率（“预缓存”中已经包含了页面中的所有内容）。 Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中有75~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的 数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。 13、Gzip压缩文件内容 网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能 决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。 从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式： Accept-Encoding: gzip, deflate 如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content- Encoding来返回给浏览器。 Content-Encoding: gzip Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。 Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和 你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。 浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。 Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。 服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同 样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于 已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。 Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。 14、配置ETag Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有 ETag文件头的响应指定页面内容的ETag。 1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195 稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一 个304状态码，这就节省了12195字节的响应。 12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时 ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著 减少多服务器间的文件验证冲突。 Apache 1.3和2.x中的ETag格式为inode-size-timestamp。即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳 等都完全相同，但是在不同服务器上他们的内码也是不同的。 IIS 5.0和IIS 6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪 IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。不同的服务器上的Apache和IIS即使对于完全相同的内容产生的 ETag在也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收一个正常的200响应并下载全部内容。如果你的网站只放在一台服务器上，就 不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和 IIS产生默认的ETag配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的 内容拥有Expires文件头，无论用户什么时候点击“刷新”或者“重载”按钮都会发送相应的GET请求。 如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳的。去掉 ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中，只需要在配置文件中简单添加下面一行代 码就可以了： 1FileETag none 15、尽早刷新输出缓冲 当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用 flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理剩余的 HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。 输出缓冲应用最好的一个地方就是紧跟在之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下 载它们。 例子： 12345 &lt;!-- css, js --&gt; `&lt;/head&gt;` &lt;?php flush(); ?&gt; `&lt;body&gt;`&lt;!-- content --&gt; 为了证明使用这项技术的好处，Yahoo!搜索率先研究并完成了用户测试。 16、使用GET来完成AJAX请求 Yahoo!Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数 据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的 数据时就不能使用GET了。 一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义 （从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。 除此之外，JavaScript和CSS也是我们页面中经常用到的内容，对它们的优化也提高网站性能的重要方面： 三、CSS部分 把样式表置于顶部 避免使用CSS表达式（） 用代替@import 避免使用滤镜 17、把样式表置于顶部 在研究Yahoo!的性能表现时，我们发现把样式表放到文档的内部似乎会加快页面的下载速度。这是因为把样式表放到内会使页面有步骤的加载显示。 注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说 特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中HTML页面就是进程指针。当浏览器有序地加载文 件头、导航栏、顶部的logo等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。 把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘。用户不得不面对一个空白页面。 HTML规范清楚指出样式表要放包含在页面的&lt;head /&gt;区域内,和&lt;a /&gt;不同，&lt;link /&gt;只能出现在文档的&lt;head /&gt;区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照HTML规范在文档&lt;head /&gt;内加载你的样式表。 18、避免使用CSS表达式（） CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色： background-color: ( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );如上所示，中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。 方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。 表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加 一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。 一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样式属性 必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能会对你 页面的性能产生影响。 19、用代替@import 前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。 在IE中，页面底部@import和使用作用是一样的，因此最好不要使用它。 20、避免使用滤镜 IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的 呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。 完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 四、 JavaScript部分 把脚本置于页面底部 使用外部JavaScript和CSS 削减JavaScript和CSS 剔除重复脚本 减少DOM访问 开发智能事件处理程序 21、把脚本置于页面底部脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本 时，浏览器就不会同时下载其它文件了，即便是主机名不相同。在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还 会有作用域的问题。很多情况下，都会遇到这方面的问题。一个经常用到的替代方法就是使用延迟脚本。DEFER属性表明脚本中没有包含document.write，它告诉浏览器继续显示。不幸的 是，Firefox并不支持DEFER属性。在Internet Explorer中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部。这会让你的页面加载的快一点。 22、使用外部JavaScript和CSS很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢 还是把它们放在页面本身之内呢？在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。内置在HTML文档中的JavaScript 和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说，如果外部文件中的 JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。关键问题是，外部JavaScript和CSS文件缓存的频率和请求HTML文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。如果一 个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把JavaScript和CSS作为外部文件引用。比较适合使用内置代码的例外就是 网站的主页，如Yahoo!主页和My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置JavaScript和CSS对于终端用户来说会加快响应时 间。对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置 JavaScript和CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。 23、削减JavaScript和CSS精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。在 JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前10大网站的调查中发现，精简也可以缩小原来 代码体积的21%，而混淆可以达到25%。尽管混淆法可以更好地缩减代码，但是对于JavaScript来说精简的风险更小。除消减外部的脚本和样式表文件外，&lt;script&gt;和&lt;style&gt;代码块也可以并且应该进行消减。即使你用Gzip压缩过脚本 和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加 ，消减代码将会获得益处。 24、剔除重复脚本在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在重复引 用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP请求和 无用的JavaScript运算，这降低了网站性能。在Internet Explorer中会产生不必要的HTTP请求，而在Firefox却不会。在Internet Explorer中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次HTTP请求。即时脚本可以缓存，当用户重载页面时也会产 生额外的HTTP请求。除增加额外的HTTP请求外，多次运算脚本也会浪费时间。在Internet Explorer和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在HTML页面中使用&lt;script /&gt;标签引用脚本的最常见方法就是： 1&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt; 在PHP中可以通过创建名为insertScript的方法来替代： 1&lt;?php insertScript(&quot;menu.js&quot;) ?&gt; 为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于Expire文件头等。 25、减少DOM访问使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：缓存已经访问过的有关元素线下更新完节点之后再将它们添加到文档树中避免使用JavaScript来修改页面布局有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。 26、开发智能事件处理程序有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。 图片和Coockie也是我们网站中几乎不可缺少组成部分，此外随着移动设备的流行，对于移动应用的优化也十分重要。这主要包括： 五、Coockie部分 减小Cookie体积 对于页面内容使用无coockie域名 27、减小Cookie体积 HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此 保持coockie尽可能的小以减少用户的响应时间十分重要。有关更多信息可以查看Tenni Theurer和Patty Chi的文章“When the Cookie Crumbles”。这们研究中主要包括：去除不必要的coockie 使coockie体积尽量小以减少对用户响应的影响注意在适应级别的域名上设置coockie以便使子域名不受影响设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。 28、对于页面内容使用无coockie域名当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的 网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。 如果你的域名是http://www.example.org/，你可以在static.example.org上存在静态内容。但是，如果你不是在http://www.example.org/上而是在顶级域名example.org设置了coockie，那么所有对于static.example.org的请求都包含coockie。在这种情 况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是ymig.com，YouTube使 用的是ytimg.com，Amazon使用的是images-anazon.com等等。使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是，如果你 想确定应该使用example.org还是http://www.example.org/作为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了把coockie设置到*.example.org（*是泛域名解析，代表 了所有子域名译者dudo注）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。 六、Image 部分 优化图像 优化CSS Spirite 不要在HTML中缩放图像 favicon.ico要小而且可缓存 29、优化图像 设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。 使用imagemagick中下面的命令行很容易检查： 1identify -verbose image.gif 如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。 尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图片，不过 这都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF 能做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以 安全地把GIF格式转换为PNG格式： 1convert image.gif image.png “我们要说的是：给PNG一个施展身手的机会吧！”在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如： 1pngcrush image.png -rem alla -reduce -brute result.png 在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息 （如EXIF信息）： 1jpegtran -copy none -optimize -perfect src.jpg dest.jpg 30、优化CSS Spirite在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100x100的图片为1万像素，而1000x1000就是100万像素。 31、不要在HTML中缩放图像不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要： 1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么你的图片（mycat.jpg）就应该是100x100像素而不是把一个500x500像素的图片缩小使用。 32、favicon.ico要小而且可缓存favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。因此，为了减少favicon.ico带来的弊端，要做到： 文件尽量地小，最好小于1K 在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。Imagemagick可以帮你创建小巧的favicon。 33、避免空的图像来源一个src属性为空串的图像有两种情况： 123456781． 直接的HTML&lt;img src=&quot;&quot;&gt;2． JavaScriptvar img = new Image();img.src = &quot;&quot;; 这两种情况都会引起同样的效果：浏览器会再次向你的服务器发出请求。 Internet Explorer 将向这个页面所在的目录发出一个请求Safari and Chrome 将发出对这个页面的一个请求。Firefox 3 和更早的版本所采取的动作和Safari and Chrome一样，但是 3.5版本 addressed this issue[bug 444931] and no longer sends a request.Opera 不进行任何操作。这个行为为何是不好的？ 1、 发送大量突然的请求将使你的服务器宕机（Cripple your servers），尤其是每天有数百万访问量的页面。 2、 产生一个从未浏览过的页面将浪费服务器的计算周期（computing cycles） 3、 损坏用户数据。如果你在请求中追踪状态（以cookie或是其他的方式），你可能会损坏数据。即使这个图像请求并没有返回一个图像，所有的头被浏览器读取并接受，包括所有cookie。While the rest of the response is thrown away, the damage may already be done. 引起这种行为的根源在于浏览器中URI的解析方式。这种行为定义在RFC 3986 - Uniform Resource Identifiers.当一个空串作为一个URI时，它被认为一个相对URI（relative URI）并通过定义在section 5.2中的算法被解析。这个特例，一个空串，列在section 5.4当中。Firefox, Safari, and Chrome都是依据这一规格来解析空串，而Internet Explorer则不正确的解析这个串，符合更早的一个规范，RFC 2396 - Uniform Resource Identifiers (this was obsoleted by RFC 3986).所以技术上，浏览器都在做它们被期望所做的事情来解析relative URIs，问题是在这个范围，空串不是故意造成的。 HTML5 adds to the description of the tag&#39;s src attribute to instruct browsers not to make an additional request in section 4.8.2: The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document&#39;s address, then the src attribute&#39;s value must not be the empty string. 非常希望浏览器在将来不会有这样的问题。不幸的是，没有为&lt;script src=&quot;&quot;&gt;` and &lt;link href=&quot;&quot;&gt;的条款。或许仍需要时间来做出调整以保证浏览器不会意外的实现这一行为。 这一规则是受雅虎JavaScript导师Nicolas C. Zakas启发。 七、 Mobile部分 保持单个内容小于25K 打包组件成复合文本 34、保持单个内容小于25K这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。查看更多信息，请参阅Wayne Shea和Tenni Theurer的文件“Performance Research, Part 5: iPhone Cacheability - Making it Stick”。 35、打包组件成复合文本把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析Bootstrap基础模板]]></title>
    <url>%2F2015%2F11%2F10%2F151110%E8%A7%A3%E6%9E%90Bootstrap%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[简要分析Bootstrap基础模板中meta标签以及引包依赖关系 Bootstrap的优势 流媒体网格布局 响应式设计 自定义表单元素 页面排版 JavaScript交互性 跨浏览器兼容性 先来看一下官方给出的一个基础模板123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; `&lt;!-- Bootstrap --&gt;` &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 下面列出其中几个关键点 关于IE1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档 视口（viewport）1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 视口的作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示 目前大多数手机浏览器的视口（承载页面的容器）宽度都是980； 视口的宽度可以通过meta标签设置 此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1） width:视口的宽度 initial-scale：初始化缩放 user-scalable:是否允许用户自行缩放（值：yes/no; 1/0） minimum-scale:最小缩放，一般设置了用户不允许缩放，就没必要设置最小和最大缩放 maximum-scale:最大缩放 条件注释1234&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 条件注释的作用就是当判断条件满足时，就会执行注释中的HTML代码，不满足时会当做注释忽略掉 第三方依赖 jQuery Bootstrap框架中的所有JS组件都依赖于jQuery实现 html5shiv 让低版本浏览器可以识别HTML5的新标签，如header、footer、section等 respond 让低版本浏览器可以支持CSS媒体查询功能 mediaquery12345678910@media (判断条件（针对于当前窗口的判断）)&#123; /*这里的代码只有当判断条件满足时才会执行*/&#125;@media (min-width: 768px) and (max-width: 992px) &#123; /*这里的代码只有当(min-width: 1280px)满足时才会执行*/ .container &#123; width: 750px; &#125;&#125; 当使用min-width作为判断条件一定要从小到大，其原因是CSS从上往下执行 基础CSS样式 概要 预置排版样式 统一预制标签样式 按钮样式 表格样式 表单样式 图片样式 辅助工具类 代码样式 栅格系统 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 响应式工具类 hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 预置界面组件 导航 导航条 面包屑导航 下拉菜单 按钮式下拉菜单 按钮组 输入框组 警告框 页头 分页 列表组 面板 媒体对象 进度条 Glyphicons 标签 徽章 缩略图 大屏幕 嵌入内容 内嵌 JavaScript插件JavaScript插件的依赖情况如何使用Javascript插件内置组件 模态对话框 下拉菜单 滚动监听 标签页 工具提示 弹出框 警告框 按钮 折叠面板 轮播图 吸顶效果 data-spy=”affix” data-offset-top=”什么位置出现” data-offset-bottom=”什么位置消失” 深度自定义 Bootstrap在线自定义 官网在线 中文网在线 源码编译LESS语言 官方文档 中文文档]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows查看端口占用以及关闭相应的进程]]></title>
    <url>%2F2015%2F11%2F08%2F151108windows%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%85%B3%E9%97%AD%E7%9B%B8%E5%BA%94%E7%9A%84%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在开发的时候，难免有时候我们在启动应用的时候发现系统需要的端口被别的程序占用，如何知道谁占有了我们需要的端口，很多人都比较头疼，下面就介绍一种非常简单的方法，就拿最常见的一个8080端口占用来说： 1.Windows平台打开命令行 直接按上shift再加上鼠标右键 开始–运行–cmd 进入命令提示符 查看所有端口占用情况在命令行输入netstat -ano1234567891011121314151617181920212223242526272829303132333435363738394041C:\Users\lsqy\Desktop&gt;netstat -ano活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 84 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:623 0.0.0.0:0 LISTENING 10264 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:5366 0.0.0.0:0 LISTENING 2756 TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 5868 TCP 0.0.0.0:16992 0.0.0.0:0 LISTENING 10264 TCP 0.0.0.0:27017 0.0.0.0:0 LISTENING 3964 TCP 172.21.10.135:65448 182.254.78.139:80 ESTABLISHED 19524 TCP [::]:135 [::]:0 LISTENING 84 TCP [::]:445 [::]:0 LISTENING 4 TCP [::]:623 [::]:0 LISTENING 10264 TCP [::]:5357 [::]:0 LISTENING 4 TCP [::]:8080 [::]:0 LISTENING 5868 TCP [::]:16992 [::]:0 LISTENING 10264 TCP [::]:49664 [::]:0 LISTENING 708 TCP [::]:49665 [::]:0 LISTENING 1064 TCP [::]:49673 [::]:0 LISTENING 2840 TCP [::]:49674 [::]:0 LISTENING 876 TCP [::]:49677 [::]:0 LISTENING 952 TCP [::]:49712 [::]:0 LISTENING 856 TCP [::1]:50170 [::]:0 LISTENING 10312 TCP [::1]:59262 [::1]:59264 ESTABLISHED 10264 TCP [::1]:59264 [::1]:59262 ESTABLISHED 10264 UDP 0.0.0.0:123 *:* 520 UDP 0.0.0.0:3702 *:* 520 UDP 0.0.0.0:3702 *:* 2464 UDP 0.0.0.0:3702 *:* 1628 UDP 0.0.0.0:3702 *:* 520 UDP 0.0.0.0:3702 *:* 2464 UDP 0.0.0.0:3702 *:* 1628 UDP 0.0.0.0:4003 *:* 14804 UDP [fe80::b1ec:1ffd:410:3856%15]:1900 *:* 2464 UDP [fe80::b1ec:1ffd:410:3856%15]:2177 *:* 2464 UDP [fe80::b1ec:1ffd:410:3856%15]:52081 *:* 2464 2.查看指定端口占用情况1234C:\Users\lsqy\Desktop&gt;netstat -ano|findstr &quot;8080&quot; 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 5868 TCP [::]:8080 [::]:0 LISTENING 5868 可以很显然的看到这个端口是被5868的进程占用 3.查看pid对应的进程12C:\Users\lsqy\Desktop&gt;tasklist|findstr &quot;5868&quot;node.exe 5868 Console 13 12,600 K 这样可以知道是node占用了端口 4.结束该进程1234C:\Users\lsqy\Desktop&gt;taskkill /f /t /im node.exe成功: 已终止 PID 7280 (属于 PID 2068 子进程)的进程。成功: 已终止 PID 2068 (属于 PID 20712 子进程)的进程。成功: 已终止 PID 5868 (属于 PID 9144 子进程)的进程。]]></content>
      <categories>
        <category>实用小技能</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让ie低版本支持CSS3 Media Query]]></title>
    <url>%2F2015%2F10%2F26%2F151026%E8%AE%A9ie%E4%BD%8E%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81CSS3%20Media%20Query%2F</url>
    <content type="text"><![CDATA[前言现在响应式开发无疑是在工作当中很必要的，但是众从周知IE系列的兼容性是不敢恭维的，下面大家就来认识一下Respond.js来解决你的苦恼吧。Bootstrap里面就引入了这个js文件，从名字很显然可以看出来是自适应的兼容。打开IE看了一下，效果挺好的，自适应的效果挺好的。Respond.js让不支持CSS3 Media Query的浏览器包括IE6-IE8等其他浏览器支持查询。 原理： 1.把head中所有的的css路径取出来放入数组 2.然后遍历数组一个个发ajax请求 3.ajax回调后仅分析response中的media query的min-width和max- width语法，分析出viewport变化区间对应相应的css块 4.页面初始化时和window.resize时，根据当前viewport使用相应的css块。使用：考虑到IE9是支持CSS3的，所以直接在HTML页面的head标签中添加脚本引用即可： 123`&lt;!--[if lt IE 9]&gt;` &lt;script src=&quot;http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]—&gt; 使用方式 官方demo地址：http://scottjehl.github.com/Respond/test/test.html 1.在css中正常用 min/max-width media queries 123@media screen and (min-width: 480px)&#123; ...styles for 480px and up go here&#125; 2.引入respond.min.js，但要在css的后面（越早引入越好，在ie下面看到页面闪屏的概率就越低，因为最初css会先渲染出来，如果respond.js加载得很后面，这时重新根据media query解析出来的css会再改变一次页面的布局等，所以看起来有闪屏的现象） 更多了解可以参考http://caibaojian.com/respondjs.html]]></content>
      <categories>
        <category>兼容处理</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ie低版本不支持HTML5新增标签]]></title>
    <url>%2F2015%2F10%2F16%2F151016%E8%A7%A3%E5%86%B3ie%E4%BD%8E%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81HTML5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[html5shiv的作用用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 为了ie678由于IE6/IE7/IE8还有很大一部分用户，为了让网站浏览者都能正常的访问HTML5网站，解决方案就有下面两个： 1、为网站创建多套模板，通过程序对User-Agent的判断给不同的浏览器用户显示不同的页面，这样的维护成本比较高，也失去响应式设计的意义。 2、使用Javascript来使不支持HTML5的浏览器支持HTML标签。目前大多网站采用的这种方式（Bootstrap官方例子也是如此）。 原理其实还是利用了原生js通过document.createElement(&quot;&quot;)创建对应的标签，CSS选择器便可正确应用到该标签。 使用使用也是相当方便的，考虑到IE9是支持html5的，所以直接在HTML页面的head标签中添加脚本引用即可 123`&lt;!--[if lt IE 9]&gt;` &lt;script src=&quot;http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]—&gt; 官方地址：http://code.google.com/p/html5shiv/GitHub项目地址：https://github.com/aFarkas/html5shiv]]></content>
      <categories>
        <category>兼容处理</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>html5shiv</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用WampServer搭建自己的HTTP服务器]]></title>
    <url>%2F2015%2F10%2F05%2F151005%E4%BD%BF%E7%94%A8WampServer%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、WampServer简介&nbsp;&nbsp;&nbsp;&nbsp;WampServer全称是Windows (Linux) + Apache + Mysql + PHP，也就是刚好是每个首字母的组合起来的，它其实是一个集成安装环境，也就是里面包含了Apache 、 Mysql 、 PHP这三款的运行环境，对于初做前端的新手来说，有些时候可能要模仿一下后台数据，那就需要用到一下服务器，但搭建环境也不是件容易的事情，特别是对于新手同学来说！因此在这里跟大家介绍一款作为一名新手在使用的方便好用的PHP服务器架设软件，那就是wampserver。 二、WampServer下载安装&nbsp;&nbsp;&nbsp;&nbsp;自行百度即可，没有什么特别可说的，直接一直下一步即可； 三、管理HTTP服务&nbsp;&nbsp;&nbsp;&nbsp;任务图标绿色为正常启动状态说明正确安装了，通过图形控制台可以启动、重启、停止所有服务;或者单独启动、重启、停止特定服务; 注意事项：1、检查访问权限 Allow from all1、理解默认索引3、确保端口没有被其它程序占用4、“#”表示注释5、修改配置要格外小心，禁止无意修改其它内容 四、配置根目录&nbsp;&nbsp;&nbsp;&nbsp;网站根目录是Web服务器上存放网站程序的空间，可通过修改配置文件自定义，如E:/www具体步骤如下1、打开配置文件，控制台选择;或者 wampserver安装目录的bin\apache\Apache2.2.21\conf\httpd.conf下2、设定根目录，查找并修改 1DocumentRoot &quot;D:/wamp/www&quot; 例如： 1DocumentRoot &quot;E:/www/&quot; 这样就指定了 “E:/www/“为存放网站的根目录。3、配置根目录，查找 1&lt;Directory &quot;D:/wamp/www/&quot;&gt; 修改成 1&lt;Directory &quot;E:/www/&quot;&gt; 4、修改完后，并不能立即生效，注意需要重启Apache注：可以指定任意目录为根目录 五、网站部署&nbsp;&nbsp;&nbsp;&nbsp;将我们制作好的网页拷贝到配置好的根目录下，浏览器访问127.0.0.1即可。 六、配置虚拟主机&nbsp;&nbsp;&nbsp;&nbsp;在一台Web服务器上，我们可以通过配置虚拟主机，然后分别设定根目录，实现对多个网站的管理。 具体步骤如下：1、开启虚拟主机辅配置，在httpd.conf 中找到去掉前面的#号注释，开启虚拟主机配置，注意http.conf是在D:\wamp\bin\apache\Apache2.2.21\conf,也就是你安装目录下的按我上面的路径查找即可 12# Virtual hosts# Include conf/extra/httpd-vhosts.conf //只需将这一行的#号去掉即可，上面的Virtual hosts前面的#不用去 2、配置虚拟主机，打开D:\wamp\bin\apache\Apache2.2.21conf/extra/httpd-vhosts.conf &lt; 我的wamp是安装在D盘的，所以是这个路径 1234567&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;c:/Apache2/docs/dummy-host2.example.com&quot; ServerName dummy-host2.example.com ErrorLog &quot;logs/dummy-host2.example.com-error.log&quot; CustomLog &quot;logs/dummy-host2.example.com-access.log&quot; common&lt;/VirtualHost&gt; 分别修改以下三项123DocumentRoot &quot;E:/www/example&quot;ServerName &quot;example.com &quot;ServerAlias &quot;www.example.com&quot; 其它项无需指定。3、修改DNS（hosts）文件 DNS想了解了可以百度搜索即可，就是一个域名系统，这里可以配置多个DNS，按自己需求来设置，相应的上面对应多个根目录 打开C:\Windows\System32\drivers\etc\hosts目录是固定的 12127.0.0.1 example.com127.0.0.1 www.example.com 注：修改hosts文件权限,以管理员身份运行4、重启Apache，这一步一定要注意，很多人容易疏忽5、浏览器访问www.example.com，你就会看到你存到这个根目录里的项目应该就能看到了,注意这里还可以再配置其他的，例如我还配置了一个 12127.0.0.1 study.com127.0.0.1 www.study.com 结语&nbsp;&nbsp;&nbsp;&nbsp;到这里就结束了，接下来前端小伙伴们就可以按照自己需求实现一些简单的动态网站开始体验下了。]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>WampServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说DOCTYPE的作用以及标准模式与混杂模式的区别]]></title>
    <url>%2F2015%2F09%2F16%2F150916%E8%AF%B4%E8%AF%B4DOCTYPE%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE&gt;定义和用法： &lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 标签之前。 &lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。 提示：请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。 &lt;!DOCTYPE&gt;作用：&lt;!DOCTYPE&gt;声明位于文档中的最前面，处于 &lt;html&gt;标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 标准模式与与混杂模式的区别其实所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；混杂模式（怪异模式）则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 , 将使网页进入怪异模式。 严格模式下：页面排版及JS解析是以该浏览器支持的最高标准来执行混杂模式：不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容 DTD即文档类型定义（Document Type Definition）]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript进阶之函数的四种调用模式]]></title>
    <url>%2F2015%2F09%2F01%2F150901Javascript%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;在JavaScript中，函数是一等公民，相信这句话大家多少都有所耳闻吧，其实主要是因为函数在JavaScript中是一个数据类型，而非像C#或其他描述性语言那样仅仅作为一个模块来使用。函数有四种调用模式，分别是：作为函数调用形式、作为对象的方法调用、作为构造函数调用、以及使用call或者apply调用。这里所有的调用模式中，其实最大的区别就是this指向的不同，有一个方便理解this指向的方法就是：“牢记谁调用的函数，函数内部的this就指向谁，this是动态确定指向谁的” ;另外要注意this是个关键字，是有特殊含义的，下面分别介绍这几种调用形式。 1.作为函数调用例：123456function func() &#123; var age = 18; console.log(this.age);// undefined console.log(this);//window&#125;func(); 123456function func() &#123; var age = 18; console.log(this.age);// undefined console.log(this);//window&#125;window.func(); 对于初学者来说是不是觉得跟自己想象的有出入，但其实一分析就知道这刚好印证了我们上面的this就是指向调用它的对象,而这里上述两个直接func()和window.func()结果是一样的，你可以暂时这样记住在函数调用模式中，函数里的 this 关键字指全局对象，如果在浏览器中就是 window 对象。这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，想了解的可以自行上网查找。 2.作为对象方法调用，this就是当前调用方法的对象&nbsp;&nbsp;&nbsp;&nbsp;函数调用模式很简单，是最基本的调用方式。可以这么理解：同样的是函数，将其赋值给一个对象的成员以后，就不一样了。将函数赋值给对象的成员后，那么这个就不在称为函数，而应该叫做方法，这是业内的一贯称谓；例：12345678910var obj = &#123; name: &quot;functionName&quot;, age: 19, getName: function() &#123; console.log(this.name);// this指向obj（当前调用方法的对象） &#125;&#125;;obj.getName(); 对比下函数调用与方法调用的区别，函数调用中，this专指全局对象window,而在方法中this专指当前对象即o.fn中的 this指的就是对象o。 3.作为构造函数调用&nbsp;&nbsp;&nbsp;&nbsp;在单纯的函数模式下，this 表示 window；在对象方法模式下，this 指的是当前对象。除了这两种情况，JavaScript 中函数还可以作为构造函数来调用,这时候是在函数调用前面加上一个 new 关键字,另外要注意构造函数最大作用是为了初始化一个实例对象，真正创建对象的是new，很多人不了解的以为就是构造函数创建了对象，这一点以后要注意。例：12345function Person(name) &#123; this.name = name;// this 指向新创建出来的对象p，这种方法可以很方便的让任何对象来使用构造函数里的属性&#125;var p = new Person(&quot;小明&quot;);console.log(p.name);//小明 其实在构造函数内部会进行下面这段代码1234567function Person(name) &#123; var this; this.name = name; return this;&#125;var p = new Person(&quot;小明&quot;);console.log(p.name);//小明 其实上面的可以描述为：创建Person的新实例，必须通过new操作符，以这种方式调用构造函数会经历以下四个步骤： ①、创建一个新对象； ②、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； ③、执行构造函数中的代码（初始化对象）； ④、返回新对象 需要注意的点 构造函数当中没有return，则默认就是返回当前对象，即this； 如果有return，后面是基本数据类型，忽略，和没写一样 但是如果后面是一个有效的引用类型的话，无论构造函数中写什么内容，都会返回这个引用类型，也就是不会返回this，而是返回这个引用类型（对象）了看如下代码:12345678function Person(name) &#123; this.name = name; return &#123; name : &quot;小王&quot; &#125;&#125;var p = new Person(&quot;小明&quot;);console.log(p.name);//小王 其实这是一种寄生模式的形式创建的对象，在这里先不详细介绍，大家暂时只需先知道不要在构造函数内部再重新return，除非真的有特殊情况再行分析； 4.使用call或者apply调用（上下文调用），this由上下文决定使用apply模式和call模式,可以任意的操作控制 this 的意义，所以在函数 js 的设 计模式中使用还是很广泛的，现在你也可以在Javascript中很多优秀的类库当中都能看到它的身影，因为它具有一个强大的作用，就是“调用上下文”；首先看它的语法：// call和apply的区别：就是参数不同 123// call(上下文, arg1, arg2, ...) call后面的参数不是数组形式；// apply(上下文，[arg1, arg2, ...]) apply后面的参数必须是数组形式；例：func.call(obj); // this 指向传入的参数：obj（第一个参数） 拿数组的push方法来举例 123456789var arr = [1,2,3];&lt;!-- 使用apply --&gt;[].push.apply(arr,[4,5,6]);cosole.log(arr);//[1,2,3,4,5,6];这时我们就将push作为一个方法，通过arr调用，也就是说apply会自动将它后面传入的参数数组按每一个传入push这个函数当中，其实等同于arr.push(4,5,6);&lt;!-- 使用call --&gt;[].push.call(arr,4,5,6);cosole.log(arr);//[1,2,3,4,5,6]; 总的来说apply的参数，第一个参数表示指定的this，第二个参数要求是数组，表示函数的参数call的参数，第一个参数也是表示指定的this，第二个参数不是数组，表示函数的参数； 结语&nbsp;&nbsp;&nbsp;&nbsp;其实在Javascript中的很多重要的概念和应用场景都是围绕着这四种调用模式来进行的，只不过很多时候大家都只是了解的不系统，在一些容易混淆的点上出了问题，所以也希望大家能够认真分析，更上一层楼吧！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax小结]]></title>
    <url>%2F2015%2F08%2F01%2F150801Ajax%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;相信大家现在每一个开发人员对AJAX都不陌生，每天肯定离不开跟它打交道，事实证明它确实很大程度的提高了用户体验。有一次跟身边的一个朋友聊天，问它对AJAX有什么深入理解，他说不就是用jquery里的AJAX嘛，按那个格式写就行了，其他的也没必要了解，但我觉得我们不应只是类库的使用者，我认为还是要‘知其然知其所以然’,不能是停留在会用的基础上，虽然不能把其全部实现都如数分析出，但是从原理的角度还是可以知道的，下面也是自己大概总结了下AJAX的原理，总结不当之处还望指出。^^_^^ AJAX简介&nbsp;&nbsp;&nbsp;&nbsp;AJAX全称其实是“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术&nbsp;&nbsp;&nbsp;&nbsp;我们经常也是用于通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，不会像最早以前只要请求下数据，就得刷新页面。&nbsp;&nbsp;&nbsp;&nbsp;说到这里，也算是AJAX拯救了Javascript，因为在2005年之前Javscript经常被认为是一个很低级的脚本语言，最重要的是很多开发者都用它开发了一些烦人的广告之类的，最终导致Javascript在好几个主流浏览器上都经常被禁用，相信现在有些开发者也知道每个浏览器都有一个禁用Javascript的选项，不过这时的我们并不是真的禁用它，最多是处于调试的目的，但那时候可是真的禁用，好了，野史就先说到这….2005年对于AJAX可以说是一个重要的元年，很多重大的事件让大众对它真的是刮目相看，Google在它著名的交互应用程序中使用了异步通讯，如Google、Google地图、Google搜索等。而AJAX又是基于Javascript，所以就此Javascript又重新发展了起来。 AJAX核心XMLHttpRequest&nbsp;&nbsp;&nbsp;&nbsp;Ajax的原理简单来说通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用Javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。&nbsp;&nbsp;&nbsp;&nbsp;XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。所以我们先从XMLHttpRequest讲起，来看看它的工作原理。首先，我们先来看看XMLHttpRequest这个对象的属性。它的属性有：1234567891011onreadystatechange 每次状态改变所触发事件的事件处理程序。responseText 从服务器进程返回数据的字符串形式。responseXML 从服务器进程返回的DOM兼容的文档数据对象。status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）status Text 伴随状态码的字符串信息readyState 对象状态值0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）1 (初始化) open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。2 (发送数据) Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 它能实现的四个主要点是： 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 对于XMLHttpRequest对象的兼容问题123456789101112不同的浏览器使用不同的方法来创建 XMLHttpRequest 对象。ie5,6 使用 ActiveXObject。ie高版本的也和其他浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象。要克服这个问题，可以使用这段简单的代码：var XMLHttp=null;if (window.XMLHttpRequest)//这种方法也可以称之为能力检测&#123;XMLHttp=new XMLHttpRequest()&#125;else if (window.ActiveXObject)&#123;XMLHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;）&#125; 原生AJAX使用步骤get请求方式1.既然要用这个内建对象，就先把它实例化这个内建对象；12// 实例化这个内建对象var xhr = new XMLHttpRequest(); 2.通过open方法发起请求行12//先以get方式提交请求，下面会说明get和post的区别 xhr.open(&apos;get&apos;, &apos;01.php&apos;); 3.设置了一个请求头12xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;text/html&apos;); get请求可以不设置，post形式的时候需要设置，在这里设上也没有影响 4.发送请求主体12 get没有请求主体，但是出于规范的角度，在里面传一个`null`;get请求参数的时候是在url后面xhr.send(null); 5.接收服务器响应&nbsp;&nbsp;&nbsp;&nbsp;HTTP响应是由服务端发出的，作为客户端更应关心的是响应的结果。HTTP响应3 个组成部分与XMLHttpRequest方法或属性的对应关系。由于服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。而onreadystatechange就是监听XMLHttpRequest的状态的事件 1234567891011121314// 监听响应状态并处理xhr.onreadystatechange = function () &#123; // 响应的状态 // console.log(xhr.readyState); // 响应的服务器状态码 // console.log(xhr.status); // 监听完成的状态及服务器响应状态 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 获得结果 console.log(xhr.responseText); // DOM操作将结果放到页面里 document.getElementById(&apos;result&apos;).innerHTML = xhr.responseText; &#125;&#125; post请求1.同上，既然要用这个内建对象，就先把它实例化这个内建对象；12// 实例化这个内建对象var xhr = new XMLHttpRequest(); 2.通过open方法发起请求行12//先以get方式提交请求，下面会说明get和post的区别 xhr.open(&apos;post&apos;, &apos;01.php&apos;); 3.设置了一个请求头 post方式必须设置请求头1xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencodeed&apos;); 4.发送请求主体12 //send里面的参数不是必须得传的，需要就传；没有参数的时候，里面最好写上null，虽然不是必须的，但比较规范，当post方式需要传递参数的时候，在里面传入xhr.send(null); 5.接收服务器响应1234567891011121314// 监听响应状态并处理xhr.onreadystatechange = function () &#123; // 响应的状态 // console.log(xhr.readyState); // 响应的服务器状态码 // console.log(xhr.status); // 监听完成的状态及服务器响应状态 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 获得结果 console.log(xhr.responseText); // DOM操作将结果放到页面里 document.getElementById(&apos;result&apos;).innerHTML = xhr.responseText; &#125;&#125; GET和POST请求方式的差异1、GET没有请求主体，使用xhr.send(null)2、GET可以通过在请求URL上添加请求参数3、POST可以通过xhr.send(‘name=itcast&amp;age=10’)传参4、POST必须要设置’Content-Type’为’application/x-www-form-urlencodeed’5、GET效率更好（应用多）6、GET大小限制约4K，POST则没有限制 get方式传参格式：需要将参数放到url后面，格式为?key=val&amp;key1=val1 ，例：xhr.open(‘get’,’index.php?name=jack&amp;age=20’)post方式传参格式：xhr.send(‘name=jack&amp;age=20’) 结语&nbsp;&nbsp;&nbsp;&nbsp;这里也只是简要分析了ajax最基本的应用与原理，以后能自己再上一个层面之后就可以再深入下了，XMLHttpRequest2.0已经早已出世了，以后可以另起篇章总结学习下。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重的几种实现方式]]></title>
    <url>%2F2015%2F07%2F29%2F150729%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[下面每种方法都采用普通的函数模式封装和原型模式封装 方法一:普通函数模式封装12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组去重&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr1 = [1, 2, 2, 3, 4, 3, 5, 4]; function unique(arr) &#123; var n = []; //声明一个临时数组 for (var i = 0; i &lt; arr.length; i++) &#123; if (n.indexOf(arr[i]) == -1) n.push(arr[i]);//如果当前数组的第i项已经保存进了临时数组，那么跳过， 否则把当前项push到临时数组里面，运用了indexOf方法的使用 &#125; return n; &#125; console.log(unique(arr1)); //[1, 2, 3, 4, 5] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原型模式 与函数模式的不同是直接将这个去重方法封装到数组Array的原型属性当中，这样每一个数组都能后通过原型链访问到这个方法 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组去重&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr1 = [1, 2, 2, 3, 4, 3, 5, 4]; Array.prototype.unique = function() &#123; var n = []; //声明一个临时数组 for (var i = 0; i &lt; this.length; i++) &#123; if (n.indexOf(this[i]) == -1) n.push(this[i]);//如果当前数组的第i项已经保存进了临时数组，那么跳过，否则把当前项push到临时数组里面 &#125; return n; &#125; console.log(arr1.unique());//[1, 2, 3, 4, 5] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方法二:普通函数模式封装1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组去重&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr1 = [1, 2, 2, 3, 4, 3, 5, 4]; function unique(arr) &#123; var n = &#123;&#125;, //n为一个hash对象 r = []; //r为一个临时数组 for (var i = 0; i &lt; arr.length; i++) &#123; if (!n[arr[i]])&#123; //如果hash表中没有当前项 n[arr[i]] = true; //存入hash表 r.push(arr[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; return r; &#125; console.log(unique(arr1));//[1, 2, 3, 4, 5] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原型模式 与函数模式的不同是直接将这个去重方法封装到数组Array的原型属性当中，这样每一个数组都能后通过原型链访问到这个方法 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组去重&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr1 = [1, 2, 2, 3, 4, 3, 5, 4]; Array.prototype.unique = function() &#123; var n = &#123;&#125;, //n为hash表 r = []; //r为临时数组 for (var i = 0; i &lt; this.length; i++) &#123; if (!n[this[i]]) &#123; //如果hash表中没有当前项 n[this[i]] = true; //存入hash表 r.push(this[i]); //把当前数组的当前项push到临时数组里面 &#125; &#125; return r; &#125; console.log(arr1.unique1()); //[1, 2, 3, 4, 5] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方法三普通函数模式封装1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组去重&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr1 = [1, 2, 2, 3, 4, 3, 5, 4]; function unique(arr) &#123; var n = [arr[0]]; //结果数组 for (var i = 1; i &lt; arr.length; i++) &#123; //从第二项开始遍历 if (arr.indexOf(arr[i]) == i) n.push(arr[i]); //如果当前数组的第i项在当前数组中第一次出现的位置不是i， 那么表示第i项是重复的，忽略掉。否则存入结果数组 &#125; return n; &#125; console.log(unique(arr1));//[1, 2, 3, 4, 5] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原型模式 与函数模式的不同是直接将这个去重方法封装到数组Array的原型属性当中，这样每一个数组都能后通过原型链访问到这个方法 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组去重&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var arr1 = [1, 2, 2, 3, 4, 3, 5, 4]; Array.prototype.unique = function() &#123; var n = [this[0]]; //结果数组 for (var i = 1; i &lt; this.length; i++) &#123; //从第二项开始遍历 if (this.indexOf(this[i]) == i) n.push(this[i]); //如果当前数组的第i项在当前数组中第一次出现的位置不是i， 那么表示第i项是重复的，忽略掉。否则存入结果数组 &#125; return n; &#125; console.log(arr1.unique1()); //[1, 2, 3, 4, 5] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结语这里总结这几种方法，也是提醒自己以后遇到问题注意发散思维，并且通过发散思维还能够让自己收获更多相关的知识运用，何乐而不为。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数组</tag>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML与CSS编码规范]]></title>
    <url>%2F2015%2F07%2F06%2F150706Html%E4%B8%8ECSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[宗旨：编写灵活、稳定、高质量的 HTML 和 CSS 代码的规范,让自己的代码更加具有鲁棒性，是每一个优秀的程序员必备的意识，时刻注意要规范自己的编码风格，终究会是利人利己，否则肯定是害人害己，也希望大家都重视起编码规范的重要性，下面列出一些规范，也是警示自己也应该时刻谨记规范编写自己的代码。 一、黄金定律&nbsp; &nbsp;&nbsp; &nbsp;不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的,这一点也就是说明一个项目必须在开展前就把自己的编码规范明确的告诉每一位同事，不管以后交接也好，什么也好，严格按照规范来执行，这样自己项目以后再扩展功能或者部分重构肯定都会事半功倍！ 二、HTML部分1. 语法 用两个空格来代替制表符（tab） 这是唯一能保证在所有环境下获得一致展现的方法。 嵌套元素应当缩进一次（即两个空格）。 对于属性的定义，确保全部使用双引号，绝不要使用单引号。 不要在自闭合（self-closing）元素的尾部添加斜线 –HTML5 规范中明确说明这是可选的。 不要省略可选的结束标签（closing tag）（例如，或 ）。 2. HTML5 doctype&nbsp; &nbsp;&nbsp; &nbsp;为每个 HTML,页面的第一行添加标准模式（standardmode）的声明，这样能够确保在每个浏览器中拥有一致的展现。 3. 语言属性根据 HTML5 规范：&nbsp; &nbsp;&nbsp; &nbsp;强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言,避免乱码，并且这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。例：123&lt;html lang=&quot;zh-CN&quot;&gt;&lt;!-- ... --&gt;&lt;/html&gt; 4. IE 兼容模式&nbsp; &nbsp;IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为edge mode，从而通知 IE 采用其所支持的最新的模式。例：&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 5. 字符编码&nbsp; &nbsp;通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（一般采用 UTF-8 编码,因为UTF-8基本上支持世界上大多数语言格式）例:123&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt; 6. 引入 CSS 和 JavaScript 文件&nbsp; &nbsp;根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性，因为 text/css 和 text/javascript 分别是它们的默认值,并且在性能的角度上，要在文档开始加载的时候加载CSS文件，在文档底部加载JavaScript，这样JavaScript不会阻碍页面的渲染；例：123&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;&lt;!-- JavaScript --&gt;&lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt; 7. 实用为王&nbsp; &nbsp;尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。 8. 属性顺序&nbsp; &nbsp;HTML属性应当按照以下给出的顺序依次排列，确保代码的易读性。123456* class* id, name* data-** src, for, type, href* title, alt* aria-*, role &nbsp; &nbsp;class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。 9. 布尔（boolean）型属性&nbsp; &nbsp;布尔型属性可以在声明时不赋值。XHTML 规范要求为其赋值，但是 HTML5 规范不需要。更多信息请参考 WhatWG section on boolean attributes：元素的布尔型属性如果有值，就是 true，如果没有值，就是 false。如果一定要为其赋值的话，请参考 WhatWG 规范：如果属性存在，其值必须是空字符串或 […] 属性的规范名称，并且不要再收尾添加空白符。简单来说，就是不用赋值。例：123&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt;&lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt; 10. 减少标签的数量&nbsp; &nbsp;编写 HTML 代码时，尽量避免多余的父元素。很多时候，这需要迭代和重构来实现。请看下面的案例：123&lt;!-- Not so great --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 11. JavaScript 生成的标签&nbsp; &nbsp;通过 JavaScript 生成的标签让内容变得不易查找、编辑，并且降低性能。能避免时尽量避免。这一点自己灵活掌握，具体看需求 三、CSS部分1. 语法 用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。 为选择器分组时，将单独的选择器单独放在一行。 为了代码的易读性，在每个声明块的左花括号前添加一个空格。 声明块的右花括号应当单独成行。 每条声明语句的 : 后应该插入一个空格。 为了获得更准确的错误报告，每条声明都应该独占一行。 所有声明语句都应当以分号结尾。最后一条声明语句后面的分号是可选的，但是，如果省略这个分号，你的代码可能更易出错。 对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，box-shadow）。 不要在 rgb()、rgba()、hsl()、hsla() 或 rect() 值的内部的逗号后面插入空格。这样利于从多个属性值（既加逗号也加空格）中区分多个颜色值（只加逗号，不加空格）。 对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，.5 代替 0.5；-.5px 代替 -0.5px）。 十六进制值应该全部小写，例如，#fff。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。 尽量使用简写形式的十六进制值，例如，用 #fff 代替#ffffff。 为选择器中的属性添加双引号，例如，input[type=”text”]。只有在某些情况下是可选的，但是，为了代码的一致性，建议都加上双引号。 避免为 0 值指定单位，例如，用 margin: 0; 代替margin: 0px;。 例：1234567891011/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123; padding:15px; margin:0px 0px 15px; background-color:rgba(0, 0, 0, 0.5); box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125;/* Good CSS*/.selector,.selector-secondary,.selector[type=&quot;text&quot;] &#123; padding: 15px; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125; 2. 声明顺序相关的属性声明应当归为一组，并按照下面的顺序排列：1234- Positioning- Box model- Typographic- Visual &nbsp; &nbsp;&nbsp; &nbsp;由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。完整的属性列表及其排列顺序请参考 Recess。例：1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ 排版样式 font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ 视觉上的 background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ 杂类 opacity: 1; &#125; 3. 不要使用 @import与 标签相比，@import 指令要慢很多，不光增加了额外的请求次数，还会导致不可预料的问题。替代办法有以下几种： 使用多个 元素 通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件 通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能 请参考 Steve Souders 的文章了解更多知识。例： 1234&lt;!-- Use link elements --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt;@import url(&quot;more.css&quot;);&lt;/style&gt; 4. 媒体查询（Media query）的位置&nbsp; &nbsp;&nbsp; &nbsp;将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。下面给出一个典型的实例。 123456.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 5. 带前缀的属性当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。例： 12345/* Prefixed properties */.selector &#123; -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15); box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125; 6. 单行规则声明对于只包含一条声明的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。&nbsp; &nbsp;&nbsp; &nbsp;这样做的关键因素是为了错误检测 – 例如，CSS 校验器指出在 183 行有语法错误。如果是单行单条声明，你就不会忽略这个错误；如果是单行多条声明的话，你就要仔细分析避免漏掉错误了。12345678910111213/* Single declarations on one line */.span1 &#123; width: 60px; &#125;.span2 &#123; width: 140px; &#125;.span3 &#123; width: 220px; &#125;/* Multiple declarations, one per line */.sprite &#123; display: inline-block; width: 16px; height: 15px; background-image: url(../img/sprite.png);&#125;.icon &#123; background-position: 0 0; &#125;.icon-home &#123; background-position: 0 -20px; &#125;.icon-account &#123; background-position: 0 -40px; &#125; 7. 简写形式的属性声明（具体情况具体操作）&nbsp; &nbsp;&nbsp; &nbsp;在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。常见的滥用简写属性声明的情况如下：1234567* padding* margin* font* background* border* border-radius 大部分情况下，我们不需要为简写形式的属性声明指定所有值。例如，HTML 的 heading 元素只需要设置上、下边距（margin）的值，因此，在必要的时候，只需覆盖这两个值就可以。过度使用简写形式的属性声明会导致代码混乱，并且会对属性值带来不必要的覆盖从而引起意外的副作用。MDN（Mozilla Developer Network）上一片非常好的关于shorthand properties 的文章，对于不太熟悉简写属性声明及其行为的用户很有用。例： 1234567891011121314/* Bad example */.element &#123; margin: 0 0 10px; background: red; background: url(&quot;image.jpg&quot;); border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123; margin-bottom: 10px; background-color: red; background-image: url(&quot;image.jpg&quot;); border-top-left-radius: 3px; border-top-right-radius: 3px;&#125; 8. Less 和 Sass 中的嵌套&nbsp; &nbsp;&nbsp; &nbsp;避免非必要的嵌套。这是因为虽然你可以使用嵌套，但是并不意味着应该使用嵌套。只有在必须将样式限制在父元素内（也就是后代选择器），并且存在多个需要嵌套的元素时才使用嵌套 12345678// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123; &gt; th &#123; … &#125; &gt; td &#123; … &#125;&#125; 9. 注释代码是由人编写并维护的。请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。不要简单地重申组件或 class 名称。对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。123456789/* Bad example *//* Modal header */.modal-header &#123; ...&#125;/* Good example *//* Wrapping element for .modal-title and .modal-close */.modal-header &#123; ...&#125; 10. class 命名 class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。 避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。 class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 在为 Sass 和 Less 变量命名是也可以参考上面列出的各项规范。123456789/* Bad example */.t &#123; ... &#125;.red &#123; ... &#125;.header &#123; ... &#125;/* Good example */.tweet &#123; ... &#125;.important &#123; ... &#125;.tweet-header &#123; ... &#125; 11、选择器 对于通用元素使用 class ，这样利于渲染性能的优化。 对于经常出现的组件，避免使用属性选择器（例如，[class^=”…”]）。浏览器的性能会受到这些因素的影响。 选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。 只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。 123456789/* Bad example */span &#123; ... &#125;.page-container #stream .stream-item .tweet .tweet-header .username &#123; ... &#125;.avatar &#123; ... &#125;/* Good example */.avatar &#123; ... &#125;.tweet-header .username &#123; ... &#125;.tweet .avatar &#123; ... &#125; 12、代码组织 以组件为单位组织代码段。 制定一致的注释规范。 使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。 如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。 13、编辑器配置&nbsp; &nbsp;&nbsp; &nbsp;将你的编辑器按照下面的配置进行设置，以避免常见的代码不一致和差异： 用两个空格代替制表符（soft-tab 即用空格代表 tab 符）。 保存文件时，删除尾部的空白符。 设置文件编码为 UTF-8。 在文件结尾添加一个空白行。 参照文档并将这些配置信息添加到项目的 .editorconfig 文件中。例如：Bootstrap 中的 .editorconfig 实例。更多信息请参考 about EditorConfig。 参考：http://www.css88.com/doc/codeguide/]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON知识小结]]></title>
    <url>%2F2015%2F06%2F05%2F150605JSON%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、JSON 定义&nbsp;&nbsp;&nbsp;&nbsp;JSON全称 JavaScript Object Notation，是一种轻量级的文本数据交换格式，它是基于ECMAScript的一个子集，独立于语言，并且在java、C++、Python等其他语言中也有，所以JSON相当于一个中转站，能够达成各种语言间交换数据，也就是说能够实现互相通信，因为各个语言都能识别JSON，所以这些特性使JSON成为理想的数据交换语言,而其实我们大多数的业务逻辑也就是通过通信过来的数据再进行下一步开展的。 二、语法规则 （格式要求）1、数据在名称/值对中2、数据由逗号分隔(最后一个键/值对不能带逗号)，这个点一定要注意，有时候容易忽略3、花括号保存对象；方括号保存数组4、键必须使用双引号 注意跟js中的对象的区别，json并不属于js，是从js中抽出来的，源自于js独立出来的； 三、JSON解析&nbsp;&nbsp;&nbsp;&nbsp;在工作当中，我们经常会有这样的需求，需要客 户端向服务器端通过地址栏或者post、get提交数据，然后服务器端处理完数据之后，将计算的结果信息回传给客户端，那么这时就存在了一定的难度，特别是数据量较大时。这个时候数据的格式成了关键，所以我们应该能够选择到某种格式可以很方便的进行数据的组装，然后可以很方便的进行 解析那就再好不过了，这时JSON便是在这里的不二选择。那接下来你只需要在客户端向服务器提交信息的时候，先按照JSON的格式拼装好一个字符串，提交给服务器端;服务端在接到请求之后，就可以将从服务端返回的数据按照JSON的格式拼装好一个字符串，响应给客户端。&nbsp;&nbsp;&nbsp;&nbsp;另外需要知道不同的语言各自也都对应有其解析方法，需要解析完成后才能读取，下面在这里只是简要分析一下Javascript和PHP的解析方式； 1、Javascript 解析方法主要是这三种eavl()、 JSON.parse()、JSON.stringify()；例如如果Javascript想传递一个复杂的数据类型给PHP等后台语言,就先通过JSON.stringify()将其字符串化(JSON)后传过去,到PHP那边可以通过json_decode()解码成PHP能够使用的数据;那从后端响应回来的数据，Javascript可以通过JSON.parse()或者eavl()来进行解析就可以达到Javascript的对象了，接下来也就可以进行相应的业务逻辑了JSON兼容处理可以引入[json2.js](http://www.JSON.org/json2.js)这个文件 2、PHP解析方法json_encode(){将PHP数组转成json格式的字符串}json_decode(){由json格式的字符串转成PHP能用的数据}也就是说如果PHP想传递一个复杂的数据类型给Javascript,就先通过json_encode()其字符串化为(JSON)后传过去,到Javascript那边可以通过JSON.parse() 解码成Javascript能够使用的数据;总结：JSON体积小、解析方便且高效，在实际开发成为首选。另外工作当中可能 四、JSON 文件类型 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” 五、对比XML&nbsp;&nbsp;&nbsp;&nbsp;XML是一种标记语言，很类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。XML可以随意通过自定义标签使数据更加具有可读性； 1、语法规则1、必须有一个根元素2、不可有空格、不可以数字或.开头、大小写敏感3、不可交叉嵌套4、属性双引号（浏览器自动修正成双引号了）5、特殊符号要使用实体6、注释和HTML一样 2、对比虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了，所以现在大多数是采用的JSON格式进行传输数据]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null和undefined的区别]]></title>
    <url>%2F2015%2F06%2F05%2F150605null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[null和undefined的基本特点 null是一个表示”无”的对象，转为数值时为0； undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined主要用法undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：-（1）变量被声明了，但没有赋值时，就等于undefined。-（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。-（3）对象没有赋值的属性，该属性的值为undefined。-（4）函数没有返回值时，默认返回undefined。 null主要用法null表示”没有对象”，即该处不应该有值。典型用法是：-（1） 作为函数的参数，表示该函数的参数不是对象。-（2） 作为对象原型链的终点。 (3) 可以将在闭包中使用的对象，在不使用的时候可以将其设为null，从而可以通知回收机制回收，从而避免内存泄漏，提高性能。 结语先暂时总结这写地方，肯定还有没有涉及到的，以后在工作当中会继续完善，学无止境！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级实用的markdown-preview使用方法]]></title>
    <url>%2F2015%2F06%2F04%2F150604%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%9A%84markdown-preview%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown这款编辑软件你绝对值得拥有，特别方便去记录一些自己的日志和博客之类的，下面总结出两个能够实现markdown-preview的方法，也就是能够实现markdown文件的实时预览，并且还可以转换成html格式的文件生成出来，下面看正文吧！ 方法一：Node环境下安装markdown-preview这款命令行工具安装NodeJS&nbsp;&nbsp;&nbsp;&nbsp;上NodeJS官网下载即可，安装也很简单，一直下一步就可以，安装了NodeJS之后npm也就自动安装了，npm即使NodeJS的包管理系统，顺便说一下，因为markdown-preview的解析机制在这里是基于NodeJS的，所以要有Node环境，即是需要安装Node。 全局安装markdown-preview1npm install -g markdown-preview 注意一定要注意加上-g，这样能够确保是全局安装，更重要的是这样就能够直接从命令行直接调用markdown-preview了 使用markdown-preview&nbsp;&nbsp;&nbsp;&nbsp;直接在需要打开的目录下面通过以下命令即可：1markdown-preview 一个md文件名 接下来就会自动在你的默认浏览器中以html形式解析之后打开这个md文件，实现预览效果 方法二：在sublime中安装其插件安装sublime&nbsp;&nbsp;&nbsp;&nbsp;网上有很多安装教程，这里就不赘述了。 安装markdown-preview这款插件&nbsp;&nbsp;&nbsp;&nbsp;通过Ctrl+shift+P调出命令窗口，然后在命令窗口输入pcip（ package Control : install package）,等待一会就会出现一个窗口，也就是sublime中的所有插件，然后输入markdown-preview就可以等待sublime安装这个插件包了 使用markdown-preview&nbsp;&nbsp;&nbsp;&nbsp;首先在你需要打开的md文件界面当中通过Ctrl+shift+P调出命令窗口，然后输markdown-preview，直接点击，如果还有选择选项，选preview in Browser即可，会出现如图：接下来就会自动在你的默认浏览器中以html形式解析之后打开这个md文件，实现预览效果，另外不得不提下sublime这块编辑器真的很不错，又轻便，而且插件特别齐全，大家可以尝试下，不要以为我是做广告哦，因为我跟sublime半点关系都没有，只是友情提醒，这次的分享就到这里。]]></content>
      <categories>
        <category>实用小技能</category>
      </categories>
      <tags>
        <tag>markdown-preview</tag>
        <tag>实用小技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[While循环的一个实用的应用场景]]></title>
    <url>%2F2015%2F06%2F01%2F150601While%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;像while这样的循环相信大家会经常用到它的最基本的用法，但是一些技巧性的用法可能都很少在意，下面分享一下我使用while循环的一个小技巧性用法，也是让自己时刻注意要发散性思维的去coding！ 这主要是围绕push和apply方法来说,就是在ie8以下，apply方法的第二个参数如果是伪数组的话会报错&nbsp;&nbsp;&nbsp;&nbsp;先来看下面这段代码 123456789&lt;!-- 未使用apply的时候，也就是未启用调用上下文模式 --&gt;var arr = [1,2,3];arr.push([4,5,6]);console.log(&apos;arr&apos;,arr);&lt;!-- 上面的输出结果为：arr [1, 2, 3, [4,5,6]] --&gt;var arr1 = [1,2,3];arr1.push.apply(arr,[4,5,6]);console.log(&apos;arr1&apos;,arr1);&lt;!-- 上面的输出结果为：arr1 [1, 2, 3, 4, 5, 6] --&gt; 上面涉及到了apply的用法，其实apply用法并不难，但是它的作用还是不小的，在Javascript中很多优秀的类库当中都能看到它的身影，因为它具有一个强大的作用，就是“调用上下文”；用法如下：12apply(上下文，[arg1, arg2, ...])fn.apply(a,[1,2]); 解析：apply的参数，第一个参数表示指定的this，第二个参数要求是数组，表示函数的参数,在上面也就是1,2时fn的参数，也就是相当于a.fn(1,2);也就是以a作为上下文调用fn，然后fn里面传入了1和2这两个参数；这是封装了一个push方法来解决apply第二个参数是伪数组的兼容问题； 12345678910111213141516&lt;!-- context是指的上下文，大家可以先不用在意这个context，只需要知道`context.getElementsByTagName(tag)`获得了一个伪数组。 --&gt;var getTag = function(tag,context,results) &#123; results = results || []; try &#123; results.push.apply(results,context.getElementsByTagName(tag)); &#125; catch(e) &#123; myPush(results,context.getElementsByTagName(tag)); &#125; return results;&#125;;var myPush = function(target,els) &#123; var j = target.length, i = 0; while((target[j++] = els[i++]))&#123;&#125; //这里的els[i++]总会有取值完的时候，那时候就会变为假，自动跳出while循环，这也 算是while循环的一个小技巧 ， target.length = j - 1; //因为伪数组的length不会自己增加，所以手动赋值一下，避免出错 &#125; 结语&nbsp;&nbsp;&nbsp;&nbsp;记录下这个小场景也是为了警醒自己在工作当中解决问题的时候要学会发散思维的去解决一些兼容问题，还有一些应用场景。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形参与实参]]></title>
    <url>%2F2015%2F05%2F16%2F150516%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;今天遇到了一个问题，以前自己以为形参是不占内存的，并且以为形参就是跟实参保持一致，今天经过了一下系统分析后，才发现自己原先的认识真实太浅薄了，下面由一个小demo引出问题：12345678910111213var obj1 = &#123; foo: &apos;bar&apos; &#125;;var obj2 = obj1;function changeObj(o) &#123; o = 1; &#125;changeObj(obj2);console.log(obj1); // =&gt; &#123; foo: &apos;bar&apos; &#125;console.log(obj2); // =&gt; &#123; foo: &apos;bar&apos; &#125; &nbsp;&nbsp;&nbsp;&nbsp;是不是有些人对这个结果很诧异，以为为什么控制台输出的obj2还是原先的{ foo: ‘bar’ }而不是1呢，我刚一开始也认为错了，有些时候认识到错误之后，及时去改正即可，所以接下来我就查阅了下相关资料，但是发现也都是写的不太全面，索性自己记录下来，到时候翻阅起来也方便，好了，下面开始分析过程：&nbsp;&nbsp;&nbsp;&nbsp;其实对于上面的函数调用( changeObj(obj2))来说，首先在函数内部会进行一下这个操作 function changeObj(o) { &nbsp;&nbsp;&nbsp;&nbsp;o = obj2 &nbsp;&nbsp;&nbsp;&nbsp;o = 1; }也就是只要一进去函数内部，首要进行的是形参等于实参， 在这里obj2是引用类型，所以等于将obj2的引用（这里是也可以用地址做个比喻，就是实际不存储，只是有一个指向而已，其实并不严谨，但是现在大家可以先这样理解）传给了o，此时o也指向了obj2，这时候如果对o进行一些添加属性或方法的操作，都会体现到obj2所指向的对象上面，下面会列上详细代码，先说这个，是直接对o进行了一次赋值操作，这时候等于是切断了o与obj2的联系，所以obj2并未改变；再对上面的demo稍加修改，变式11234567891011121314var obj1 = &#123; foo: &apos;bar&apos; &#125;;var obj2 = obj1;function changeObj(o) &#123; o.foo = &apos;baz&apos;; o = &#123;&#125;; &#125;changeObj(obj2);console.log(obj1); // =&gt; &#123; foo: &apos;baz&apos; &#125;console.log(obj2); // =&gt; &#123; foo: &apos;baz&apos; &#125; &nbsp;&nbsp;&nbsp;&nbsp;此时通过o.foo = ‘baz’;的修改对obj1和obj2都得到了体现，这个不难理解，因为对于obj1 = obj2这一步来说，本身变量值存储引用类型的引用，所以经历这一步解析之后，obj1和obj2会指向同一个对象，也可以说是同一块内存，那通过changeObj(obj2)之后，这个函数内部的解析在上面已经提及，在o还未赋值之前，对o进行的属性操作都会体现在obj2上，因为在调用的函数内部，o和obj2指向同一个对象，当然obj1也会跟着改变；再对上面的demo稍加修改，变式2123456789101112131415var obj1 = &#123; foo: &apos;bar&apos; &#125;;var obj2 = obj1;function changeObj(o) &#123; o = &#123;&#125;; o.foo = &apos;baz&apos;; &#125;changeObj(obj2);console.log(obj1); // =&gt; &#123; foo: &apos;bar&apos; &#125;console.log(obj2); // =&gt; &#123; foo: &apos;bar&apos; &#125; 这次只是让changeobj内部o的赋值操作放到了上面，这次再对o进行的属性操作并未对obj1和obj2产生影响，因为在解析完 o={} 之后o和obj2的引用链就被切断了，也可以说接下来o进行的任何操作都与obj2无关了，所以控制台输出的结果也正印证了； &nbsp;&nbsp;&nbsp;&nbsp;综上所述，总结出以下几点: 没有调用函数时，形参是不占内存的。调用函数时，会给形参分配内存单元，在调用结束时，即刻释放所分配的内存单元。也就是说形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。 实参出现在主调函数中，进入被调函数后，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。 因此应提前用赋值，输入等办法使实参获得确定值。另外实参占用的内存直到程序结束释放。 使用值传递时，实参和形参是各自独立的。一进入函数进行的 o = obj2 这样是拷贝了obj2的值给o，这时o 与 obj2占用两个不同的内存单元；而使用 引用传递时，一进入函数进行的 o = obj2 这样实际上是拷贝了obj2的引用（地址）给o，这时o 与 obj2指向同一个对象（内存）。 以前我们都没有注意到形参，以为形参不占内存，现在回过头来看，其实我们对于传的形参都是为了使用它而不是为了改变它的，所以没有出现一些错误，当试图改变的时候，就不一样了，这时候只要你一旦对这个形参进行了赋值操作，不管是简单数据类型还是复杂数据类型，都不会对传进去的对象产生作用了，所以以后在使用函数时千万不要在内部对形参进行赋值操作！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript分层概念]]></title>
    <url>%2F2015%2F05%2F01%2F150501Javascript%E5%88%86%E5%B1%82%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;一个项目前期的分层设计是很重要的，一个好的分层结构会使我们的代码组织条理更清晰，减少冗余，提髙代码重用率。和 CSS — 样，我 觉得将 JavaScript 也分成三层也是比较合理的，从下往上依次是 base 层、 common 层 和 page 层 。需要 说明的是，如何分层是一件主观的事情，为 的 是 “ 把事情变得更好” ，没有对和错之 分，只有好和坏，我并不是说 “ 只有这样分层才是对的”，下面简单列出这几个层的一个介绍 1. base 层&nbsp;&nbsp;&nbsp;&nbsp;位于三层的最底端，这一层有两个职责。职责一是封装不同浏览器下 JavaScript 的差异，提供统一的接口，我们可以依靠它来完成跨浏览器兼容的工作。职责二是扩展JavaScript语言底层提供的接口，让它提供更多更为易用的接口。 base 层的功能是给 common 层 和 page 层提供接口 2. common 层&nbsp;&nbsp;&nbsp;&nbsp;位于三层的中间，依赖 base 层提供的接口。 commom 层提供可供复用的组件，它 是典型的 MVC 模式中的 M, 和页面内的具体功能没有直接关系。 common 层的功能是给 page 层提供组件。 3. page 层&nbsp;&nbsp;&nbsp;&nbsp;位于三层的最顶端。这一层和页面里的具体功能需求直接相关，相当于 MVC模式中的C, page 层依赖于 base 层 和 common 层。 page 层的功能是完成页面内的功能需求。引申：其实page 层是和页面里的具体功能需求直接相关。如果页面里的功能需求 很简单，页面里可以没有 base 层代码，甚至可以没有 common 层代码，但一定会有 page 层 代码。 可以说base 层 和 common 层都是属于框架级的， page 层是属于应用级的，它可以调用 base 层的接口和 common 层的组件。 下面举例形象化这三者的关系：&nbsp;&nbsp;&nbsp;&nbsp;我们平时绝大部分工作都是在 page 层完成的，有了分层的概念， page 层的工作就非 常轻松了。如 果 base 层 和 common 层足够丰富和稳定，我们就可以将精力全部放在具体 业务逻辑上，跨浏览器兼容和常用组件都可以交给 base 层 和 common 层去完成，一方面 可以极大地提高开发效率，另一方面也可以大大提高代码的重用率，减小网页的大小，下面举一个生动的例子：&nbsp;&nbsp;&nbsp;&nbsp;如果没有 base 层 和 common 层 ，直接用原生 JavaScript 写程序，就像是开着汽车行 驶在一条不平坦的泥路上，一路上有凸起的石块（浏览器兼容带来的阻碍） ，也有凹陷 的 沼 泽 （原生 JavaScript 提 供 的 底 层 接 口 不 足）&nbsp;&nbsp;&nbsp;&nbsp;引 入 base 层之后呢，就像铲平了泥路上凸起的石块（提供跨浏览器兼容的接口） ，填满了 凹陷的沼泽（弥补原生 JavaScript 底层接口的不足） 。在 base 层的基础上写程序，就像 汽车行驶在一条平坦的泥路上。&nbsp;&nbsp;&nbsp;&nbsp;继 base 层之后，再 引 入 common层,就像在平坦的泥路上铺上了一层沥青，路再也不是普通的泥路了，它成了高速公路。在 base 层 和 common 的基础上写Javascript, 就像开着汽车在高速公路上飞驰！ 结语&nbsp;&nbsp;&nbsp;&nbsp;其实在平常的工作学习中，一定要学会归类学习，重要的去学习一些思想，就像这次的这个分层理念，其实对于Javascript和CSS都是非常适用的，并且最终都是能做到是自己的代码精炼和具有条理的，重要的是可维护性会很强。&nbsp;&nbsp;&nbsp;&nbsp;每当读书的时候，就会发现自己很渺小，需要去学习的东西还有很多，随时学习的心态必须时刻具备，上面的总结是从Web前端开发修炼之道当中凝练出来的，记录下来，也是提醒下自己的分层意识，随着现在前端越来越成熟和规范的时候，我们每一个前端人都应该时刻要去具备一颗追求卓越的心态，让自己尽快提升一个高度，特在此共勉！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决自适应的两栏布局方式]]></title>
    <url>%2F2015%2F04%2F29%2F150429%E8%A7%A3%E5%86%B3%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;今天也算是一个小需求吧，需要实现一下这个，自己简单摸索了一下，总结出了两种方法，实现这样的方法会用很多种，在这里自己也是仅仅列出自己构思的这两种记录下来，下面开始 首先是第一种方式-运用了文本环绕的概念&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;简单科普一下文本环绕的概念,文字环绕是Microsoft Office Word软件的一种排版方式,主要用于设置Word文档中的图片文本框、自选图形、剪贴画、艺术字等对象与文字之间的位置关系.一般包括四周型、紧密型、衬于文字下方、浮于文字上方、上下型、穿越型等多种文字环绕方式,上面这个文本环绕的概念是节选自百科。 &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面列出实现现实需求中的思路：当文本在另一个容器当中，容器是overflow：hidden的时候。那么这个时候这个盒子就变成了一个绝缘的盒子，不去影响任何外部的元素并且内容使用剩余的宽度。下面简单列出，注意下面的代码仅供实例，丝毫不具备优化之类的思想，因为大家主要是了解这个布局思路即可。先附上一个简图 ![layout](150429解决自适应的两栏布局方式/layout.png) 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; html,body &#123; height: 100%; &#125; .sidebar &#123; width: 100px; height: 60%; float: left; background-color: orange; &#125; .main &#123; height: 100%; overflow: hidden; background-color: skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;sidebar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这样一个简单地侧边栏固定，中间宽度自适应的效果就实现了，下面来看第二种实现方式 方法二-利用绝对定位来实现 &nbsp;&nbsp;&nbsp;&nbsp;主要是利用设置了绝对定位，也即是设置了position:absolute;这样当前元素就脱离了标准流，就不占位置了，接下来给右边盒子设置100%宽，再设置上padding-left为左边盒子的宽度即可实现；当然当遇到两端都有一个栏的情况下可以让其两端都为绝对定位，中间的盒子设置100%宽，那这样的话就需要左右padding把那两个盒子的宽给设置出来即可。下面列出实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; html, body &#123; height: 100%; &#125; .sidebar1 &#123; position: absolute; left: 0; width: 100px; height: 100%; background-color: orange; &#125; .sidebar2 &#123; position: absolute; top: 0; right: 0; width: 100px; height: 100%; background-color: orange; &#125; .main &#123; width: 100%; height: 100%; padding-left: 100px; padding-right: 100px; overflow: hidden; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; //这里是列出了三栏的情况，两栏直接去掉一栏，在上面再对main的padding做一下修改即可 &lt;div class=&quot;sidebar1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;div class=&quot;sidebar2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结语 &nbsp;&nbsp;&nbsp;&nbsp;其实这种布局在移动端布局还是比较常见，应用场景：有一栏或两栏宽固定，剩下的一栏宽度自适应;再次重申，这只是自己做的一个小结，也希望能帮助到有需要的人，当然对于大神来说，不喜勿喷，今天这个就到这里了。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText3快捷键总结]]></title>
    <url>%2F2015%2F04%2F03%2F150403SublimeText3%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[sublime这款轻便的编辑器，反正我是觉得很好用，下面是一些常用快捷键,愿能帮助你更畅快的coding！ 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。例如：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。例如：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。例如 ：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。应用场景：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 垂直等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式，有的电脑需要加上fn，因为快捷键的冲突 Shift+F11 免打扰模式]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github托管自己的网页]]></title>
    <url>%2F2015%2F03%2F02%2F150302%E4%BD%BF%E7%94%A8github%E6%89%98%E7%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[一、GIT基本命令操作1. 初始化一个本地GIT仓储 （仓库）12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 2. 查看本地仓储的变更状态1git status 用于查看本地仓储的状态第一次查看，显示的是一些没有被跟踪的文件git status -s // -s 是输出简要的变更日志 3. 添加本地暂存（托管）文件1git add (--all) 初始的时候必须这样添加一下，后面是–all或者.(点），这样说明是添加所有文件到暂存区，也可以将一个没有被跟踪的文件添加到跟踪列表 4. 添加本地GIT忽略清单文件在代码库文件夹的根目录添加一个.gitignore文件，此文件用于说明忽略的文件有哪些，例如类似于node_modules这种性质的文件是不应该被跟踪 5. 提交被托管的文件变化到本地仓储1git commit (-m) &quot;描述信息&quot; 将本地的变化提交的本地的仓库文件夹归档,一般在有了一个小单元的整体变化后再提交,也就是也没必要有一点点改动就提交，这样徒增自己的版本数量 6. 对比差异1git diff 可以用于对比当前状态和版本库中状态的变化 7. 提交日志1git log 可以查看提交日志 8. 回归到指定版本1git reset --hard 9. 为仓储添加远端（服务器端）地址12345git remote add origin (github仓库地址)//https://github.com/zwxs/github-demo.git将本地仓储的提交记录推送到远端的master分支git push -u origin master拉取远端master分支的更新记录到本地git pull origin master 二、一般我们也只需像官网那样简单几步12345git init # 初始化一个git本地仓库git add README.md # 添加一个README.md文件到缓存区git commit -m &quot;first commit&quot; # 提交描述信息git remote add origin https://github.com/lsqy/lsq.git # 为仓储添加远端（服务器端）地址git push -u origin master # 将本地仓储的提交记录推送到远端的master分支 三、接下来托管自己的网页到github上，也是本次总结的一个重点 这也算是引入了GIT分支的概念 - 创建一个新的分支1git branch gh-pages - 切换到新的分支1git checkout gh-pages - 将本地的分支推送到远端1git push -u origin gh-pages 接下来访问下lsqy.github.io/test即可看到托管上的网页了,注意这里的lsqy是我的github用户名，你需要改成自己的这样以后自己的一些示例就可以很方便的进行演示了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用原生JS实现动画-缓动动画]]></title>
    <url>%2F2015%2F02%2F04%2F150204%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;缓动动画跟前面的匀速动画相比肯定会更加细腻，在现实中还是缓动应用的较多，下面的同样列出实现主要有几个点： 效果是实现一个对象（obj）移动到目标位置（target) 用之前先清一下定时器，防止导致出现存在多个定时器，无法停下来，导致出现bug; 定时器间隔设为25ms是因为现在主流的大多是25ms效果比较好一点，具体你也可以根据需要改变; step是指的步长，在这里的step是实现缓动效果的关键，step是通过目标点和当前位置的距离差来决定的，这样就会有随着距离减小会慢慢变小，也就是会有慢慢减速，先快后慢的效果 清除定时器的时间点判断-这次就不用向匀速动画中那样通过手动在快接近目标点的时候将其赋值为目标点，因为这里上面的step都是除以10，并且也对step在0位置做了判断，所以可以达到当前位置等于目标位置，也就是可以顺利清除定时器；下面是具体代码实现：123456789101112131415function animate(obj, target) &#123; //缓动动画 事实证明还是缓动效果比较细腻 clearInterval(obj.timer); //防止重复调用，用前先清定时器 obj.timer = setInterval(function() &#123; var leader = obj.offsetLeft; //读取的时候用offsetTop确保也能读取到不是行内的样式 var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //通过下面这个方法能够在控制台中体会到数据的渐变 console.log(&quot;target:&quot; + target + &quot;---leader:&quot; + leader + &quot;---step:&quot; + step); if (leader != target) &#123; obj.style.left = leader + step + &quot;px&quot;; //赋值的时候就用top设置行间样式 &#125; else &#123; clearInterval(obj.timer); &#125; &#125;, 25)&#125; 下面是使用这个封装的animate实现的缓动动画效果，另外这个案例当中还穿插了一下无缝滚动的效果，能够实现最后一张平滑的切换到第一张，下面附上代码： 下面的代码并不是特别规范，只是站在初学者的角度通俗的将几个重要的点展示出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt; &lt;div id=&apos;box&apos;&gt; &lt;div class=&quot;screen&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div id=&quot;arr&quot;&gt;&lt;span id=&quot;left&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span id=&quot;right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;var box = document.getElementById(&quot;box&quot;), screen = box.children[0], ul = screen.children[0], ullis = ul.children, ol = screen.children[1], imgWidth = screen.offsetWidth, arr = document.getElementById(&quot;arr&quot;), arrLeft = document.getElementById(&quot;left&quot;), arrRight = document.getElementById(&quot;right&quot;), pic = 0, square = 0, timer = null， ollis = ol.children;&lt;!-- 根据图片的数量生成小按钮 --&gt;for (var i = 0; i &lt; ullis.length; i++) &#123; var li = document.createElement(&quot;li&quot;); ol.appendChild(li); li.innerHTML = i + 1;&#125;ollis[0].className = &quot;current&quot;;var firstImg = ullis[0].cloneNode(true); //如果不加上.cloneNode(true),只是单纯的把li移动了，而不是重新复制一个ul.appendChild(firstImg); //这样能够很好地实现无缝衔接；// 根据按钮来让图片滚动for (var j = 0; j &lt; ollis.length; j++) &#123; ollis[j].index = j; ollis[j].onmouseover = function() &#123; for (var k = 0; k &lt; ollis.length; k++) &#123; ollis[k].className = &quot;&quot;; &#125; this.className = &quot;current&quot;; var target = -this.index * imgWidth; animate(ul, target); square = pic = this.index; &#125;&#125;// 鼠标放到盒子上面清除定时器，并显示箭头box.onmouseover = function() &#123; arr.style.display = &quot;block&quot;; clearInterval(timer); &#125;// 鼠标离开盒子重新设置定时器，并隐藏箭头box.onmouseout = function() &#123; arr.style.display = &quot;none&quot;; timer = setInterval(playnextR, 2000);&#125;arrRight.onclick = function() &#123; playnextR();&#125;arrLeft.onclick = function() &#123; playnextL();&#125;//封装向右切换的动画函数function playnextR() &#123; if (pic == ullis.length - 1) &#123; //注意这里是pic == ullis.length-1，先前写成了pic == ollis.length-1,导致出现bug ul.style.left = 0; pic = 0; &#125; pic++; var target = -imgWidth * pic; animate(ul, target); if (square &lt; ollis.length - 1) &#123; square++; &#125; else &#123; square = 0; &#125; for (var i = 0; i &lt; ollis.length; i++) &#123; ollis[i].className = &quot;&quot;; &#125; ollis[square].className = &quot;current&quot;;&#125;//封装向左切换的动画函数function playnextL() &#123; if (pic == 0) &#123; ul.style.left = -imgWidth * (ullis.length - 1) + &quot;px&quot;; //后面的这个px一定要注意加上去； pic = ullis.length - 1; &#125; pic--; var target = -imgWidth * pic; animate(ul, target); if (square &gt; 0) &#123; square--; &#125; else &#123; square = ollis.length - 1; &#125; for (var i = 0; i &lt; ollis.length; i++) &#123; ollis[i].className = &quot;&quot;; &#125; ollis[square].className = &quot;current&quot;;&#125;//4.添加自动滚动//相当于每秒钟按下一次右箭头timer = setInterval(playnextR, 2000);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用原生JS实现动画-匀速动画]]></title>
    <url>%2F2015%2F02%2F02%2F150202%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB-%E5%8C%80%E9%80%9F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;其实动画效果无非就是根据时间一直移动而已，只不过移动的快而已，所以肯定需要通过定时器来实现，下面的实现主要有几个点： 效果是实现一个对象（obj）移动到目标位置（target) 用之前先清一下定时器，防止导致出现存在多个定时器，无法停下来，导致出现bug; 定时器间隔设为25ms是因为现在主流的大多是25ms效果比较好一点，具体你也可以根据需要改变; step是指的步长，也就是每25ms走的距离，同样这个step也是可以调整的，step在这里做判断是因为目标位置有时候会小于对象现在所处的位置，也就是target &lt; leader,这时就需要step变为负值了。 清除定时器的时间点判断-当目标位置与现在的位置的差值小于step的时候，清除，需要使用Math.abs是因为step有可能是负值下面是具体代码实现：123456789101112131415function animate(obj,target) &#123; //匀速动画 clearInterval(obj.timer); //用之前先清定时器 obj.timer = setInterval(function()&#123; var leader = obj.offsetLeft, step = 20; step = leader &lt; target ? step : -step; //根据当前位置与目标位置的大小来确定步长的正负； if (Math.abs(leader - target) &gt; Math.abs(step)) &#123; obj.style.left = leader + step + &quot;px&quot;; //注意加上px &#125; else &#123; clearInterval(obj.timer); //手动将快要到达终点的对象放到终点,保证最终停在目标位置 obj.style.left = target + &quot;px&quot;; &#125; &#125;, 25) &#125; 下面是使用这个封装的animate实现的匀速动画效果;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局-让一个盒子水平垂直居中的几种方法]]></title>
    <url>%2F2014%2F12%2F01%2F141201CSS%E5%B8%83%E5%B1%80-%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;实现问题的方式永远不只一种，这里也是根据一个经常会用到的需求来做一个小结，下面列出了5种能够让一个盒子水平垂直居中的方法，也是在提醒自己在工作当中要随时记得发散思维，不要太固化，提高自己灵活解决问题的能力，问题很简单，就是实现如图效果：下面上代码： 方法一、最传统的方法123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;居中问题&lt;/title&gt; &lt;style&gt; .outer &#123; position: relative; width: 300px; height: 300px; background-color: orange; &#125; .inner &#123; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; width: 100px; height: 100px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 大体实现思路就是先设置父盒子为相对定位，然后设置子盒子为绝对定位，设置其left和top都为50%，然后再设置margin-top和margin-left为它们各自高和宽的一半即可，这一个方法不足的地方是必须需要先知道子盒子的宽高，设置了居中还得靠js来获取就有点兴师动众了，看下面的方法 方法二、巧妙的运用了margin:auto1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;居中问题&lt;/title&gt; &lt;style&gt; .outer &#123; position: relative; width: 300px; height: 300px; background-color: orange; &#125; .inner &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; width: 100px; height: 100px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 大体实现思路就是先设置父盒子为相对定位，然后设置子盒子为绝对定位，设置其left、right、top、bottom都为0，再设置margin：auto即可； 方法三、利用C3属性transform123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;居中问题&lt;/title&gt; &lt;style&gt; .outer &#123; position: relative; width: 300px; height: 300px; background-color: orange; &#125; .inner &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 100px; height: 100px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这一点实现思路跟方法一差不多，但是弥补了方法一的缺陷，不需要提前知道子盒子的宽高了，兼容性这块兼容主流的，当然ie6/7还是需要传统解决的 方法四、利用flex布局1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;居中问题&lt;/title&gt; &lt;style&gt; .outer &#123; width: 300px; height: 300px; background-color: orange; margin: 50px auto; display: flex; justify-content: center; align-items: center; &#125; .inner &#123; width: 100px; height: 100px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 大体实现思路就是只需要设置父盒子display为flex，然后再设置其justify-content: center;（主轴方向对齐，可以调整子元素在主轴方向上的对齐方式）align-items: center;（定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式）;扩展性较强，移动端常用； 方法五、flex布局结合margin:auto123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;居中问题&lt;/title&gt; &lt;style&gt; .outer &#123; width: 300px; height: 300px; background-color: orange; display: flex; &#125; .inner &#123; width: 100px; height: 100px; background-color: skyblue; margin: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 大体实现思路也是先设置父盒子display：flex，然后再设置子盒子margin：auto即可,扩展性较强，移动端常用； 附加一个图片水平垂直居中123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图片水平居中&lt;/title&gt; &lt;style&gt; .outer &#123; width: 300px; height: 300px; border: 1px solid #000; display: table-cell; text-align: center; vertical-align: middle; &#125; img &#123; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;img src=&quot;demo.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 主要是指定父盒子为display: table-cell;然后设置text-align: center;vertical-align: middle;即可 结语当然可能还有一些方式可以实现，这里只是记录下，有需要的朋友可以参考！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
</search>
